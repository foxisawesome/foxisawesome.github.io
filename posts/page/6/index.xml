<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Q. Weng</title>
    <link>https://foxisawesome.github.io/posts/</link>
    <description>Recent content in Posts on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 06 Dec 2020 16:48:55 -0500</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>613 Shortest Distance in a Line</title>
      <link>https://foxisawesome.github.io/posts/613-shortest-distance-in-a-line/</link>
      <pubDate>Wed, 14 Oct 2020 19:50:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/613-shortest-distance-in-a-line/</guid>
      <description>LC 613 Shortest Distance in a Line   Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.
Write a query to find the shortest distance between two points in these points.
| x | |-----| | -1 | | 0 | | 2 |  The shortest distance is &amp;lsquo;1&amp;rsquo; obviously, which is from point &amp;lsquo;-1&amp;rsquo; to &amp;lsquo;0&amp;rsquo;. So the output is as below:</description>
    </item>
    
    <item>
      <title>603 Consecutive Available Seats</title>
      <link>https://foxisawesome.github.io/posts/603-consecutive-available-seats/</link>
      <pubDate>Wed, 14 Oct 2020 19:47:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/603-consecutive-available-seats/</guid>
      <description>LC 603 Consecutive Available Seats   Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?
| seat_id | free | |---------|------| | 1 | 1 | | 2 | 0 | | 3 | 1 | | 4 | 1 | | 5 | 1 |  Your query should return the following result for the sample case above.</description>
    </item>
    
    <item>
      <title>602 Friend Requests Ii Who Has the Most Friends</title>
      <link>https://foxisawesome.github.io/posts/602-friend-requests-ii-who-has-the-most-friends/</link>
      <pubDate>Wed, 14 Oct 2020 19:41:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/602-friend-requests-ii-who-has-the-most-friends/</guid>
      <description>LC 602 Friend Requests Ii Who Has the Most Friends Write a query to find the the people who has most friends and the most friends number under the following rules: It is guaranteed there is only 1 people having the most friends. The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value. For the sample data above,</description>
    </item>
    
    <item>
      <title>974 Subarray Sums Divisible by K</title>
      <link>https://foxisawesome.github.io/posts/974-subarray-sums-divisible-by-k/</link>
      <pubDate>Wed, 14 Oct 2020 17:17:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/974-subarray-sums-divisible-by-k/</guid>
      <description>LC 974 Subarray Sums Divisible by K   Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.
Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]   Solution 2020-10-14 Notes:  About the problems - sum of contiguous subarray , prefix sum is a common technique.</description>
    </item>
    
    <item>
      <title>909 Snakes and Ladders</title>
      <link>https://foxisawesome.github.io/posts/909-snakes-and-ladders/</link>
      <pubDate>Wed, 14 Oct 2020 15:51:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/909-snakes-and-ladders/</guid>
      <description>LC 909 Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation: At the beginning, you start at square 1 [at row 5, column</description>
    </item>
    
    <item>
      <title>1428 Leftmost Column With at Least a One</title>
      <link>https://foxisawesome.github.io/posts/1428-leftmost-column-with-at-least-a-one/</link>
      <pubDate>Tue, 13 Oct 2020 20:37:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1428-leftmost-column-with-at-least-a-one/</guid>
      <description>LC 1428 Leftmost Column With at Least a One (This problem is an interactive problem.) A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;rsquo;t exist, return -1. You can&amp;rsquo;t access the Binary Matrix</description>
    </item>
    
    <item>
      <title>1581 Customer Who Visited but Did Not Make Any Transactions</title>
      <link>https://foxisawesome.github.io/posts/1581-customer-who-visited-but-did-not-make-any-transactions/</link>
      <pubDate>Tue, 13 Oct 2020 20:09:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1581-customer-who-visited-but-did-not-make-any-transactions/</guid>
      <description>LC 1581 Customer Who Visited but Did Not Make Any Transactions Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits. Return the result table sorted in any order. The query result format is in the following example: Visits +----------+-------------+ | visit_id | customer_id | +----------+-------------+ | 1 | 23 | |</description>
    </item>
    
    <item>
      <title>1613 Find the Missing Ids</title>
      <link>https://foxisawesome.github.io/posts/1613-find-the-missing-ids/</link>
      <pubDate>Tue, 13 Oct 2020 20:03:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1613-find-the-missing-ids/</guid>
      <description>LC 1613 Find the Missing Ids Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following</description>
    </item>
    
    <item>
      <title>1587 Bank Account Summary II</title>
      <link>https://foxisawesome.github.io/posts/1587-bank-account-summary-ii/</link>
      <pubDate>Tue, 13 Oct 2020 19:51:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1587-bank-account-summary-ii/</guid>
      <description>LC 1587 Bank Account Summary II Write an SQL query to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. Return the result table in any order. The query result format is in the following example. Users table: +------------+--------------+ | account | name | +------------+--------------+ | 900001</description>
    </item>
    
    <item>
      <title>654 Maximum Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/654-maximum-binary-tree/</link>
      <pubDate>Tue, 13 Oct 2020 16:05:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/654-maximum-binary-tree/</guid>
      <description>LC 654 Maximum Binary Tree Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree</description>
    </item>
    
    <item>
      <title>106 Construct Binary Tree From Inorder and Postorder Traversal</title>
      <link>https://foxisawesome.github.io/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Tue, 13 Oct 2020 15:28:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>LC 106 Construct Binary Tree From Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution 2020-10-13 Notes: 和 LC 105 一个道理。 # Definition</description>
    </item>
    
    <item>
      <title>105 Construct Binary Tree From Preorder and Inorder Traversal</title>
      <link>https://foxisawesome.github.io/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Tue, 13 Oct 2020 15:21:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>LC 105 Construct Binary Tree From Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution 2020-10-13 Notes: 这题关键是 root 在 ino</description>
    </item>
    
    <item>
      <title>116 Populating Next Right Pointers in Each Node</title>
      <link>https://foxisawesome.github.io/posts/116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Tue, 13 Oct 2020 14:59:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/116-populating-next-right-pointers-in-each-node/</guid>
      <description>LC 116 Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer</description>
    </item>
    
    <item>
      <title>226 Invert Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Oct 2020 09:16:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/226-invert-binary-tree/</guid>
      <description>LC 226 Invert Binary Tree   nvert a binary tree.
Input:
 4 / \ 2 7 / \ / \ 1 3 6 9  Output:
 4 / \ 7 2 / \ / \ 9 6 3 1   Solution 2020-10-13 Notes:    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>453 Minimum Moves to Equal Array Elements</title>
      <link>https://foxisawesome.github.io/posts/453-minimum-moves-to-equal-array-elements/</link>
      <pubDate>Sun, 11 Oct 2020 21:45:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/453-minimum-moves-to-equal-array-elements/</guid>
      <description>LC 453 Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Input: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4] Solution 2020-10-11 Notes: 很巧的一</description>
    </item>
    
    <item>
      <title>547 Friend Circles</title>
      <link>https://foxisawesome.github.io/posts/547-friend-circles/</link>
      <pubDate>Sun, 11 Oct 2020 21:26:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/547-friend-circles/</guid>
      <description>LC 547 Friend Circles There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given</description>
    </item>
    
    <item>
      <title>1280 Students and Examinations</title>
      <link>https://foxisawesome.github.io/posts/1280-students-and-examinations/</link>
      <pubDate>Sun, 11 Oct 2020 15:57:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1280-students-and-examinations/</guid>
      <description>LC 1280 Students and Examinations   Write an SQL query to find the number of times each student attended each exam.
Order the result table by student_id and subject_name.
The query result format is in the following example:
Students table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | | 13 | John | | 6 | Alex | +------------+--------------+ Subjects table: +--------------+ | subject_name | +--------------+ | Math | | Physics | | Programming | +--------------+ Examinations table: +------------+--------------+ | student_id | subject_name | +------------+--------------+ | 1 | Math | | 1 | Physics | | 1 | Programming | | 2 | Programming | | 1 | Physics | | 1 | Math | | 13 | Math | | 13 | Programming | | 13 | Physics | | 2 | Math | | 1 | Math | +------------+--------------+ Result table: +------------+--------------+--------------+----------------+ | student_id | student_name | subject_name | attended_exams | +------------+--------------+--------------+----------------+ | 1 | Alice | Math | 3 | | 1 | Alice | Physics | 2 | | 1 | Alice | Programming | 1 | | 2 | Bob | Math | 1 | | 2 | Bob | Physics | 0 | | 2 | Bob | Programming | 1 | | 6 | Alex | Math | 0 | | 6 | Alex | Physics | 0 | | 6 | Alex | Programming | 0 | | 13 | John | Math | 1 | | 13 | John | Physics | 1 | | 13 | John | Programming | 1 | +------------+--------------+--------------+----------------+   Solution 2020-10-11 Notes: SELECT a.</description>
    </item>
    
    <item>
      <title>1205 Monthly Transactions II</title>
      <link>https://foxisawesome.github.io/posts/1205-monthly-transactions-ii/</link>
      <pubDate>Sun, 11 Oct 2020 15:45:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1205-monthly-transactions-ii/</guid>
      <description>LC 1205 Monthly Transactions II   Write an SQL query to find for each month and country, the number of approved transactions and their total amount, the number of chargebacks and their total amount.
Note: In your query, given the month and country, ignore rows with all zeros.
The query result format is in the following example:
Transactions table: +------+---------+----------+--------+------------+ | id | country | state | amount | trans_date | +------+---------+----------+--------+------------+ | 101 | US | approved | 1000 | 2019-05-18 | | 102 | US | declined | 2000 | 2019-05-19 | | 103 | US | approved | 3000 | 2019-06-10 | | 104 | US | approved | 4000 | 2019-06-13 | | 105 | US | approved | 5000 | 2019-06-15 | +------+---------+----------+--------+------------+ Chargebacks table: +------------+------------+ | trans_id | trans_date | +------------+------------+ | 102 | 2019-05-29 | | 101 | 2019-06-30 | | 105 | 2019-09-18 | +------------+------------+ Result table: +----------+---------+----------------+-----------------+-------------------+--------------------+ | month | country | approved_count | approved_amount | chargeback_count | chargeback_amount | +----------+---------+----------------+-----------------+-------------------+--------------------+ | 2019-05 | US | 1 | 1000 | 1 | 2000 | | 2019-06 | US | 3 | 12000 | 1 | 1000 | | 2019-09 | US | 0 | 0 | 1 | 5000 | +----------+---------+----------------+-----------------+-------------------+--------------------+   Solution 2020-10-11 Notes: SELECT month, country, SUM(CASE WHEN state = &amp;quot;approved&amp;quot; THEN 1 ELSE 0 END) AS approved_count, SUM(CASE WHEN state = &amp;quot;approved&amp;quot; THEN amount ELSE 0 END) AS approved_amount, SUM(CASE WHEN state = &amp;quot;back&amp;quot; THEN 1 ELSE 0 END) AS chargeback_count, SUM(CASE WHEN state = &amp;quot;back&amp;quot; THEN amount ELSE 0 END) AS chargeback_amount FROM( SELECT LEFT(chargebacks.</description>
    </item>
    
    <item>
      <title>695 Max Area of Island</title>
      <link>https://foxisawesome.github.io/posts/695-max-area-of-island/</link>
      <pubDate>Sun, 11 Oct 2020 11:03:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/695-max-area-of-island/</guid>
      <description>LC 695 Max Area of Island Given a non-empty 2D array grid of 0&amp;rsquo;s and 1&amp;rsquo;s, an island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0],</description>
    </item>
    
    <item>
      <title>1197 Minimum Knight Moves</title>
      <link>https://foxisawesome.github.io/posts/1197-minimum-knight-moves/</link>
      <pubDate>Sun, 11 Oct 2020 10:38:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1197-minimum-knight-moves/</guid>
      <description>LC 1197 Minimum Knight Moves In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0]. A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction. Solution 2020-10-11 Notes: 这题最优解是dp 但使用naiv</description>
    </item>
    
  </channel>
</rss>
