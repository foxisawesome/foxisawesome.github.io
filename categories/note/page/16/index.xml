<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>note on Q. Weng</title>
    <link>https://foxisawesome.github.io/categories/note/</link>
    <description>Recent content in note on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 06 Dec 2020 16:48:55 -0500</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/categories/note/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>99 Recover Binary Search Tree</title>
      <link>https://foxisawesome.github.io/posts/99-recover-binary-search-tree/</link>
      <pubDate>Sun, 13 Sep 2020 20:10:43 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/99-recover-binary-search-tree/</guid>
      <description>LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.
Recover the tree without changing its structure.
Input: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:
    </description>
    </item>
    
    <item>
      <title>92 Reverse Linked List ii</title>
      <link>https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/</link>
      <pubDate>Sun, 13 Sep 2020 19:51:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/</guid>
      <description>LC 92 Reverse Linked List ii Reverse a linked list from position m to n. Do it in one-pass. Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL Solution 2020-09-13 Notes: 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的util</description>
    </item>
    
    <item>
      <title>102 Binary Tree Level Order Traversal</title>
      <link>https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/</link>
      <pubDate>Sun, 13 Sep 2020 14:55:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/</guid>
      <description>LC 102 Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes&#39; values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return [[3],[9,20],[15,7]] Solution 2020-09-13 Notes: 与LC 109 一样 Recursion 解法： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0,</description>
    </item>
    
    <item>
      <title>199 Binary Tree Right Side View</title>
      <link>https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/</link>
      <pubDate>Sun, 13 Sep 2020 14:39:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/</guid>
      <description>LC 199 Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- Solution 2020-09-13 Notes: 一刷虽然做出来了 但是在输出</description>
    </item>
    
    <item>
      <title>987 Vertical Order Traversal of a Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/</link>
      <pubDate>Sun, 13 Sep 2020 13:59:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/</guid>
      <description>LC 987 Vertical Order Traversal of a Binary Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes</description>
    </item>
    
    <item>
      <title>501 Find Mode in Binary Search Tree</title>
      <link>https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/</link>
      <pubDate>Sat, 12 Sep 2020 21:54:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/</guid>
      <description>LC 501 Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal</description>
    </item>
    
    <item>
      <title>621 Task Scheduler</title>
      <link>https://foxisawesome.github.io/posts/621-task-scheduler/</link>
      <pubDate>Sat, 12 Sep 2020 21:00:42 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/621-task-scheduler/</guid>
      <description>LC 621 Task Scheduler Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two</description>
    </item>
    
    <item>
      <title>300 Longest Increasing Subsequence</title>
      <link>https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/</link>
      <pubDate>Sat, 12 Sep 2020 20:05:08 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/</guid>
      <description>LC 300 Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Solution 2020-09-12 Notes: $\mathcal{O}(N^2)$的解，25%通过了。经典的d</description>
    </item>
    
    <item>
      <title>767 Reorganize String</title>
      <link>https://foxisawesome.github.io/posts/767-reorganize-string/</link>
      <pubDate>Sat, 12 Sep 2020 15:53:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/767-reorganize-string/</guid>
      <description>LC 767 Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Input: S = &amp;quot;aab&amp;quot; Output: &amp;quot;aba&amp;quot; Solution 2020-10-09 Notes: 又刷了一遍，感觉algo不难想到吗，可</description>
    </item>
    
    <item>
      <title>双指针技巧总结</title>
      <link>https://foxisawesome.github.io/posts/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 11 Sep 2020 22:01:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</guid>
      <description>双指针技巧总结 我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环</description>
    </item>
    
    <item>
      <title>团灭LC股票问题</title>
      <link>https://foxisawesome.github.io/posts/%E5%9B%A2%E7%81%ADlc%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 11 Sep 2020 21:59:37 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E5%9B%A2%E7%81%ADlc%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/</guid>
      <description>团灭 LeetCode 股票买卖问题 很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫</description>
    </item>
    
    <item>
      <title>142 Linked List Cycle ii</title>
      <link>https://foxisawesome.github.io/posts/142-linked-list-cycle-ii/</link>
      <pubDate>Fri, 11 Sep 2020 20:35:06 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/142-linked-list-cycle-ii/</guid>
      <description>LC 142 Linked List Cycle ii Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Solution 2020-09-11 Notes: 这题的</description>
    </item>
    
    <item>
      <title>4 Median of Two Sorted Arrays</title>
      <link>https://foxisawesome.github.io/posts/4-median-of-two-sorted-arrays/</link>
      <pubDate>Fri, 11 Sep 2020 14:40:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/4-median-of-two-sorted-arrays/</guid>
      <description>LC 4 Median of Two Sorted Arrays Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Solution 2020-09-11 Notes: 山景城一姐的做法一目了然！第一种用了merge sort，第二种做法是binar</description>
    </item>
    
    <item>
      <title>二分查找详解</title>
      <link>https://foxisawesome.github.io/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 11 Sep 2020 14:40:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</guid>
      <description>original labuladong post 先给大家讲个笑话乐呵一下： 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿</description>
    </item>
    
    <item>
      <title>829 Consecutive Numbers Sum</title>
      <link>https://foxisawesome.github.io/posts/829-consecutive-numbers-sum/</link>
      <pubDate>Fri, 11 Sep 2020 13:50:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/829-consecutive-numbers-sum/</guid>
      <description>LC 829 Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Solution 2020-09-11 Notes: 以为又是backtrackin</description>
    </item>
    
    <item>
      <title>197 Rising Temperature</title>
      <link>https://foxisawesome.github.io/posts/197-rising-temperature/</link>
      <pubDate>Fri, 11 Sep 2020 10:00:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/197-rising-temperature/</guid>
      <description>LC 197 Rising Temperature   Write an SQL query to find all dates&#39; id with higher temperature compared to its previous dates (yesterday).
Weather +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ Result table: +----+ | id | +----+ | 2 | | 4 | +----+   Solution 2020-09-11 Notes:</description>
    </item>
    
    <item>
      <title>184 Department Highest Salary</title>
      <link>https://foxisawesome.github.io/posts/184-department-highest-salary/</link>
      <pubDate>Fri, 11 Sep 2020 09:35:52 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/184-department-highest-salary/</guid>
      <description>LC 184 Department Highest Salary   The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.
+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+  The Department table holds all departments of the company.</description>
    </item>
    
    <item>
      <title>182 Duplicate Emails</title>
      <link>https://foxisawesome.github.io/posts/182-duplicate-emails/</link>
      <pubDate>Thu, 10 Sep 2020 22:14:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/182-duplicate-emails/</guid>
      <description>LC 182 Duplicate Emails   Write a SQL query to find all duplicate emails in a table named Person.
+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+  For example, your query should return the following for the above table:
+---------+ | Email | +---------+ | a@b.com | +---------+   Solution 2020-09-10 Notes:</description>
    </item>
    
    <item>
      <title>178 Rank Scores</title>
      <link>https://foxisawesome.github.io/posts/178-rank-scores/</link>
      <pubDate>Thu, 10 Sep 2020 21:57:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/178-rank-scores/</guid>
      <description>LC 178 Rank Scores Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no &amp;ldquo;holes&amp;rdquo; between ranks. +----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3</description>
    </item>
    
    <item>
      <title>312 Burst Balloons</title>
      <link>https://foxisawesome.github.io/posts/312-burst-balloons/</link>
      <pubDate>Thu, 10 Sep 2020 20:58:53 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/312-burst-balloons/</guid>
      <description>LC 312 Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum</description>
    </item>
    
  </channel>
</rss>
