<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algo on Q. Weng</title>
    <link>https://foxisawesome.github.io/categories/algo/</link>
    <description>Recent content in algo on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 15 Oct 2020 12:03:45 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/categories/algo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>112 Path Sum</title>
      <link>https://foxisawesome.github.io/posts/112-path-sum/</link>
      <pubDate>Wed, 09 Sep 2020 21:47:10 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/112-path-sum/</guid>
      <description>LC 112 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum</description>
    </item>
    
    <item>
      <title>104 Maximum Depth of Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 09 Sep 2020 21:45:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/104-maximum-depth-of-binary-tree/</guid>
      <description>LC 104 Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 Solution 2020-09-09 Notes: 注意patterns. Beat the TREE! # Definition for</description>
    </item>
    
    <item>
      <title>111 Minimum Depth of Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/111-minimum-depth-of-binary-tree/</link>
      <pubDate>Wed, 09 Sep 2020 21:41:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/111-minimum-depth-of-binary-tree/</guid>
      <description>LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return 2
 Solution 2020-09-09 Notes:
 Beat the TREE!  # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>124 Binary Tree Maximum Path Sum</title>
      <link>https://foxisawesome.github.io/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 09 Sep 2020 14:41:35 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>LC 124 Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15</description>
    </item>
    
    <item>
      <title>236 Lowest Common Ancestor of a Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Wed, 09 Sep 2020 13:57:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>LC 236 Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be</description>
    </item>
    
    <item>
      <title>392 Is Subsequence</title>
      <link>https://foxisawesome.github.io/posts/392-is-subsequence/</link>
      <pubDate>Tue, 08 Sep 2020 22:19:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/392-is-subsequence/</guid>
      <description>LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot; while &amp;quot;aec&amp;quot; is not).
 Solution 2020-09-08 Notes:  O(N) is easy.</description>
    </item>
    
    <item>
      <title>268 Missing Number</title>
      <link>https://foxisawesome.github.io/posts/268-missing-number/</link>
      <pubDate>Tue, 08 Sep 2020 21:54:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/268-missing-number/</guid>
      <description>LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
 Solution 2020-09-08 Notes:
 Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -&amp;gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  </description>
    </item>
    
    <item>
      <title>645 Set Mismatch</title>
      <link>https://foxisawesome.github.io/posts/645-set-mismatch/</link>
      <pubDate>Tue, 08 Sep 2020 21:25:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/645-set-mismatch/</guid>
      <description>LC 645 Set Mismatch The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number</description>
    </item>
    
    <item>
      <title>234 Palindrome Linked List</title>
      <link>https://foxisawesome.github.io/posts/234-palindrome-linked-list/</link>
      <pubDate>Tue, 08 Sep 2020 20:54:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/234-palindrome-linked-list/</guid>
      <description>LC 234 Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Solution 2020-09-08 Notes: Recursion solution参考了 labuladong 以下是一种比较直观但是不是optimal的解法 line 13 is a post-order traverse. # Definition for singly-linked list. # class ListNode: #</description>
    </item>
    
    <item>
      <title>325 Maximum Size Subarray Sum Equals K</title>
      <link>https://foxisawesome.github.io/posts/325-maximum-size-subarray-sum-equals-k/</link>
      <pubDate>Tue, 08 Sep 2020 17:08:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/325-maximum-size-subarray-sum-equals-k/</guid>
      <description>LC 325 Maximum Size Subarray Sum Equals K Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn&amp;rsquo;t one, return 0 instead. Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Solution 2020-09-08 Notes: 此题解法跟</description>
    </item>
    
    <item>
      <title>560 Subarray Sum Equals K</title>
      <link>https://foxisawesome.github.io/posts/560-subarray-sum-equals-k/</link>
      <pubDate>Tue, 08 Sep 2020 15:07:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/560-subarray-sum-equals-k/</guid>
      <description>LC 560 Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Input:nums = [1,1,1], k = 2 Output: 2 Solution 2020-09-08 Notes: 看了labuladong 的总结 预先算一个cumulativ</description>
    </item>
    
    <item>
      <title>1109 Corporate Flight Bookings</title>
      <link>https://foxisawesome.github.io/posts/1109-corporate-flight-bookings/</link>
      <pubDate>Tue, 08 Sep 2020 13:44:08 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1109-corporate-flight-bookings/</guid>
      <description>LC 1109 Corporate Flight Bookings There are n flights, and they are labeled from 1 to n. We have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label. Input: bookings = [[1,2,10],[2,3,20],[2,5,25]],</description>
    </item>
    
    <item>
      <title>1539 Kth Missing Positive Number</title>
      <link>https://foxisawesome.github.io/posts/1539-kth-missing-positive-number/</link>
      <pubDate>Mon, 07 Sep 2020 22:03:58 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1539-kth-missing-positive-number/</guid>
      <description>LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary</description>
    </item>
    
    <item>
      <title>1512 Number of Good Pairs</title>
      <link>https://foxisawesome.github.io/posts/1512-number-of-good-pairs/</link>
      <pubDate>Sun, 06 Sep 2020 21:03:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1512-number-of-good-pairs/</guid>
      <description>LC 1512 Number of Good Pairs   Given an array of integers nums.
A pair (i,j) is called good if nums[i] == nums[j] and i &amp;lt; j.
Return the number of good pairs.
 Solution 2020-09-06 Notes:  One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j &amp;lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  </description>
    </item>
    
    <item>
      <title>SQL Notes</title>
      <link>https://foxisawesome.github.io/sql/sql-notes/</link>
      <pubDate>Sun, 06 Sep 2020 18:35:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/sql-notes/</guid>
      <description>SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.</description>
    </item>
    
    <item>
      <title>166 Fraction to Recurring Decimal</title>
      <link>https://foxisawesome.github.io/posts/166-fraction-to-recurring-decimal/</link>
      <pubDate>Sat, 05 Sep 2020 22:05:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/166-fraction-to-recurring-decimal/</guid>
      <description>LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
If the fractional part is repeating, enclose the repeating part in parentheses.
If multiple answers are possible, just return any of them.
Extreme case: numer = -2147483648, denominator = -1999
 Solution 2020-09-05 Notes:  Details: python built-in divmod() returns floor, which is not friendly in negative case.</description>
    </item>
    
    <item>
      <title>159 Longest Substring With at Most Two Distinct Characters</title>
      <link>https://foxisawesome.github.io/posts/159-longest-substring-with-at-most-two-distinct-characters/</link>
      <pubDate>Sat, 05 Sep 2020 21:08:15 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/159-longest-substring-with-at-most-two-distinct-characters/</guid>
      <description>LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: &amp;quot;ccaabbb&amp;quot; Output: 5 Explanation: t is &amp;quot;aabbb&amp;quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://foxisawesome.github.io/posts/136-single-number/</link>
      <pubDate>Sat, 05 Sep 2020 20:58:41 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/136-single-number/</guid>
      <description>LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 Solution 2020-09-05 Notes:  Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: stack = set() for num in nums: if num not in stack: stack.</description>
    </item>
    
    <item>
      <title>187 Repeated Dna Sequences</title>
      <link>https://foxisawesome.github.io/posts/187-repeated-dna-sequences/</link>
      <pubDate>Sat, 05 Sep 2020 20:17:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/187-repeated-dna-sequences/</guid>
      <description>LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷</description>
    </item>
    
    <item>
      <title>1249 Minimum Remove to Make Valid Parentheses</title>
      <link>https://foxisawesome.github.io/posts/1249-minimum-remove-to-make-valid-parentheses/</link>
      <pubDate>Sat, 05 Sep 2020 14:01:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1249-minimum-remove-to-make-valid-parentheses/</guid>
      <description>LC 1249 Minimum Remove to Make Valid Parentheses Given a string s of &#39;(&#39; , &#39;)&#39; and lowercase English characters. Your task is to remove the minimum number of parentheses ( &#39;(&#39; or &#39;)&#39;, in any positions ) so that the resulting parentheses string is valid and return any valid string. Input: s = &amp;quot;lee(t(c)o)de)&amp;quot; Output: &amp;quot;lee(t(c)o)de&amp;quot; Explanation: &amp;quot;lee(t(co)de)&amp;quot; , &amp;quot;lee(t(c)ode)&amp;quot; would also be accepted. Solution 2020-09-05 Notes: 很简</description>
    </item>
    
  </channel>
</rss>
