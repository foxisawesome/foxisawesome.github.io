<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Series on Q. Weng</title>
    <link>https://foxisawesome.github.io/series/</link>
    <description>Recent content in Series on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    
        <atom:link href="https://foxisawesome.github.io/series/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1512 Number of Good Pairs</title>
      <link>https://foxisawesome.github.io/1512-number-of-good-pairs/</link>
      <pubDate>Sun, 06 Sep 2020 21:03:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/1512-number-of-good-pairs/</guid>
      <description>LC 1512 Number of Good Pairs   Given an array of integers nums.
A pair (i,j) is called good if nums[i] == nums[j] and i &amp;lt; j.
Return the number of good pairs.
 Solution 2020-09-06 Notes:
 One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j &amp;lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  </description>
    </item>
    
    <item>
      <title>SQL Notes</title>
      <link>https://foxisawesome.github.io/sql-notes/</link>
      <pubDate>Sun, 06 Sep 2020 18:35:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql-notes/</guid>
      <description>SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.</description>
    </item>
    
    <item>
      <title>166 Fraction to Recurring Decimal</title>
      <link>https://foxisawesome.github.io/166-fraction-to-recurring-decimal/</link>
      <pubDate>Sat, 05 Sep 2020 22:05:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/166-fraction-to-recurring-decimal/</guid>
      <description>LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.
If the fractional part is repeating, enclose the repeating part in parentheses.
If multiple answers are possible, just return any of them.
Extreme case: numer = -2147483648, denominator = -1999
 Solution 2020-09-05 Notes:
 Details: python built-in divmod() returns floor, which is not friendly in negative case.</description>
    </item>
    
    <item>
      <title>159 Longest Substring With at Most Two Distinct Characters</title>
      <link>https://foxisawesome.github.io/159-longest-substring-with-at-most-two-distinct-characters/</link>
      <pubDate>Sat, 05 Sep 2020 21:08:15 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/159-longest-substring-with-at-most-two-distinct-characters/</guid>
      <description>LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: &amp;quot;ccaabbb&amp;quot; Output: 5 Explanation: t is &amp;quot;aabbb&amp;quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://foxisawesome.github.io/136-single-number/</link>
      <pubDate>Sat, 05 Sep 2020 20:58:41 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/136-single-number/</guid>
      <description>LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
 Solution 2020-09-05 Notes:
 Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: stack = set() for num in nums: if num not in stack: stack.</description>
    </item>
    
    <item>
      <title>187 Repeated Dna Sequences</title>
      <link>https://foxisawesome.github.io/187-repeated-dna-sequences/</link>
      <pubDate>Sat, 05 Sep 2020 20:17:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/187-repeated-dna-sequences/</guid>
      <description>LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷</description>
    </item>
    
    <item>
      <title>1249 Minimum Remove to Make Valid Parentheses</title>
      <link>https://foxisawesome.github.io/1249-minimum-remove-to-make-valid-parentheses/</link>
      <pubDate>Sat, 05 Sep 2020 14:01:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/1249-minimum-remove-to-make-valid-parentheses/</guid>
      <description>LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:
   # Time O() # Space O()  </description>
    </item>
    
    <item>
      <title>316 Remove Dup Letters</title>
      <link>https://foxisawesome.github.io/316-remove-dup-letters/</link>
      <pubDate>Fri, 04 Sep 2020 19:56:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/316-remove-dup-letters/</guid>
      <description>LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.
Input: &amp;quot;cbacdcbc&amp;quot; Output: &amp;quot;acdb&amp;quot;   Solution 2020-09-04 Notes:
  Need one-pass of s to get the counter of each letter.
  a second pass, dial down counter at each iteration.</description>
    </item>
    
    <item>
      <title>1081 Smallest Subsequence of Distinct Char</title>
      <link>https://foxisawesome.github.io/1081-smallest-subsequence-of-distinct-char/</link>
      <pubDate>Fri, 04 Sep 2020 19:55:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/1081-smallest-subsequence-of-distinct-char/</guid>
      <description>LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.
Input: &amp;quot;ecbacba&amp;quot; Output: &amp;quot;eacb&amp;quot;   Solution 2020-09-04 Notes:
  Need one-pass of s to get the counter of each letter.
  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.</description>
    </item>
    
    <item>
      <title>80 Remove Dup From Sorted Array II</title>
      <link>https://foxisawesome.github.io/80-remove-dup-from-sorted-array-ii/</link>
      <pubDate>Fri, 04 Sep 2020 14:05:24 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/80-remove-dup-from-sorted-array-ii/</guid>
      <description>LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Given nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:
 Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast &amp;lt; len(nums): count[nums[fast]] = count.</description>
    </item>
    
    <item>
      <title>26 Remove Dup From Sorted Array</title>
      <link>https://foxisawesome.github.io/26-remove-dup-from-sorted-array/</link>
      <pubDate>Fri, 04 Sep 2020 13:45:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/26-remove-dup-from-sorted-array/</guid>
      <description>LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</description>
    </item>
    
    <item>
      <title>18 K Sum</title>
      <link>https://foxisawesome.github.io/18-k-sum/</link>
      <pubDate>Thu, 03 Sep 2020 22:17:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/18-k-sum/</guid>
      <description>LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
 Solution 2020-09-03 Notes:
K - sum algo:
 sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i &amp;gt; 0 and nums[i]==nums[i-1]):</description>
    </item>
    
    <item>
      <title>140 Word Break II</title>
      <link>https://foxisawesome.github.io/140-word-break-ii/</link>
      <pubDate>Thu, 03 Sep 2020 21:26:20 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/140-word-break-ii/</guid>
      <description>LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = &amp;quot;pineapplepenapple&amp;quot; wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;, &amp;quot;applepen&amp;quot;, &amp;quot;pine&amp;quot;, &amp;quot;pineapple&amp;quot;] Output: [ &amp;quot;pine apple pen apple&amp;quot;, &amp;quot;pineapple pen apple&amp;quot;, &amp;quot;pine applepen apple&amp;quot; ] Solution 2020-09-03 Notes: 第一</description>
    </item>
    
    <item>
      <title>128 Longest Consecutive Sequence</title>
      <link>https://foxisawesome.github.io/128-longest-consecutive-sequence/</link>
      <pubDate>Thu, 03 Sep 2020 20:41:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/128-longest-consecutive-sequence/</guid>
      <description>LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: 题目 time complexity 要求O(N)，那没其</description>
    </item>
    
    <item>
      <title>543 Diameter of Binary Tree</title>
      <link>https://foxisawesome.github.io/543-diameter-of-binary-tree/</link>
      <pubDate>Wed, 02 Sep 2020 15:49:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/543-diameter-of-binary-tree/</guid>
      <description>LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
Example: Given a binary tree
 1 / \ 2 3 / \ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>48 Rotate Image</title>
      <link>https://foxisawesome.github.io/48-rotate-image/</link>
      <pubDate>Wed, 02 Sep 2020 14:16:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/48-rotate-image/</guid>
      <description>LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
 Solution 2020-09-02T14:16:29-04:00 Notes:
  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.</description>
    </item>
    
    <item>
      <title>528 Random Pick With Weight</title>
      <link>https://foxisawesome.github.io/528-random-pick-with-weight/</link>
      <pubDate>Wed, 02 Sep 2020 14:11:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/528-random-pick-with-weight/</guid>
      <description>LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).
We need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.</description>
    </item>
    
    <item>
      <title>445 Add Two Num II</title>
      <link>https://foxisawesome.github.io/445-add-two-num-ii/</link>
      <pubDate>Wed, 02 Sep 2020 09:38:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/445-add-two-num-ii/</guid>
      <description>LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Follow up: What if you cannot modify the input lists?</description>
    </item>
    
    <item>
      <title>295 Find Median From Data Stream</title>
      <link>https://foxisawesome.github.io/295-find-median-from-data-stream/</link>
      <pubDate>Tue, 01 Sep 2020 21:33:10 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/295-find-median-from-data-stream/</guid>
      <description>LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow 了花花酱的so</description>
    </item>
    
    <item>
      <title>148 Sort List</title>
      <link>https://foxisawesome.github.io/148-sort-list/</link>
      <pubDate>Tue, 01 Sep 2020 19:26:00 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/148-sort-list/</guid>
      <description>LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.
Example 1:
Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4  Example 2:
Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5   Solution 2020-09-01 Notes:
 Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.</description>
    </item>
    
  </channel>
</rss>
