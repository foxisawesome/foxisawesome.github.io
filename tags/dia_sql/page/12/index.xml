<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dia_sql on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/dia_sql/</link>
    <description>Recent content in dia_sql on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 29 Oct 2020 11:19:23 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/dia_sql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Cheatsheet</title>
      <link>https://foxisawesome.github.io/notes/cheatsheet/</link>
      <pubDate>Fri, 25 Sep 2020 19:13:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/notes/cheatsheet/</guid>
      <description> [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip([&#39;a&#39;,&#39;b&#39;],[&#39;c&#39;,&#39;d&#39;])]: [[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;c&amp;rsquo;], [&amp;lsquo;b&amp;rsquo;, &amp;rsquo;d&#39;]] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]   sort a by b: [x for _,x in sorted(zip(b,a))]  </description>
    </item>
    
    <item>
      <title>36 Valid Sudoku</title>
      <link>https://foxisawesome.github.io/posts/36-valid-sudoku/</link>
      <pubDate>Fri, 25 Sep 2020 19:13:25 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/36-valid-sudoku/</guid>
      <description>LC 36 Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. Solution 2020-09-25 Notes: 按</description>
    </item>
    
    <item>
      <title>771 Jewels and Stones</title>
      <link>https://foxisawesome.github.io/posts/771-jewels-and-stones/</link>
      <pubDate>Fri, 25 Sep 2020 15:54:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/771-jewels-and-stones/</guid>
      <description>LC 771 Jewels and Stones You&amp;rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so</description>
    </item>
    
    <item>
      <title>62 Unique Paths</title>
      <link>https://foxisawesome.github.io/posts/62-unique-paths/</link>
      <pubDate>Fri, 25 Sep 2020 15:47:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/62-unique-paths/</guid>
      <description>LC 62 Unique Paths A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below). How many possible unique paths are there? Solution 2020-09-25 Notes: 像cli</description>
    </item>
    
    <item>
      <title>819 Most Common Word</title>
      <link>https://foxisawesome.github.io/posts/819-most-common-word/</link>
      <pubDate>Fri, 25 Sep 2020 14:39:42 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/819-most-common-word/</guid>
      <description>LC 819 Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The</description>
    </item>
    
    <item>
      <title>1137 N Th Tribonacci Number</title>
      <link>https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/</link>
      <pubDate>Fri, 25 Sep 2020 14:13:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/</guid>
      <description>LC 1137 N Th Tribonacci Number The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0. Given n, return the value of Tn. Solution 2020-09-25 Notes: 加个memo在 def __init__(self): 能把整个recursion写在一</description>
    </item>
    
    <item>
      <title>303 Range Sum Query Immutable</title>
      <link>https://foxisawesome.github.io/posts/303-range-sum-query-immutable/</link>
      <pubDate>Fri, 25 Sep 2020 14:03:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/303-range-sum-query-immutable/</guid>
      <description>LC 303 Range Sum Query Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Solution 2020-09-25 Notes: 这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求</description>
    </item>
    
    <item>
      <title>209 Minimum Size Subarray Sum</title>
      <link>https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/</link>
      <pubDate>Fri, 25 Sep 2020 11:08:36 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/</guid>
      <description>LC 209 Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead. Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint Solution 2020-09-25 Notes: 这题 O(N)的</description>
    </item>
    
    <item>
      <title>167 Two Sum II Input Array Is Sorted</title>
      <link>https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Fri, 25 Sep 2020 10:36:56 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>LC 167 Two Sum II Input Array Is Sorted Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The</description>
    </item>
    
    <item>
      <title>75 Sort Colors</title>
      <link>https://foxisawesome.github.io/posts/75-sort-colors/</link>
      <pubDate>Fri, 25 Sep 2020 10:27:10 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/75-sort-colors/</guid>
      <description>LC 75 Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Follow up: Could you solve this problem without using the library&amp;rsquo;s sort function?</description>
    </item>
    
    <item>
      <title>181 Employees Earning More Than Their Managers</title>
      <link>https://foxisawesome.github.io/posts/181-employees-earning-more-than-their-managers/</link>
      <pubDate>Thu, 24 Sep 2020 21:57:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/181-employees-earning-more-than-their-managers/</guid>
      <description>LC 181 Employees Earning More Than Their Managers   Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.
 Solution 2020-09-24 Notes: SELECT name AS employee FROM ( SELECT a.name, a.salary, a.managerId, b.salary AS mg_sal FROM employee a JOIN employee b ON a.managerID = b.ID ) c WHERE salary &amp;gt; mg_sal  </description>
    </item>
    
    <item>
      <title>180 Consecutive Numbers</title>
      <link>https://foxisawesome.github.io/posts/180-consecutive-numbers/</link>
      <pubDate>Thu, 24 Sep 2020 21:41:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/180-consecutive-numbers/</guid>
      <description>LC 180 Consecutive Numbers Write a SQL query to find all numbers that appear at least three times consecutively. Solution 2020-09-24 Notes: self join 的写法 SELECT DISTINCT a.num AS ConsecutiveNums FROM logs a JOIN logs b ON a.id+1 = b.id AND a.num=b.num JOIN logs c ON a.id+2 = c.id AND a.num=c.num LEAD() function 的写法： SELECT DISTINCT num AS consecutiveNums FROM ( SELECT id, num, LEAD(num,1)</description>
    </item>
    
    <item>
      <title>177 Nth Highest Salary</title>
      <link>https://foxisawesome.github.io/posts/177-nth-highest-salary/</link>
      <pubDate>Thu, 24 Sep 2020 21:16:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/177-nth-highest-salary/</guid>
      <description>LC 177 Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. Solution 2020-09-24 Notes: 这个sql function 的写法得背下来。不过也没什么难的。 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE m int; SET m = n-1; RETURN ( SELECT salary FROM employee GROUP BY 1 ORDER by</description>
    </item>
    
    <item>
      <title>875 Koko Eating Bananas</title>
      <link>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</link>
      <pubDate>Thu, 24 Sep 2020 13:51:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</guid>
      <description>LC 875 Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them</description>
    </item>
    
    <item>
      <title>774 Minimize Max Distance to Gas Station</title>
      <link>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</link>
      <pubDate>Thu, 24 Sep 2020 13:49:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</guid>
      <description>LC 774 Minimize Max Distance to Gas Station On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D. Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000</description>
    </item>
    
    <item>
      <title>410 Split Array Largest Sum</title>
      <link>https://foxisawesome.github.io/posts/410-split-array-largest-sum/</link>
      <pubDate>Thu, 24 Sep 2020 13:48:35 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/410-split-array-largest-sum/</guid>
      <description>LC 410 Split Array Largest Sum Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5]</description>
    </item>
    
    <item>
      <title>1011 Capacity to Ship Packages Within D Days</title>
      <link>https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/</link>
      <pubDate>Thu, 24 Sep 2020 13:46:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/</guid>
      <description>LC 1011 Capacity to Ship Packages Within D Days conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Thu, 24 Sep 2020 13:18:43 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/</guid>
      <description>LC 21 Merge Two Sorted Lists Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Solution 2020-09-24 Notes: 不要create 新的 ListNode along the way, making algo much faster. # Definition for singly-linked list. # class ListNode: #</description>
    </item>
    
    <item>
      <title>14 Longest Common Prefix</title>
      <link>https://foxisawesome.github.io/posts/14-longest-common-prefix/</link>
      <pubDate>Thu, 24 Sep 2020 13:13:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/14-longest-common-prefix/</guid>
      <description>LC 14 Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;quot;&amp;quot;. Input: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Solution 2020-09-24 Notes: 第三刷了，当年做的很痛苦的一道题。其实很简单。 class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: if</description>
    </item>
    
    <item>
      <title>38 Count and Say</title>
      <link>https://foxisawesome.github.io/posts/38-count-and-say/</link>
      <pubDate>Thu, 24 Sep 2020 12:56:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/38-count-and-say/</guid>
      <description>LC 38 Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 Solution 2020-09-24 Notes: algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有</description>
    </item>
    
  </channel>
</rss>
