<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary_search on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/binary_search/</link>
    <description>Recent content in binary_search on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Oct 2020 20:37:12 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/binary_search/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1225 Report Contiguous Dates</title>
      <link>https://foxisawesome.github.io/posts/1225-report-contiguous-dates/</link>
      <pubDate>Thu, 29 Oct 2020 11:18:31 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1225-report-contiguous-dates/</guid>
      <description>LC 1225 Report Contiguous Dates 01-01 to 2019-12-31. period_state` is *&#39;failed&#39;* if tasks in this interval failed or *&#39;succeeded&#39;* if tasks in this interval succeeded. Interval of days are retrieved as `start_date` and `end_date. Order result by start_date. The query result format is in the following example: Failed table: +-------------------+ | fail_date | +-------------------+ | 2018-12-28 | | 2018-12-29 | | 2019-01-04 | | 2019-01-05 | +-------------------+ Succeeded table: +-------------------+</description>
    </item>
    
    <item>
      <title>1211 Queries Quality and Percentage</title>
      <link>https://foxisawesome.github.io/posts/1211-queries-quality-and-percentage/</link>
      <pubDate>Thu, 29 Oct 2020 11:18:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1211-queries-quality-and-percentage/</guid>
      <description>LC 1211 Queries Quality and Percentage Write an SQL query to find each query_name, the quality and poor_query_percentage. Both quality and poor_query_percentage should be rounded to 2 decimal places. The query result format is in the following example: Queries table: +------------+-------------------+----------+--------+ | query_name | result | position | rating | +------------+-------------------+----------+--------+ | Dog | Golden Retriever | 1 | 5 | | Dog | German Shepherd | 2 | 5</description>
    </item>
    
    <item>
      <title>1193 Monthly Transactions I</title>
      <link>https://foxisawesome.github.io/posts/1193-monthly-transactions-i/</link>
      <pubDate>Thu, 29 Oct 2020 11:18:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1193-monthly-transactions-i/</guid>
      <description>LC 1193 Monthly Transactions I Write an SQL query to find for each month and country, the number of transactions and their total amount, the number of approved transactions and their total amount. The query result format is in the following example: Transactions table: +------+---------+----------+--------+------------+ | id | country | state | amount | trans_date | +------+---------+----------+--------+------------+ | 121 | US | approved | 1000 | 2018-12-18 | | 122</description>
    </item>
    
    <item>
      <title>1158 Market Analysis I</title>
      <link>https://foxisawesome.github.io/posts/1158-market-analysis-i/</link>
      <pubDate>Thu, 29 Oct 2020 11:17:54 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1158-market-analysis-i/</guid>
      <description>LC 1158 Market Analysis I Write an SQL query to find for each user, the join date and the number of orders they made as a buyer in 2019. The query result format is in the following example: Users table: +---------+------------+----------------+ | user_id | join_date | favorite_brand | +---------+------------+----------------+ | 1 | 2018-01-01 | Lenovo | | 2 | 2018-02-09 | Samsung | | 3 | 2018-01-19 | LG |</description>
    </item>
    
    <item>
      <title>1149 Article Views II</title>
      <link>https://foxisawesome.github.io/posts/1149-article-views-ii/</link>
      <pubDate>Thu, 29 Oct 2020 11:17:39 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1149-article-views-ii/</guid>
      <description>LC 1149 Article Views II Write an SQL query to find all the people who viewed more than one article on the same date, sorted in ascending order by their id. The query result format is in the following example: Views table: +------------+-----------+-----------+------------+ | article_id | author_id | viewer_id | view_date | +------------+-----------+-----------+------------+ | 1 | 3 | 5 | 2019-08-01 | | 3 | 4 | 5 | 2019-08-01</description>
    </item>
    
    <item>
      <title>1132 Reported Posts II</title>
      <link>https://foxisawesome.github.io/posts/1132-reported-posts-ii/</link>
      <pubDate>Thu, 29 Oct 2020 11:14:32 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1132-reported-posts-ii/</guid>
      <description>LC 1132 Reported Posts II Write an SQL query to find the average for daily percentage of posts that got removed after being reported as spam, rounded to 2 decimal places. The query result format is in the following example: Actions table: +---------+---------+-------------+--------+--------+ | user_id | post_id | action_date | action | extra | +---------+---------+-------------+--------+--------+ | 1 | 1 | 2019-07-01 | view | null | | 1 | 1</description>
    </item>
    
    <item>
      <title>1127 User Purchase Platform</title>
      <link>https://foxisawesome.github.io/posts/1127-user-purchase-platform/</link>
      <pubDate>Thu, 29 Oct 2020 11:14:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1127-user-purchase-platform/</guid>
      <description>LC 1127 User Purchase Platform   Write an SQL query to find the total number of users and the total amount spent using mobile only, desktop only and both mobile and desktop together for each date.
The query result format is in the following example:
Spending table: +---------+------------+----------+--------+ | user_id | spend_date | platform | amount | +---------+------------+----------+--------+ | 1 | 2019-07-01 | mobile | 100 | | 1 | 2019-07-01 | desktop | 100 | | 2 | 2019-07-01 | mobile | 100 | | 2 | 2019-07-02 | mobile | 100 | | 3 | 2019-07-01 | desktop | 100 | | 3 | 2019-07-02 | desktop | 100 | +---------+------------+----------+--------+ Result table: +------------+----------+--------------+-------------+ | spend_date | platform | total_amount | total_users | +------------+----------+--------------+-------------+ | 2019-07-01 | desktop | 100 | 1 | | 2019-07-01 | mobile | 100 | 1 | | 2019-07-01 | both | 200 | 1 | | 2019-07-02 | desktop | 100 | 1 | | 2019-07-02 | mobile | 100 | 1 | | 2019-07-02 | both | 0 | 0 | +------------+----------+--------------+-------------+ On 2019-07-01, user 1 purchased using both desktop and mobile, user 2 purchased using mobile only and user 3 purchased using desktop only.</description>
    </item>
    
    <item>
      <title>1126 Active Businesses</title>
      <link>https://foxisawesome.github.io/posts/1126-active-businesses/</link>
      <pubDate>Thu, 29 Oct 2020 11:14:06 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1126-active-businesses/</guid>
      <description>LC 1126 Active Businesses Write an SQL query to find all active businesses. An active business is a business that has more than one event type with occurences greater than the average occurences of that event type among all businesses. The query result format is in the following example: Events table: +-------------+------------+------------+ | business_id | event_type | occurences | +-------------+------------+------------+ | 1 | reviews | 7 | | 3 |</description>
    </item>
    
    <item>
      <title>1098 Unpopular Books</title>
      <link>https://foxisawesome.github.io/posts/1098-unpopular-books/</link>
      <pubDate>Thu, 29 Oct 2020 10:21:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1098-unpopular-books/</guid>
      <description>LC 1098 Unpopular Books Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23. The query result format is in the following example: Books table: +---------+--------------------+----------------+ | book_id | name | available_from | +---------+--------------------+----------------+ | 1 | &amp;quot;Kalila And Demna&amp;quot; | 2010-01-01 | |</description>
    </item>
    
    <item>
      <title>1082 Sales Analysis I</title>
      <link>https://foxisawesome.github.io/posts/1082-sales-analysis-i/</link>
      <pubDate>Thu, 29 Oct 2020 09:53:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1082-sales-analysis-i/</guid>
      <description>LC 1082 Sales Analysis I   Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.
 Solution 2020-10-29 Notes:  Window function solution, which is faster  SELECT seller_id FROM ( SELECT *, RANK() OVER(ORDER BY SUM(price) DESC) AS rk FROM sales GROUP BY seller_id ) a WHERE rk = 1   aggregation func solution  SELECT seller_id FROM sales GROUP BY 1 HAVING SUM(price) = (SELECT SUM(price) FROM sales GROUP BY seller_id ORDER BY 1 DESC LIMIT 1)  </description>
    </item>
    
    <item>
      <title>1077 Project Employees III</title>
      <link>https://foxisawesome.github.io/posts/1077-project-employees-iii/</link>
      <pubDate>Thu, 29 Oct 2020 09:24:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1077-project-employees-iii/</guid>
      <description>LC 1077 Project Employees III Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years. Solution 2020-10-29 Notes: 秒了 SELECT project_id, employee_id FROM ( SELECT a.*, RANK() OVER(PARTITION BY project_id ORDER BY experience_years DESC) AS rk FROM project a JOIN employee b ON a.employee_id = b.employee_id ) c WHERE rk =</description>
    </item>
    
    <item>
      <title>1069 Product Sales Analysis II</title>
      <link>https://foxisawesome.github.io/posts/1069-product-sales-analysis-ii/</link>
      <pubDate>Thu, 29 Oct 2020 09:15:54 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1069-product-sales-analysis-ii/</guid>
      <description>LC 1069 Product Sales Analysis II   Write an SQL query that reports the total quantity sold for every product id.
 Solution 2020-10-29 Notes: SELECT product_id, SUM(quantity) AS total_quantity FROM sales GROUP BY 1 ORDER BY 1  </description>
    </item>
    
    <item>
      <title>1068 Product Sales Analysis I</title>
      <link>https://foxisawesome.github.io/posts/1068-product-sales-analysis-i/</link>
      <pubDate>Thu, 29 Oct 2020 09:11:53 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1068-product-sales-analysis-i/</guid>
      <description>LC 1068 Product Sales Analysis I   Write an SQL query that reports all product names of the products in the Sales table along with their selling year and price.
 Solution 2020-10-29 Notes: select a.product_name, b.year, b.price from product a join sales b on a.product_id = b.product_id order by year, price ;  </description>
    </item>
    
    <item>
      <title>601 Human Traffic of Stadium</title>
      <link>https://foxisawesome.github.io/posts/601-human-traffic-of-stadium/</link>
      <pubDate>Tue, 27 Oct 2020 15:47:32 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/601-human-traffic-of-stadium/</guid>
      <description>LC 601 Human Traffic of Stadium   Write an SQL query to display the records with three or more rows with consecutive id&amp;rsquo;s, and the number of people is greater than or equal to 100 for each.
Return the result table ordered by visit_date in ascending order.
The query result format is in the following example.
Stadium table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ Result table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+   Solution 2020-10-27 Notes:  it is slower than version #2.</description>
    </item>
    
    <item>
      <title>614 Second Degree Follower</title>
      <link>https://foxisawesome.github.io/posts/614-second-degree-follower/</link>
      <pubDate>Sun, 25 Oct 2020 14:53:46 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/614-second-degree-follower/</guid>
      <description>LC 614 Second Degree Follower   In facebook, there is a follow table with two columns: followee, follower.
Please write a sql query to get the amount of each follower’s follower if he/she has one.
For example:
+-------------+------------+ | followee | follower | +-------------+------------+ | A | B | | B | C | | B | D | | D | E | +-------------+------------+  should output:
+-------------+------------+ | follower | num | +-------------+------------+ | B | 2 | | D | 1 | +-------------+------------+  Explaination: Both B and D exist in the follower list, when as a followee, B&amp;rsquo;s follower is C and D, and D&amp;rsquo;s follower is E.</description>
    </item>
    
    <item>
      <title>608 Tree Node</title>
      <link>https://foxisawesome.github.io/posts/608-tree-node/</link>
      <pubDate>Sun, 25 Oct 2020 14:50:31 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/608-tree-node/</guid>
      <description>LC 608 Tree Node Given a table tree, id is identifier of the tree node and p_id is its parent node&amp;rsquo;s id. +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ Each node in the tree can be one of three types: Leaf: if the node</description>
    </item>
    
    <item>
      <title>610 Triangle Judgement</title>
      <link>https://foxisawesome.github.io/posts/610-triangle-judgement/</link>
      <pubDate>Sun, 25 Oct 2020 10:02:33 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/610-triangle-judgement/</guid>
      <description>LC 610 Triangle Judgement Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z. | x | y | z | |----|----|----| | 13 | 15 | 30 | | 10 | 20 | 15 | For the sample data above, your query should return the follow result:</description>
    </item>
    
    <item>
      <title>612 Shortest Distance in a Plane</title>
      <link>https://foxisawesome.github.io/posts/612-shortest-distance-in-a-plane/</link>
      <pubDate>Sun, 25 Oct 2020 10:00:41 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/612-shortest-distance-in-a-plane/</guid>
      <description>LC 612 Shortest Distance in a Plane Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane. Write a query to find the shortest distance between these points rounded to 2 decimals. | x | y | |----|----| | -1 | -1 | | 0 | 0 | | -1 | -2 | The shortest distance is 1.00 from point (-1,-1) to (-1,2). So</description>
    </item>
    
    <item>
      <title>586 Customer Placing the Largest Number of Orders</title>
      <link>https://foxisawesome.github.io/posts/586-customer-placing-the-largest-number-of-orders/</link>
      <pubDate>Sat, 24 Oct 2020 20:14:32 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/586-customer-placing-the-largest-number-of-orders/</guid>
      <description>LC 586 Customer Placing the Largest Number of Orders Query the customer_number from the *orders* table for the customer who has placed the largest number of orders. It is guaranteed that exactly one customer will have placed more orders than any other customer. Solution 2020-10-24 Notes: 秒了 select customer_number from (select customer_number, count(order_number) as ct from orders group by 1 order by ct desc) a limit 1</description>
    </item>
    
    <item>
      <title>580 Count Student Number in Departments</title>
      <link>https://foxisawesome.github.io/posts/580-count-student-number-in-departments/</link>
      <pubDate>Sat, 24 Oct 2020 20:11:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/580-count-student-number-in-departments/</guid>
      <description>LC 580 Count Student Number in Departments Write a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students). Sort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name. *student* table: | student_id | student_name</description>
    </item>
    
  </channel>
</rss>
