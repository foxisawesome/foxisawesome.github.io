<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GRAPH on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/graph/</link>
    <description>Recent content in GRAPH on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Oct 2020 21:26:03 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>701 Insert Into BST</title>
      <link>https://foxisawesome.github.io/posts/701-insert-into-bst/</link>
      <pubDate>Sun, 30 Aug 2020 20:58:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/701-insert-into-bst/</guid>
      <description>LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST</description>
    </item>
    
    <item>
      <title>Sliding Window Note</title>
      <link>https://foxisawesome.github.io/posts/sliding-window-note/</link>
      <pubDate>Sun, 30 Aug 2020 17:08:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/sliding-window-note/</guid>
      <description>滑动窗口算法的思路是这样： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)</description>
    </item>
    
    <item>
      <title>Linked List Note (First Post)</title>
      <link>https://foxisawesome.github.io/posts/linked-list-note/</link>
      <pubDate>Sun, 30 Aug 2020 16:54:06 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/linked-list-note/</guid>
      <description>开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post! It takes a while for me to get how exactly Linked List</description>
    </item>
    
    <item>
      <title>917 Reverse Only Letters</title>
      <link>https://foxisawesome.github.io/posts/917-reverse-only-letters/</link>
      <pubDate>Sat, 29 Aug 2020 15:47:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/917-reverse-only-letters/</guid>
      <description>LC 917 Reverse Only Letters   Given a string S, return the &amp;ldquo;reversed&amp;rdquo; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.
 Solution 2020-08-29 Notes: class Solution: def reverseOnlyLetters(self, S: str) -&amp;gt; str: if not S: return &#39;&#39; out = list(S) n = len(S) l, r = 0, n-1 while l &amp;lt; r: if not S[l].isalpha() and not S[r].</description>
    </item>
    
    <item>
      <title>50 Powx N</title>
      <link>https://foxisawesome.github.io/posts/50-powx-n/</link>
      <pubDate>Fri, 28 Aug 2020 13:47:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/50-powx-n/</guid>
      <description>LC 50 Powx N Implement pow(x, n), which calculates x raised to the power n (i.e. x^n). Solution 2020-09-25 Notes: 一个月水平进化了一点。 class Solution: def myPow(self, x: float, n: int) -&amp;gt; float: if n &amp;lt; 0: return self.myPow(1/x,abs(n)) if n == 0: return 1 if n % 2 ==0: ans = self.myPow(x,n//2) ** 2 else: ans = x * self.myPow(x, n//2)</description>
    </item>
    
    <item>
      <title>滑动窗口技巧</title>
      <link>https://foxisawesome.github.io/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 10 Aug 2020 21:59:37 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/</guid>
      <description>本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是</description>
    </item>
    
    <item>
      <title>42 Trapping Rain Water</title>
      <link>https://foxisawesome.github.io/posts/42-trapping-rain-water/</link>
      <pubDate>Wed, 05 Aug 2020 14:01:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/42-trapping-rain-water/</guid>
      <description>LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: 短边原理，左右指针同时走，r_max 大时短边在left，所以计算lef</description>
    </item>
    
    <item>
      <title>206 Reverse Linked List</title>
      <link>https://foxisawesome.github.io/posts/206-reverse-linked-list/</link>
      <pubDate>Sat, 01 Aug 2020 20:06:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/206-reverse-linked-list/</guid>
      <description>LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL Solution 2020-09-01 Notes: 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next</description>
    </item>
    
    <item>
      <title>回溯算法详解</title>
      <link>https://foxisawesome.github.io/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/</link>
      <pubDate>Sat, 11 Jul 2020 21:59:37 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/</guid>
      <description>这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套</description>
    </item>
    
    <item>
      <title>1112 Highest Grade for Each Student</title>
      <link>https://foxisawesome.github.io/posts/1112-highest-grade-for-each-student/</link>
      <pubDate>Thu, 09 Jul 2020 11:13:51 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1112-highest-grade-for-each-student/</guid>
      <description>LC 1112 Highest Grade for Each Student Write a SQL query to find the highest grade with its corresponding course for each student. In case of a tie, you should find the course with the smallest course_id. The output must be sorted by increasing student_id. The query result format is in the following example: Enrollments table: +------------+-------------------+ | student_id | course_id | grade | +------------+-----------+-------+ | 2 | 2 |</description>
    </item>
    
    <item>
      <title>2 Add Two Num</title>
      <link>https://foxisawesome.github.io/posts/2-add-two-num/</link>
      <pubDate>Thu, 02 Jul 2020 10:08:20 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/2-add-two-num/</guid>
      <description>LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt;</description>
    </item>
    
    <item>
      <title>169 Majority Element</title>
      <link>https://foxisawesome.github.io/posts/169-majority-element/</link>
      <pubDate>Fri, 24 Apr 2020 13:06:24 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/169-majority-element/</guid>
      <description>LC 169 Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution 2020-09-24 Notes: 这道题有很多种方法做。 hash table做法。 class Solution:</description>
    </item>
    
    <item>
      <title>204 Count Primes</title>
      <link>https://foxisawesome.github.io/posts/204-count-primes/</link>
      <pubDate>Sun, 12 Apr 2020 21:33:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/204-count-primes/</guid>
      <description>LC 204 Count Primes   Count the number of prime numbers less than a non-negative number, **n**.
 Solution 2020-09-12 Notes:   In mathematics, the sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.
  class Solution: def countPrimes(self, n: int) -&amp;gt; int: if n &amp;lt; 2: return 0 grid = [1] * n grid[0] = 0 grid[1] = 0 for i in range(2,int(n**0.</description>
    </item>
    
    <item>
      <title>69 Sqrtx</title>
      <link>https://foxisawesome.github.io/posts/69-sqrtx/</link>
      <pubDate>Sat, 07 Mar 2020 22:51:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/69-sqrtx/</guid>
      <description>LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: 标准的binary search 模版， right 从x//2开始。 2020-10-06 Notes： 今天又做了一遍，这题虽然看起来像是寻找left bound</description>
    </item>
    
    <item>
      <title>1 Two Sum</title>
      <link>https://foxisawesome.github.io/posts/1-two-sum/</link>
      <pubDate>Sat, 01 Feb 2020 14:01:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1-two-sum/</guid>
      <description>LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have *exactly* one solution, and you may not use the same element twice.
 Solution 2020-02-01 Notes:
 use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  </description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://foxisawesome.github.io/about/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://foxisawesome.github.io/about/</guid>
      <description>Dr. Q. Weng   Linkedin
  Github
  fox.weng@me.com
  Research and Interests Data Analysis Probability and Statistics • Bayesian Analysis • Machine Learning • Time Series Analysis • Natural Language Processing • Visualization.
Others Knowledge Sharing • Data Science • Clean Code
Hobbies Photography • Sports</description>
    </item>
    
    <item>
      <title>Imbalance Data Handling Notes</title>
      <link>https://foxisawesome.github.io/posts/imbalance_data_handling_notes/</link>
      <pubDate>Mon, 11 Nov 2019 21:43:28 -0500</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/imbalance_data_handling_notes/</guid>
      <description>reference: The 5 Most Useful Techniques to Handle Imbalanced Datasets
1. Random Undersampling and Oversampling A widely adopted and perhaps the most straightforward method for dealing with highly imbalanced datasets is called resampling. It consists of removing samples from the majority class (under-sampling) and/or adding more examples from the minority class (over-sampling).
Let us first create some example imbalanced data.
from sklearn.datasets import make_classification X, y = make_classification( n_classes=2, class_sep=1.5, weights=[0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://foxisawesome.github.io/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/</guid>
      <description>前缀和技巧 今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。 那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行</description>
    </item>
    
  </channel>
</rss>
