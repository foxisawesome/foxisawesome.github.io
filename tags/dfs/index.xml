<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/dfs/</link>
    <description>Recent content in DFS on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Oct 2020 21:26:03 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>647 Palindromic Substrings</title>
      <link>https://foxisawesome.github.io/posts/647-palindromic-substrings/</link>
      <pubDate>Wed, 21 Oct 2020 14:39:41 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/647-palindromic-substrings/</guid>
      <description>LC 647 Palindromic Substrings   Given a string, your task is to count how many palindromic substrings in this string.
The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
Input: &amp;quot;abc&amp;quot; Output: 3 Explanation: Three palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;.  Input: &amp;quot;aaa&amp;quot; Output: 6 Explanation: Six palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;.   Solution 2020-10-21 Notes:  dp[i][j]: if s[i:j+1] is palindromic.</description>
    </item>
    
    <item>
      <title>1353 Maximum Number of Events That Can Be Attended</title>
      <link>https://foxisawesome.github.io/posts/1353-maximum-number-of-events-that-can-be-attended/</link>
      <pubDate>Wed, 21 Oct 2020 14:05:38 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1353-maximum-number-of-events-that-can-be-attended/</guid>
      <description>LC 1353 Maximum Number of Events That Can Be Attended Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei &amp;lt;= d &amp;lt;= endTimei. Notice that you can only attend one event at any time d. Return the maximum number of events you can attend. Input: events =</description>
    </item>
    
    <item>
      <title>901 Online Stock Span</title>
      <link>https://foxisawesome.github.io/posts/901-online-stock-span/</link>
      <pubDate>Wed, 21 Oct 2020 14:02:39 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/901-online-stock-span/</guid>
      <description>LC 901 Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;rsquo;s price for the current day. The span of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;rsquo;s price. For example, if the</description>
    </item>
    
    <item>
      <title>152 Maximum Product Subarray</title>
      <link>https://foxisawesome.github.io/posts/152-maximum-product-subarray/</link>
      <pubDate>Wed, 21 Oct 2020 13:33:35 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/152-maximum-product-subarray/</guid>
      <description>LC 152 Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Solution 2020-10-21 Notes: 最大值可能来自三种来源：nums[i], prev_max X nums[i], prev_min X numi[i] 优化了</description>
    </item>
    
    <item>
      <title>1398 Customers Who Bought Products a and B but Not C</title>
      <link>https://foxisawesome.github.io/sql/1398-customers-who-bought-products-a-and-b-but-not-c/</link>
      <pubDate>Wed, 21 Oct 2020 11:20:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1398-customers-who-bought-products-a-and-b-but-not-c/</guid>
      <description>LC 1398 Customers Who Bought Products a and B but Not C Write an SQL query to report the customer_id and customer_name of customers who bought products &amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo; but did not buy the product &amp;ldquo;C&amp;rdquo; since we want to recommend them buy this product. Return the result table ordered by customer_id. Solution 2020-10-21 Notes: 秒了 SELECT a.* FROM customers a JOIN ( SELECT * FROM orders GROUP BY</description>
    </item>
    
    <item>
      <title>1308 Running Total for Different Genders</title>
      <link>https://foxisawesome.github.io/sql/1308-running-total-for-different-genders/</link>
      <pubDate>Wed, 21 Oct 2020 11:14:44 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1308-running-total-for-different-genders/</guid>
      <description>LC 1308 Running Total for Different Genders Write an SQL query to find the total score for each gender at each day. Order the result table by gender and day The query result format is in the following example: Scores table: +-------------+--------+------------+--------------+ | player_name | gender | day | score_points | +-------------+--------+------------+--------------+ | Aron | F | 2020-01-01 | 17 | | Alice | F | 2020-01-07 | 23 |</description>
    </item>
    
    <item>
      <title>1393 Capital Gainloss</title>
      <link>https://foxisawesome.github.io/sql/1393-capital-gainloss/</link>
      <pubDate>Wed, 21 Oct 2020 11:10:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1393-capital-gainloss/</guid>
      <description>LC 1393 Capital Gainloss Write an SQL query to report the Capital gain/loss for each stock. The capital gain/loss of a stock is total gain or loss after buying and selling the stock one or many times. Return the result table in any order. The query result format is in the following example: Stocks table: +---------------+-----------+---------------+--------+ | stock_name | operation | operation_day | price | +---------------+-----------+---------------+--------+ | Leetcode | Buy</description>
    </item>
    
    <item>
      <title>1445 Apples Oranges</title>
      <link>https://foxisawesome.github.io/sql/1445-apples-oranges/</link>
      <pubDate>Wed, 21 Oct 2020 10:09:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1445-apples-oranges/</guid>
      <description>LC 1445 Apples Oranges Write an SQL query to report the difference between number of apples and oranges sold each day. Return the result table ordered by sale_date in format (&amp;lsquo;YYYY-MM-DD&amp;rsquo;). The query result format is in the following example: Sales table: +------------+------------+-------------+ | sale_date | fruit | sold_num | +------------+------------+-------------+ | 2020-05-01 | apples | 10 | | 2020-05-01 | oranges | 8 | | 2020-05-02 | apples |</description>
    </item>
    
    <item>
      <title>1270 All People Report to the Given Manager</title>
      <link>https://foxisawesome.github.io/sql/1270-all-people-report-to-the-given-manager/</link>
      <pubDate>Wed, 21 Oct 2020 10:02:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1270-all-people-report-to-the-given-manager/</guid>
      <description>LC 1270 All People Report to the Given Manager Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company. The indirect relation between managers will not exceed 3 managers as the company is small. Return result table in any order without duplicates. The query result format is in the following example: Employees table: +-------------+---------------+------------+ | employee_id |</description>
    </item>
    
    <item>
      <title>383 Ransom Note</title>
      <link>https://foxisawesome.github.io/posts/383-ransom-note/</link>
      <pubDate>Mon, 19 Oct 2020 19:35:54 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/383-ransom-note/</guid>
      <description>LC 383 Ransom Note   Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.
Each letter in the magazine string can only be used once in your ransom note.
Input: ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot; Output: false   Solution 2020-10-19 Notes:  edge case is acutally hard to get them right in the first place  class Solution: def canConstruct(self, ransomNote: str, magazine: str) -&amp;gt; bool: if not ransomNote: return True if not magazine: return False d = collections.</description>
    </item>
    
    <item>
      <title>682 Baseball Game</title>
      <link>https://foxisawesome.github.io/posts/682-baseball-game/</link>
      <pubDate>Mon, 19 Oct 2020 16:34:58 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/682-baseball-game/</guid>
      <description>LC 682 Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds&amp;rsquo; scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:</description>
    </item>
    
    <item>
      <title>1167 Minimum Cost to Connect Sticks</title>
      <link>https://foxisawesome.github.io/posts/1167-minimum-cost-to-connect-sticks/</link>
      <pubDate>Mon, 19 Oct 2020 16:16:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1167-minimum-cost-to-connect-sticks/</guid>
      <description>LC 1167 Minimum Cost to Connect Sticks You have some number of sticks with positive integer lengths. These lengths are given as an array sticks, where sticks[i] is the length of the ith stick. You can connect any two sticks of lengths x and y into one stick by paying a cost of x + y. You must connect all the sticks until there is only one stick remaining. Return</description>
    </item>
    
    <item>
      <title>1083 Sales Analysis II</title>
      <link>https://foxisawesome.github.io/sql/1083-sales-analysis-ii/</link>
      <pubDate>Mon, 19 Oct 2020 15:30:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1083-sales-analysis-ii/</guid>
      <description>LC 1083 Sales Analysis II Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table. The query result format is in the following example: Product table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone</description>
    </item>
    
    <item>
      <title>1495 Friendly Movies Streamed Last Month</title>
      <link>https://foxisawesome.github.io/sql/1495-friendly-movies-streamed-last-month/</link>
      <pubDate>Mon, 19 Oct 2020 15:22:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1495-friendly-movies-streamed-last-month/</guid>
      <description>LC 1495 Friendly Movies Streamed Last Month   Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.
Return the result table in any order.
 Solution 2020-10-19 Notes: select distinct title from content a join TVProgram b on a.content_id = b.content_id where a.kids_content = &#39;Y&#39; and a.content_type = &#39;Movies&#39; and month(b.program_date) = 6  </description>
    </item>
    
    <item>
      <title>1076 Project Employees II</title>
      <link>https://foxisawesome.github.io/sql/1076-project-employees-ii/</link>
      <pubDate>Mon, 19 Oct 2020 15:19:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1076-project-employees-ii/</guid>
      <description>LC 1076 Project Employees II Write an SQL query that reports all the projects that have the most employees. The query result format is in the following example: Project table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Result table: +-------------+ | project_id | +-------------+</description>
    </item>
    
    <item>
      <title>619 Biggest Single Number</title>
      <link>https://foxisawesome.github.io/sql/619-biggest-single-number/</link>
      <pubDate>Mon, 19 Oct 2020 15:04:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/619-biggest-single-number/</guid>
      <description>LC 619 Biggest Single Number   Table my_numbers contains many numbers in column num including duplicated ones. Can you write a SQL query to find the biggest number, which only appears once
 Solution 2020-10-19 Notes: # 1 SELECT MAX(a.num) AS num FROM ( SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1 ) a #2 SELECT MAX(num) AS num FROM ( SELECT *, COUNT(*) OVER(PARTITION BY num) AS ct FROM my_numbers ) a WHERE ct = 1  </description>
    </item>
    
    <item>
      <title>196 Delete Duplicate Emails</title>
      <link>https://foxisawesome.github.io/sql/196-delete-duplicate-emails/</link>
      <pubDate>Mon, 19 Oct 2020 14:53:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/196-delete-duplicate-emails/</guid>
      <description>LC 196 Delete Duplicate Emails   Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.
+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows:</description>
    </item>
    
    <item>
      <title>597 Friend Requests I Overall Acceptance Rate</title>
      <link>https://foxisawesome.github.io/sql/597-friend-requests-i-overall-acceptance-rate/</link>
      <pubDate>Mon, 19 Oct 2020 14:49:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/597-friend-requests-i-overall-acceptance-rate/</guid>
      <description>LC 597 Friend Requests I Overall Acceptance Rate   Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.
 Solution 2020-10-19 Notes: SELECT round(ifnull( (select count(*) from (select distinct requester_id, accepter_id from request_accepted) a) / (select count(*) from (select distinct sender_id, send_to_id from friend_request) b) ,0),2) as accept_rate  </description>
    </item>
    
    <item>
      <title>584 Find Customer Referee</title>
      <link>https://foxisawesome.github.io/sql/584-find-customer-referee/</link>
      <pubDate>Mon, 19 Oct 2020 14:44:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/584-find-customer-referee/</guid>
      <description>LC 584 Find Customer Referee   Write a query to return the list of customers NOT referred by the person with id &amp;lsquo;2&amp;rsquo;.
 Solution 2020-10-19 Notes: SELECT name FROM customer WHERE referee_id != &#39;2&#39; OR referee_id IS NULL  </description>
    </item>
    
    <item>
      <title>1148 Article Views I</title>
      <link>https://foxisawesome.github.io/sql/1148-article-views-i/</link>
      <pubDate>Mon, 19 Oct 2020 14:41:54 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1148-article-views-i/</guid>
      <description>LC 1148 Article Views I Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id. The query result format is in the following example: Views table: +------------+-----------+-----------+------------+ | article_id | author_id | viewer_id | view_date | +------------+-----------+-----------+------------+ | 1 | 3 | 5 | 2019-08-01 | | 1 | 3 | 6 | 2019-08-02 |</description>
    </item>
    
  </channel>
</rss>
