<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/dfs/</link>
    <description>Recent content in DFS on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 11 Oct 2020 21:26:03 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1479 Sales by Day of the Week</title>
      <link>https://foxisawesome.github.io/sql/1479-sales-by-day-of-the-week/</link>
      <pubDate>Fri, 16 Oct 2020 09:29:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1479-sales-by-day-of-the-week/</guid>
      <description>LC 1479 Sales by Day of the Week   Write an SQL query to report how many units in each category have been ordered on each day of the week.
Return the result table ordered by category.
 Solution 2020-10-16 Notes:  DAYOFWEEK() : ‘2’ is Mon. MYSQL does not have pivot function, use below template  WITH combo AS ( SELECT b.*, DAYOFWEEK(order_date) AS week, item_category FROM items a LEFT JOIN orders b ON a.</description>
    </item>
    
    <item>
      <title>615 Average Salary Departments vs Company</title>
      <link>https://foxisawesome.github.io/sql/615-average-salary-departments-vs-company/</link>
      <pubDate>Fri, 16 Oct 2020 09:08:36 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/615-average-salary-departments-vs-company/</guid>
      <description>LC 615 Average Salary Departments vs Company Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company&amp;rsquo;s average salary. Table: salary | id | employee_id | amount | pay_date | |----|-------------|--------|------------| | 1 | 1 | 9000 | 2017-03-31 | | 2 | 2 | 6000 | 2017-03-31 | | 3 | 3 |</description>
    </item>
    
    <item>
      <title>1024 Video Stitching</title>
      <link>https://foxisawesome.github.io/posts/1024-video-stitching/</link>
      <pubDate>Thu, 15 Oct 2020 12:03:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1024-video-stitching/</guid>
      <description>LC 1024 Video Stitching You are given a series of video clips from a sporting event that lasted T seconds. These video clips can be overlapping with each other and have varied lengths. Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1]. We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0,</description>
    </item>
    
    <item>
      <title>452 Minimum Number of Arrows to Burst Balloons</title>
      <link>https://foxisawesome.github.io/posts/452-minimum-number-of-arrows-to-burst-balloons/</link>
      <pubDate>Thu, 15 Oct 2020 10:20:23 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/452-minimum-number-of-arrows-to-burst-balloons/</guid>
      <description>LC 452 Minimum Number of Arrows to Burst Balloons There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it&amp;rsquo;s horizontal, y-coordinates don&amp;rsquo;t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end. An arrow can be shot up exactly vertically from different points</description>
    </item>
    
    <item>
      <title>435 Non Overlapping Intervals</title>
      <link>https://foxisawesome.github.io/posts/435-non-overlapping-intervals/</link>
      <pubDate>Thu, 15 Oct 2020 10:04:00 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/435-non-overlapping-intervals/</guid>
      <description>LC 435 Non Overlapping Intervals Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Input: [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Solution 2020-10-15 Notes: Greedy 算法解决的一类 区间问题。 这题的思路是，先把每</description>
    </item>
    
    <item>
      <title>613 Shortest Distance in a Line</title>
      <link>https://foxisawesome.github.io/sql/613-shortest-distance-in-a-line/</link>
      <pubDate>Wed, 14 Oct 2020 19:50:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/613-shortest-distance-in-a-line/</guid>
      <description>LC 613 Shortest Distance in a Line   Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.
Write a query to find the shortest distance between two points in these points.
| x | |-----| | -1 | | 0 | | 2 |  The shortest distance is &amp;lsquo;1&amp;rsquo; obviously, which is from point &amp;lsquo;-1&amp;rsquo; to &amp;lsquo;0&amp;rsquo;. So the output is as below:</description>
    </item>
    
    <item>
      <title>603 Consecutive Available Seats</title>
      <link>https://foxisawesome.github.io/sql/603-consecutive-available-seats/</link>
      <pubDate>Wed, 14 Oct 2020 19:47:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/603-consecutive-available-seats/</guid>
      <description>LC 603 Consecutive Available Seats   Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?
| seat_id | free | |---------|------| | 1 | 1 | | 2 | 0 | | 3 | 1 | | 4 | 1 | | 5 | 1 |  Your query should return the following result for the sample case above.</description>
    </item>
    
    <item>
      <title>602 Friend Requests Ii Who Has the Most Friends</title>
      <link>https://foxisawesome.github.io/sql/602-friend-requests-ii-who-has-the-most-friends/</link>
      <pubDate>Wed, 14 Oct 2020 19:41:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/602-friend-requests-ii-who-has-the-most-friends/</guid>
      <description>LC 602 Friend Requests Ii Who Has the Most Friends Write a query to find the the people who has most friends and the most friends number under the following rules: It is guaranteed there is only 1 people having the most friends. The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value. For the sample data above,</description>
    </item>
    
    <item>
      <title>974 Subarray Sums Divisible by K</title>
      <link>https://foxisawesome.github.io/posts/974-subarray-sums-divisible-by-k/</link>
      <pubDate>Wed, 14 Oct 2020 17:17:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/974-subarray-sums-divisible-by-k/</guid>
      <description>LC 974 Subarray Sums Divisible by K   Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.
Input: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]   Solution 2020-10-14 Notes:  About the problems - sum of contiguous subarray , prefix sum is a common technique.</description>
    </item>
    
    <item>
      <title>909 Snakes and Ladders</title>
      <link>https://foxisawesome.github.io/posts/909-snakes-and-ladders/</link>
      <pubDate>Wed, 14 Oct 2020 15:51:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/909-snakes-and-ladders/</guid>
      <description>LC 909 Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation: At the beginning, you start at square 1 [at row 5, column</description>
    </item>
    
    <item>
      <title>1428 Leftmost Column With at Least a One</title>
      <link>https://foxisawesome.github.io/posts/1428-leftmost-column-with-at-least-a-one/</link>
      <pubDate>Tue, 13 Oct 2020 20:37:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1428-leftmost-column-with-at-least-a-one/</guid>
      <description>LC 1428 Leftmost Column With at Least a One (This problem is an interactive problem.) A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;rsquo;t exist, return -1. You can&amp;rsquo;t access the Binary Matrix</description>
    </item>
    
    <item>
      <title>1581 Customer Who Visited but Did Not Make Any Transactions</title>
      <link>https://foxisawesome.github.io/sql/1581-customer-who-visited-but-did-not-make-any-transactions/</link>
      <pubDate>Tue, 13 Oct 2020 20:09:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1581-customer-who-visited-but-did-not-make-any-transactions/</guid>
      <description>LC 1581 Customer Who Visited but Did Not Make Any Transactions Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits. Return the result table sorted in any order. The query result format is in the following example: Visits +----------+-------------+ | visit_id | customer_id | +----------+-------------+ | 1 | 23 | |</description>
    </item>
    
    <item>
      <title>1613 Find the Missing Ids</title>
      <link>https://foxisawesome.github.io/sql/1613-find-the-missing-ids/</link>
      <pubDate>Tue, 13 Oct 2020 20:03:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1613-find-the-missing-ids/</guid>
      <description>LC 1613 Find the Missing Ids Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following</description>
    </item>
    
    <item>
      <title>1587 Bank Account Summary II</title>
      <link>https://foxisawesome.github.io/sql/1587-bank-account-summary-ii/</link>
      <pubDate>Tue, 13 Oct 2020 19:51:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1587-bank-account-summary-ii/</guid>
      <description>LC 1587 Bank Account Summary II Write an SQL query to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. Return the result table in any order. The query result format is in the following example. Users table: +------------+--------------+ | account | name | +------------+--------------+ | 900001</description>
    </item>
    
    <item>
      <title>654 Maximum Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/654-maximum-binary-tree/</link>
      <pubDate>Tue, 13 Oct 2020 16:05:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/654-maximum-binary-tree/</guid>
      <description>LC 654 Maximum Binary Tree Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree</description>
    </item>
    
    <item>
      <title>106 Construct Binary Tree From Inorder and Postorder Traversal</title>
      <link>https://foxisawesome.github.io/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Tue, 13 Oct 2020 15:28:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>LC 106 Construct Binary Tree From Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution 2020-10-13 Notes: 和 LC 105 一个道理。 # Definition</description>
    </item>
    
    <item>
      <title>105 Construct Binary Tree From Preorder and Inorder Traversal</title>
      <link>https://foxisawesome.github.io/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Tue, 13 Oct 2020 15:21:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>LC 105 Construct Binary Tree From Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution 2020-10-13 Notes: 这题关键是 root 在 ino</description>
    </item>
    
    <item>
      <title>116 Populating Next Right Pointers in Each Node</title>
      <link>https://foxisawesome.github.io/posts/116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Tue, 13 Oct 2020 14:59:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/116-populating-next-right-pointers-in-each-node/</guid>
      <description>LC 116 Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer</description>
    </item>
    
    <item>
      <title>226 Invert Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Oct 2020 09:16:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/226-invert-binary-tree/</guid>
      <description>LC 226 Invert Binary Tree   nvert a binary tree.
Input:
 4 / \ 2 7 / \ / \ 1 3 6 9  Output:
 4 / \ 7 2 / \ / \ 9 6 3 1   Solution 2020-10-13 Notes:    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>453 Minimum Moves to Equal Array Elements</title>
      <link>https://foxisawesome.github.io/posts/453-minimum-moves-to-equal-array-elements/</link>
      <pubDate>Sun, 11 Oct 2020 21:45:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/453-minimum-moves-to-equal-array-elements/</guid>
      <description>LC 453 Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Input: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4] Solution 2020-10-11 Notes: 很巧的一</description>
    </item>
    
  </channel>
</rss>
