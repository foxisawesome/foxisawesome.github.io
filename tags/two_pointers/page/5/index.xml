<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>two_pointers on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/two_pointers/</link>
    <description>Recent content in two_pointers on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 02 Oct 2020 14:14:19 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/two_pointers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>468 Validate Ip Address</title>
      <link>https://foxisawesome.github.io/posts/468-validate-ip-address/</link>
      <pubDate>Thu, 08 Oct 2020 20:03:36 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/468-validate-ip-address/</guid>
      <description>LC 468 Validate Ip Address Given a string IP, return &amp;quot;IPv4&amp;quot; if IP is a valid IPv4 address, &amp;quot;IPv6&amp;quot; if IP is a valid IPv6 address or &amp;quot;Neither&amp;quot; if IP is not a correct IP of any type. A valid IPv4 address is an IP in the form &amp;quot;x1.x2.x3.x4&amp;quot; where 0 &amp;lt;= xi &amp;lt;= 255 and xi cannot contain leading zeros. For example, &amp;quot;192.168.1.1&amp;quot; and &amp;quot;192.168.1.0&amp;quot; are valid IPv4 addresses</description>
    </item>
    
    <item>
      <title>595 Big Countries</title>
      <link>https://foxisawesome.github.io/sql/595-big-countries/</link>
      <pubDate>Thu, 08 Oct 2020 17:00:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/595-big-countries/</guid>
      <description>LC 595 Big Countries   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.
Write a SQL solution to output big countries&#39; name, population and area.
 Solution 2020-10-08 Notes:   #Union solution is actually faster than using #or.
  Why Union is faster than OR?
Strictly speaking, Using UNION is faster when it comes to cases like scan two different column like this</description>
    </item>
    
    <item>
      <title>596 Classes More Than 5 Students</title>
      <link>https://foxisawesome.github.io/sql/596-classes-more-than-5-students/</link>
      <pubDate>Thu, 08 Oct 2020 16:53:20 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/596-classes-more-than-5-students/</guid>
      <description>LC 596 Classes More Than 5 Students   There is a table courses with columns: student and class
Please list out all classes which have more than or equal to 5 students.
 Solution 2020-10-08 Notes: SELECT DISTINCT class FROM ( SELECT *, COUNT(student) OVER(PARTITION BY class) AS ct FROM (SELECT DISTINCT student, class FROM courses) b ) a WHERE ct &amp;gt;= 5  </description>
    </item>
    
    <item>
      <title>1532 the Most Recent Three Orders</title>
      <link>https://foxisawesome.github.io/sql/1532-the-most-recent-three-orders/</link>
      <pubDate>Thu, 08 Oct 2020 16:44:43 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1532-the-most-recent-three-orders/</guid>
      <description>LC 1532 the Most Recent Three Orders   Write an SQL query to find the most recent 3 orders of each user. If a user ordered less than 3 orders return all of their orders.
Return the result table sorted by customer_name in ascending order and in case of a tie by the customer_id in ascending order. If there still a tie, order them by the order_date in descending order.</description>
    </item>
    
    <item>
      <title>1607 Sellers With No Sales</title>
      <link>https://foxisawesome.github.io/sql/1607-sellers-with-no-sales/</link>
      <pubDate>Thu, 08 Oct 2020 16:39:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1607-sellers-with-no-sales/</guid>
      <description>LC 1607 Sellers With No Sales   Write an SQL query to report the names of all sellers who did not make any sales in 2020.
Return the result table ordered by seller_name in ascending order.
 Solution 2020-10-08 Notes: SELECT DISTINCT seller_name FROM seller WHERE seller_id NOT IN (SELECT seller_id FROM orders WHERE LEFT(sale_date,4)=2020) ORDER BY 1  </description>
    </item>
    
    <item>
      <title>1152 Analyze User Website Visit Pattern</title>
      <link>https://foxisawesome.github.io/posts/1152-analyze-user-website-visit-pattern/</link>
      <pubDate>Thu, 08 Oct 2020 10:33:48 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1152-analyze-user-website-visit-pattern/</guid>
      <description>LC 1152 Analyze User Website Visit Pattern We are given some website visits: the user with name username[i] visited the website website[i] at time timestamp[i]. A 3-sequence is a list of websites of length 3 sorted in ascending order by the time of their visits. (The websites in a 3-sequence are not necessarily distinct.) Find the 3-sequence visited by the largest number of users. If there is more than one</description>
    </item>
    
    <item>
      <title>1350 Students With Invalid Departments</title>
      <link>https://foxisawesome.github.io/sql/1350-students-with-invalid-departments/</link>
      <pubDate>Wed, 07 Oct 2020 21:36:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1350-students-with-invalid-departments/</guid>
      <description>LC 1350 Students With Invalid Departments   Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.
Return the result table in any order.
The query result format is in the following example:
Departments table: +------+--------------------------+ | id | name | +------+--------------------------+ | 1 | Electrical Engineering | | 7 | Computer Engineering | | 13 | Bussiness Administration | +------+--------------------------+ Students table: +------+----------+---------------+ | id | name | department_id | +------+----------+---------------+ | 23 | Alice | 1 | | 1 | Bob | 7 | | 5 | Jennifer | 13 | | 2 | John | 14 | | 4 | Jasmine | 77 | | 3 | Steve | 74 | | 6 | Luis | 1 | | 8 | Jonathan | 7 | | 7 | Daiana | 33 | | 11 | Madelynn | 1 | +------+----------+---------------+ Result table: +------+----------+ | id | name | +------+----------+ | 2 | John | | 7 | Daiana | | 4 | Jasmine | | 3 | Steve | +------+----------+ John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively.</description>
    </item>
    
    <item>
      <title>1174 Immediate Food Delivery II</title>
      <link>https://foxisawesome.github.io/sql/1174-immediate-food-delivery-ii/</link>
      <pubDate>Wed, 07 Oct 2020 21:29:20 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1174-immediate-food-delivery-ii/</guid>
      <description>LC 1174 Immediate Food Delivery II Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. The query result format is in the following example: Delivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 2 | 2019-08-02 | 2019-08-02 | |</description>
    </item>
    
    <item>
      <title>1173 Immediate Food Delivery I</title>
      <link>https://foxisawesome.github.io/sql/1173-immediate-food-delivery-i/</link>
      <pubDate>Wed, 07 Oct 2020 21:23:23 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1173-immediate-food-delivery-i/</guid>
      <description>LC 1173 Immediate Food Delivery I   Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.
The query result format is in the following example:
Delivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 5 | 2019-08-02 | 2019-08-02 | | 3 | 1 | 2019-08-11 | 2019-08-11 | | 4 | 3 | 2019-08-24 | 2019-08-26 | | 5 | 4 | 2019-08-21 | 2019-08-22 | | 6 | 2 | 2019-08-11 | 2019-08-13 | +-------------+-------------+------------+-----------------------------+ Result table: +----------------------+ | immediate_percentage | +----------------------+ | 33.</description>
    </item>
    
    <item>
      <title>763 Partition Labels</title>
      <link>https://foxisawesome.github.io/posts/763-partition-labels/</link>
      <pubDate>Wed, 07 Oct 2020 21:12:44 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/763-partition-labels/</guid>
      <description>LC 763 Partition Labels A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. Input: S = &amp;quot;ababcbacadefegdehijhklij&amp;quot; Output: [9,7,8] Explanation: The partition is &amp;quot;ababcbaca&amp;quot;, &amp;quot;defegde&amp;quot;, &amp;quot;hijhklij&amp;quot;. This is a partition so that each letter appears in</description>
    </item>
    
    <item>
      <title>1285 Find the Start and End Number of Continuous Ranges</title>
      <link>https://foxisawesome.github.io/sql/1285-find-the-start-and-end-number-of-continuous-ranges/</link>
      <pubDate>Tue, 06 Oct 2020 22:18:54 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1285-find-the-start-and-end-number-of-continuous-ranges/</guid>
      <description>LC 1285 Find the Start and End Number of Continuous Ranges Write an SQL query to find the start and end number of continuous ranges in table Logs. Order the result table by start_id. The query result format is in the following example: Logs table: +------------+ | log_id | +------------+ | 1 | | 2 | | 3 | | 7 | | 8 | | 10 | +------------+ Result</description>
    </item>
    
    <item>
      <title>626 Exchange Seats</title>
      <link>https://foxisawesome.github.io/sql/626-exchange-seats/</link>
      <pubDate>Tue, 06 Oct 2020 21:59:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/626-exchange-seats/</guid>
      <description>LC 626 Exchange Seats   Can you write a SQL query to output the result for Mary?
+---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+  For the sample input, the output is:
+---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+   Solution 2020-10-06 Notes: SELECT CASE WHEN MOD(id, 2) = 1 AND id !</description>
    </item>
    
    <item>
      <title>55 Jump Game</title>
      <link>https://foxisawesome.github.io/posts/55-jump-game/</link>
      <pubDate>Tue, 06 Oct 2020 19:25:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/55-jump-game/</guid>
      <description>LC 55 Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Solution 2020-10-06 Notes: 这</description>
    </item>
    
    <item>
      <title>1194 Tournament Winners</title>
      <link>https://foxisawesome.github.io/sql/1194-tournament-winners/</link>
      <pubDate>Mon, 05 Oct 2020 21:07:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1194-tournament-winners/</guid>
      <description>LC 1194 Tournament Winners The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins. Write an SQL query to find the winner in each group. The query result format is in the following example: Players table: +-----------+------------+ | player_id | group_id | +-----------+------------+ | 15 | 1 | | 25 | 1 |</description>
    </item>
    
    <item>
      <title>571 Find Median Given Frequency of Numbers</title>
      <link>https://foxisawesome.github.io/sql/571-find-median-given-frequency-of-numbers/</link>
      <pubDate>Mon, 05 Oct 2020 20:46:24 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/571-find-median-given-frequency-of-numbers/</guid>
      <description>LC 571 Find Median Given Frequency of Numbers The Numbers table keeps the value of number and its frequency. +----------+-------------+ | Number | Frequency | +----------+-------------| | 0 | 7 | | 1 | 1 | | 2 | 3 | | 3 | 1 | +----------+-------------+ In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0</description>
    </item>
    
    <item>
      <title>569 Median Employee Salary</title>
      <link>https://foxisawesome.github.io/sql/569-median-employee-salary/</link>
      <pubDate>Mon, 05 Oct 2020 20:26:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/569-median-employee-salary/</guid>
      <description>LC 569 Median Employee Salary The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. +-----+------------+--------+ |Id | Company | Salary | +-----+------------+--------+ |1 | A | 2341 | |2 | A | 341 | |3 | A | 15 | |4 | A | 15314 | |5 | A | 451 | |6 | A | 513 | |7 | B</description>
    </item>
    
    <item>
      <title>107 Binary Tree Level Order Traversal II</title>
      <link>https://foxisawesome.github.io/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Mon, 05 Oct 2020 10:06:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>LC 107 Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution 2020-10-05 Notes: 学习了 负雪明</description>
    </item>
    
    <item>
      <title>1454 Active Users</title>
      <link>https://foxisawesome.github.io/sql/1454-active-users/</link>
      <pubDate>Sun, 04 Oct 2020 21:18:04 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1454-active-users/</guid>
      <description>LC 1454 Active Users   Write an SQL query to find the id and the name of active users.
Active users are those who logged in to their accounts for 5 or more consecutive days.
Return the result table ordered by the id.
The query result format is in the following example:
Accounts table: +----+----------+ | id | name | +----+----------+ | 1 | Winston | | 7 | Jonathan | +----+----------+ Logins table: +----+------------+ | id | login_date | +----+------------+ | 7 | 2020-05-30 | | 1 | 2020-05-30 | | 7 | 2020-05-31 | | 7 | 2020-06-01 | | 7 | 2020-06-02 | | 7 | 2020-06-02 | | 7 | 2020-06-03 | | 1 | 2020-06-07 | | 7 | 2020-06-10 | +----+------------+ Result table: +----+----------+ | id | name | +----+----------+ | 7 | Jonathan | +----+----------+   Solution 2020-10-04 Notes:  consecutive 5 days: DATEDIFF(date, LEAD(date,4)) = 4  SELECT DISTINCT a.</description>
    </item>
    
    <item>
      <title>579 Find Cumulative Salary of an Employee</title>
      <link>https://foxisawesome.github.io/sql/579-find-cumulative-salary-of-an-employee/</link>
      <pubDate>Sun, 04 Oct 2020 21:05:57 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/579-find-cumulative-salary-of-an-employee/</guid>
      <description>LC 579 Find Cumulative Salary of an Employee The Employee table holds the salary information in a year. Write a SQL to get the cumulative sum of an employee&amp;rsquo;s salary over a period of 3 months but exclude the most recent month. The result should be displayed by &amp;lsquo;Id&amp;rsquo; ascending, and then by &amp;lsquo;Month&amp;rsquo; descending. Example Input | Id | Month | Salary | |----|-------|--------| | 1 | 1 |</description>
    </item>
    
    <item>
      <title>1075 Project Employees I</title>
      <link>https://foxisawesome.github.io/sql/1075-project-employees-i/</link>
      <pubDate>Sun, 04 Oct 2020 20:55:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1075-project-employees-i/</guid>
      <description>LC 1075 Project Employees I   Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
The query result format is in the following example:
Project table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Employee table: +-------------+--------+------------------+ | employee_id | name | experience_years | +-------------+--------+------------------+ | 1 | Khaled | 3 | | 2 | Ali | 2 | | 3 | John | 1 | | 4 | Doe | 2 | +-------------+--------+------------------+ Result table: +-------------+---------------+ | project_id | average_years | +-------------+---------------+ | 1 | 2.</description>
    </item>
    
  </channel>
</rss>
