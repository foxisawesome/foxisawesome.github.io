<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sort on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/sort/</link>
    <description>Recent content in sort on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 25 Sep 2020 10:27:10 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/sort/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>925 Long Pressed Name</title>
      <link>https://foxisawesome.github.io/posts/925-long-pressed-name/</link>
      <pubDate>Sun, 27 Sep 2020 16:14:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/925-long-pressed-name/</guid>
      <description>LC 925 Long Pressed Name Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Solution 2020-09-27 Notes: 这题好</description>
    </item>
    
    <item>
      <title>455 Assign Cookies</title>
      <link>https://foxisawesome.github.io/posts/455-assign-cookies/</link>
      <pubDate>Sun, 27 Sep 2020 15:43:20 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/455-assign-cookies/</guid>
      <description>LC 455 Assign Cookies Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to</description>
    </item>
    
    <item>
      <title>152 Valid Palindrome</title>
      <link>https://foxisawesome.github.io/posts/152-valid-palindrome/</link>
      <pubDate>Sun, 27 Sep 2020 15:20:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/152-valid-palindrome/</guid>
      <description>LC 152 Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. e.g. “0P”, “.,” Solution 2020-09-27 Notes: 题目本身很简单，但是two notes：1. wh</description>
    </item>
    
    <item>
      <title>11 Container With Most Water</title>
      <link>https://foxisawesome.github.io/posts/11-container-with-most-water/</link>
      <pubDate>Sun, 27 Sep 2020 15:10:08 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/11-container-with-most-water/</guid>
      <description>LC 11 Container With Most Water Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Solution 2020-09-27 Notes: 左右poi</description>
    </item>
    
    <item>
      <title>74 Search a 2d Matrix</title>
      <link>https://foxisawesome.github.io/posts/74-search-a-2d-matrix/</link>
      <pubDate>Fri, 25 Sep 2020 19:49:42 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/74-search-a-2d-matrix/</guid>
      <description>LC 74 Search a 2d Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Solution 2020-09-25 Notes: Right bound binary search returns the closest left bound, e.g. binarySearch([1,3,5,7], 4). 两次</description>
    </item>
    
    <item>
      <title>Cheatsheet</title>
      <link>https://foxisawesome.github.io/posts/cheatsheet/</link>
      <pubDate>Fri, 25 Sep 2020 19:13:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/cheatsheet/</guid>
      <description> [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip([&#39;a&#39;,&#39;b&#39;],[&#39;c&#39;,&#39;d&#39;])]: [[&amp;lsquo;a&amp;rsquo;, &amp;lsquo;c&amp;rsquo;], [&amp;lsquo;b&amp;rsquo;, &amp;rsquo;d&amp;rsquo;]] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]  </description>
    </item>
    
    <item>
      <title>36 Valid Sudoku</title>
      <link>https://foxisawesome.github.io/posts/36-valid-sudoku/</link>
      <pubDate>Fri, 25 Sep 2020 19:13:25 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/36-valid-sudoku/</guid>
      <description>LC 36 Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. Solution 2020-09-25 Notes: 按</description>
    </item>
    
    <item>
      <title>771 Jewels and Stones</title>
      <link>https://foxisawesome.github.io/posts/771-jewels-and-stones/</link>
      <pubDate>Fri, 25 Sep 2020 15:54:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/771-jewels-and-stones/</guid>
      <description>LC 771 Jewels and Stones You&amp;rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so</description>
    </item>
    
    <item>
      <title>62 Unique Paths</title>
      <link>https://foxisawesome.github.io/posts/62-unique-paths/</link>
      <pubDate>Fri, 25 Sep 2020 15:47:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/62-unique-paths/</guid>
      <description>LC 62 Unique Paths A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below). How many possible unique paths are there? Solution 2020-09-25 Notes: 像cli</description>
    </item>
    
    <item>
      <title>819 Most Common Word</title>
      <link>https://foxisawesome.github.io/posts/819-most-common-word/</link>
      <pubDate>Fri, 25 Sep 2020 14:39:42 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/819-most-common-word/</guid>
      <description>LC 819 Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The</description>
    </item>
    
    <item>
      <title>1137 N Th Tribonacci Number</title>
      <link>https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/</link>
      <pubDate>Fri, 25 Sep 2020 14:13:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/</guid>
      <description>LC 1137 N Th Tribonacci Number The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0. Given n, return the value of Tn. Solution 2020-09-25 Notes: 加个memo在 def __init__(self): 能把整个recursion写在一</description>
    </item>
    
    <item>
      <title>303 Range Sum Query Immutable</title>
      <link>https://foxisawesome.github.io/posts/303-range-sum-query-immutable/</link>
      <pubDate>Fri, 25 Sep 2020 14:03:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/303-range-sum-query-immutable/</guid>
      <description>LC 303 Range Sum Query Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Solution 2020-09-25 Notes: 这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求</description>
    </item>
    
    <item>
      <title>209 Minimum Size Subarray Sum</title>
      <link>https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/</link>
      <pubDate>Fri, 25 Sep 2020 11:08:36 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/</guid>
      <description>LC 209 Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead. Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint Solution 2020-09-25 Notes: 这题 O(N)的</description>
    </item>
    
    <item>
      <title>167 Two Sum II Input Array Is Sorted</title>
      <link>https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Fri, 25 Sep 2020 10:36:56 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>LC 167 Two Sum II Input Array Is Sorted Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The</description>
    </item>
    
    <item>
      <title>75 Sort Colors</title>
      <link>https://foxisawesome.github.io/posts/75-sort-colors/</link>
      <pubDate>Fri, 25 Sep 2020 10:27:10 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/75-sort-colors/</guid>
      <description>LC 75 Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Follow up: Could you solve this problem without using the library&amp;rsquo;s sort function?</description>
    </item>
    
    <item>
      <title>181 Employees Earning More Than Their Managers</title>
      <link>https://foxisawesome.github.io/sql/181-employees-earning-more-than-their-managers/</link>
      <pubDate>Thu, 24 Sep 2020 21:57:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/181-employees-earning-more-than-their-managers/</guid>
      <description>LC 181 Employees Earning More Than Their Managers   Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.
 Solution 2020-09-24 Notes: SELECT name AS employee FROM ( SELECT a.name, a.salary, a.managerId, b.salary AS mg_sal FROM employee a JOIN employee b ON a.managerID = b.ID ) c WHERE salary &amp;gt; mg_sal  </description>
    </item>
    
    <item>
      <title>180 Consecutive Numbers</title>
      <link>https://foxisawesome.github.io/sql/180-consecutive-numbers/</link>
      <pubDate>Thu, 24 Sep 2020 21:41:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/180-consecutive-numbers/</guid>
      <description>LC 180 Consecutive Numbers Write a SQL query to find all numbers that appear at least three times consecutively. Solution 2020-09-24 Notes: self join 的写法 SELECT DISTINCT a.num AS ConsecutiveNums FROM logs a JOIN logs b ON a.id+1 = b.id AND a.num=b.num JOIN logs c ON a.id+2 = c.id AND a.num=c.num LEAD() function 的写法： SELECT DISTINCT num AS consecutiveNums FROM ( SELECT id, num, LEAD(num,1)</description>
    </item>
    
    <item>
      <title>177 Nth Highest Salary</title>
      <link>https://foxisawesome.github.io/sql/177-nth-highest-salary/</link>
      <pubDate>Thu, 24 Sep 2020 21:16:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/177-nth-highest-salary/</guid>
      <description>LC 177 Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. Solution 2020-09-24 Notes: 这个sql function 的写法得背下来。不过也没什么难的。 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE m int; SET m = n-1; RETURN ( SELECT salary FROM employee GROUP BY 1 ORDER by</description>
    </item>
    
    <item>
      <title>875 Koko Eating Bananas</title>
      <link>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</link>
      <pubDate>Thu, 24 Sep 2020 13:51:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</guid>
      <description>LC 875 Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them</description>
    </item>
    
    <item>
      <title>774 Minimize Max Distance to Gas Station</title>
      <link>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</link>
      <pubDate>Thu, 24 Sep 2020 13:49:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</guid>
      <description>LC 774 Minimize Max Distance to Gas Station On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D. Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000</description>
    </item>
    
  </channel>
</rss>
