<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sort on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/sort/</link>
    <description>Recent content in sort on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 09 Oct 2020 15:32:40 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/sort/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>626 Exchange Seats</title>
      <link>https://foxisawesome.github.io/sql/626-exchange-seats/</link>
      <pubDate>Tue, 06 Oct 2020 21:59:09 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/626-exchange-seats/</guid>
      <description>LC 626 Exchange Seats   Can you write a SQL query to output the result for Mary?
+---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+  For the sample input, the output is:
+---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+   Solution 2020-10-06 Notes: SELECT CASE WHEN MOD(id, 2) = 1 AND id !</description>
    </item>
    
    <item>
      <title>55 Jump Game</title>
      <link>https://foxisawesome.github.io/posts/55-jump-game/</link>
      <pubDate>Tue, 06 Oct 2020 19:25:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/55-jump-game/</guid>
      <description>LC 55 Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Solution 2020-10-06 Notes: 这</description>
    </item>
    
    <item>
      <title>1194 Tournament Winners</title>
      <link>https://foxisawesome.github.io/sql/1194-tournament-winners/</link>
      <pubDate>Mon, 05 Oct 2020 21:07:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1194-tournament-winners/</guid>
      <description>LC 1194 Tournament Winners The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins. Write an SQL query to find the winner in each group. The query result format is in the following example: Players table: +-----------+------------+ | player_id | group_id | +-----------+------------+ | 15 | 1 | | 25 | 1 |</description>
    </item>
    
    <item>
      <title>571 Find Median Given Frequency of Numbers</title>
      <link>https://foxisawesome.github.io/sql/571-find-median-given-frequency-of-numbers/</link>
      <pubDate>Mon, 05 Oct 2020 20:46:24 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/571-find-median-given-frequency-of-numbers/</guid>
      <description>LC 571 Find Median Given Frequency of Numbers The Numbers table keeps the value of number and its frequency. +----------+-------------+ | Number | Frequency | +----------+-------------| | 0 | 7 | | 1 | 1 | | 2 | 3 | | 3 | 1 | +----------+-------------+ In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0</description>
    </item>
    
    <item>
      <title>569 Median Employee Salary</title>
      <link>https://foxisawesome.github.io/sql/569-median-employee-salary/</link>
      <pubDate>Mon, 05 Oct 2020 20:26:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/569-median-employee-salary/</guid>
      <description>LC 569 Median Employee Salary The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. +-----+------------+--------+ |Id | Company | Salary | +-----+------------+--------+ |1 | A | 2341 | |2 | A | 341 | |3 | A | 15 | |4 | A | 15314 | |5 | A | 451 | |6 | A | 513 | |7 | B</description>
    </item>
    
    <item>
      <title>107 Binary Tree Level Order Traversal II</title>
      <link>https://foxisawesome.github.io/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Mon, 05 Oct 2020 10:06:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>LC 107 Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution 2020-10-05 Notes: 学习了 负雪明</description>
    </item>
    
    <item>
      <title>1454 Active Users</title>
      <link>https://foxisawesome.github.io/sql/1454-active-users/</link>
      <pubDate>Sun, 04 Oct 2020 21:18:04 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1454-active-users/</guid>
      <description>LC 1454 Active Users   Write an SQL query to find the id and the name of active users.
Active users are those who logged in to their accounts for 5 or more consecutive days.
Return the result table ordered by the id.
The query result format is in the following example:
Accounts table: +----+----------+ | id | name | +----+----------+ | 1 | Winston | | 7 | Jonathan | +----+----------+ Logins table: +----+------------+ | id | login_date | +----+------------+ | 7 | 2020-05-30 | | 1 | 2020-05-30 | | 7 | 2020-05-31 | | 7 | 2020-06-01 | | 7 | 2020-06-02 | | 7 | 2020-06-02 | | 7 | 2020-06-03 | | 1 | 2020-06-07 | | 7 | 2020-06-10 | +----+------------+ Result table: +----+----------+ | id | name | +----+----------+ | 7 | Jonathan | +----+----------+   Solution 2020-10-04 Notes:  consecutive 5 days: DATEDIFF(date, LEAD(date,4)) = 4  SELECT DISTINCT a.</description>
    </item>
    
    <item>
      <title>579 Find Cumulative Salary of an Employee</title>
      <link>https://foxisawesome.github.io/sql/579-find-cumulative-salary-of-an-employee/</link>
      <pubDate>Sun, 04 Oct 2020 21:05:57 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/579-find-cumulative-salary-of-an-employee/</guid>
      <description>LC 579 Find Cumulative Salary of an Employee The Employee table holds the salary information in a year. Write a SQL to get the cumulative sum of an employee&amp;rsquo;s salary over a period of 3 months but exclude the most recent month. The result should be displayed by &amp;lsquo;Id&amp;rsquo; ascending, and then by &amp;lsquo;Month&amp;rsquo; descending. Example Input | Id | Month | Salary | |----|-------|--------| | 1 | 1 |</description>
    </item>
    
    <item>
      <title>1075 Project Employees I</title>
      <link>https://foxisawesome.github.io/sql/1075-project-employees-i/</link>
      <pubDate>Sun, 04 Oct 2020 20:55:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1075-project-employees-i/</guid>
      <description>LC 1075 Project Employees I   Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
The query result format is in the following example:
Project table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Employee table: +-------------+--------+------------------+ | employee_id | name | experience_years | +-------------+--------+------------------+ | 1 | Khaled | 3 | | 2 | Ali | 2 | | 3 | John | 1 | | 4 | Doe | 2 | +-------------+--------+------------------+ Result table: +-------------+---------------+ | project_id | average_years | +-------------+---------------+ | 1 | 2.</description>
    </item>
    
    <item>
      <title>620 Not Boring Movies</title>
      <link>https://foxisawesome.github.io/sql/620-not-boring-movies/</link>
      <pubDate>Sun, 04 Oct 2020 20:51:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/620-not-boring-movies/</guid>
      <description>LC 620 Not Boring Movies   X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.
Please write a SQL query to output movies with an odd numbered ID and a description that is not &amp;lsquo;boring&amp;rsquo;. Order the result by rating.
 Solution 2020-10-04 Notes: SELECT * FROM cinema WHERE id % 2 = 1 AND description !</description>
    </item>
    
    <item>
      <title>137 Single Number II</title>
      <link>https://foxisawesome.github.io/posts/137-single-number-ii/</link>
      <pubDate>Sun, 04 Oct 2020 20:43:36 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/137-single-number-ii/</guid>
      <description>LC 137 Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Input: [2,2,3,2] Output: 3 Input: [0,1,0,1,0,1,99] Output: 99 Solution 2020-10-04 Notes: 因为确定那个特殊值只出现一次，</description>
    </item>
    
    <item>
      <title>130 Surrounded Regions</title>
      <link>https://foxisawesome.github.io/posts/130-surrounded-regions/</link>
      <pubDate>Sun, 04 Oct 2020 20:34:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/130-surrounded-regions/</guid>
      <description>LC 130 Surrounded Regions Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;. A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X</description>
    </item>
    
    <item>
      <title>108 Convert Sorted Array to Binary Search Tree</title>
      <link>https://foxisawesome.github.io/posts/108-convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Sun, 04 Oct 2020 16:08:38 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/108-convert-sorted-array-to-binary-search-tree/</guid>
      <description>LC 108 Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following</description>
    </item>
    
    <item>
      <title>120 Triangle</title>
      <link>https://foxisawesome.github.io/posts/120-triangle/</link>
      <pubDate>Sun, 04 Oct 2020 16:00:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/120-triangle/</guid>
      <description>LC 120 Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using</description>
    </item>
    
    <item>
      <title>113 Path Sum II</title>
      <link>https://foxisawesome.github.io/posts/113-path-sum-ii/</link>
      <pubDate>Sun, 04 Oct 2020 15:04:33 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/113-path-sum-ii/</guid>
      <description>LC 113 Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum. Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution 2020-10-04 Notes: 很明显的dfs题。但</description>
    </item>
    
    <item>
      <title>114 Flatten Binary Tree to Linked List</title>
      <link>https://foxisawesome.github.io/posts/114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sun, 04 Oct 2020 10:58:04 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/114-flatten-binary-tree-to-linked-list/</guid>
      <description>LC 114 Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Solution 2020-10-04 Notes: 感觉这题是 tree 真正体会recu</description>
    </item>
    
    <item>
      <title>1596 the Most Frequently Ordered Products for Each Customer</title>
      <link>https://foxisawesome.github.io/sql/1596-the-most-frequently-ordered-products-for-each-customer/</link>
      <pubDate>Sat, 03 Oct 2020 19:53:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1596-the-most-frequently-ordered-products-for-each-customer/</guid>
      <description>LC 1596 the Most Frequently Ordered Products for Each Customer Write an SQL query to find the most frequently ordered product(s) for each customer. The result table should have the product_id and product_name for each customer_id who ordered at least one order. Return the result table in any order. The query result format is in the following example: Orders +----------+------------+-------------+------------+ | order_id | order_date | customer_id | product_id | +----------+------------+-------------+------------+</description>
    </item>
    
    <item>
      <title>1571 Warehouse Manager</title>
      <link>https://foxisawesome.github.io/sql/1571-warehouse-manager/</link>
      <pubDate>Sat, 03 Oct 2020 19:39:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1571-warehouse-manager/</guid>
      <description>LC 1571 Warehouse Manager   Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.
 warehouse_name volume  Return the result table in any order.
Warehouse table: +------------+--------------+-------------+ | name | product_id | units | +------------+--------------+-------------+ | LCHouse1 | 1 | 1 | | LCHouse1 | 2 | 10 | | LCHouse1 | 3 | 5 | | LCHouse2 | 1 | 2 | | LCHouse2 | 2 | 2 | | LCHouse3 | 4 | 1 | +------------+--------------+-------------+ Products table: +------------+--------------+------------+----------+-----------+ | product_id | product_name | Width | Length | Height | +------------+--------------+------------+----------+-----------+ | 1 | LC-TV | 5 | 50 | 40 | | 2 | LC-KeyChain | 5 | 5 | 5 | | 3 | LC-Phone | 2 | 10 | 10 | | 4 | LC-T-Shirt | 4 | 10 | 20 | +------------+--------------+------------+----------+-----------+ Result table: +----------------+------------+ | warehouse_name | volume | +----------------+------------+ | LCHouse1 | 12250 | | LCHouse2 | 20250 | | LCHouse3 | 800 | +----------------+------------+ Volume of product_id = 1 (LC-TV), 5x50x40 = 10000 Volume of product_id = 2 (LC-KeyChain), 5x5x5 = 125 Volume of product_id = 3 (LC-Phone), 2x10x10 = 200 Volume of product_id = 4 (LC-T-Shirt), 4x10x20 = 800 LCHouse1: 1 unit of LC-TV + 10 units of LC-KeyChain + 5 units of LC-Phone.</description>
    </item>
    
    <item>
      <title>1241 Number of Comments per Post</title>
      <link>https://foxisawesome.github.io/sql/1241-number-of-comments-per-post/</link>
      <pubDate>Sat, 03 Oct 2020 19:19:08 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1241-number-of-comments-per-post/</guid>
      <description>LC 1241 Number of Comments per Post Write an SQL query to find number of comments per each post. Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order. Submissions may contain duplicate comments. You should count the number of unique comments per post. Submissions may contain duplicate posts. You should treat them as one post. The query result format is in</description>
    </item>
    
    <item>
      <title>1084 Sales Analysis Iii</title>
      <link>https://foxisawesome.github.io/sql/1084-sales-analysis-iii/</link>
      <pubDate>Sat, 03 Oct 2020 18:58:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1084-sales-analysis-iii/</guid>
      <description>LC 1084 Sales Analysis Iii Write an SQL query that reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive. The query result format is in the following example: Product table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone | 1400 | +------------+--------------+------------+ Sales</description>
    </item>
    
  </channel>
</rss>
