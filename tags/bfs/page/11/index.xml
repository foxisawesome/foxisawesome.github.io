<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BFS on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/bfs/</link>
    <description>Recent content in BFS on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 14 Oct 2020 15:51:48 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>56 Merge Intervals</title>
      <link>https://foxisawesome.github.io/posts/56-merge-intervals/</link>
      <pubDate>Tue, 15 Sep 2020 13:14:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/56-merge-intervals/</guid>
      <description>LC 56 Merge Intervals Given a collection of intervals, merge all overlapping intervals. Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Solution 2020-09-15 Notes: 先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。 class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: if not intervals:</description>
    </item>
    
    <item>
      <title>23 Merge K Sorted Lists</title>
      <link>https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/</link>
      <pubDate>Mon, 14 Sep 2020 21:04:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/</guid>
      <description>LC 23 Merge K Sorted Lists You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] merging them into one sorted list: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Solution 2020-09-14 Notes: 最简单暴力，最挫的方法。</description>
    </item>
    
    <item>
      <title>3 Longest Substring Without Repeating Characters</title>
      <link>https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 14 Sep 2020 16:25:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/</guid>
      <description>LC 3 Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters. Solution 2020-09-14 Notes: 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding w</description>
    </item>
    
    <item>
      <title>516 Longest Palindromic Subsequence</title>
      <link>https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/</link>
      <pubDate>Mon, 14 Sep 2020 15:20:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/</guid>
      <description>LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence&amp;rsquo;s length in s. You may assume that the maximum length of s is 1000.
 Solution 2020-09-14 Notes:
   class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] !</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://foxisawesome.github.io/posts/5-longest-palindromic-substring/</link>
      <pubDate>Mon, 14 Sep 2020 10:05:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/5-longest-palindromic-substring/</guid>
      <description>LC 5 Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer. Solution 2020-09-14 Notes: 本质是dp，与LC 516相同 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: if not s: return &amp;quot;&amp;quot; n =</description>
    </item>
    
    <item>
      <title>937 Reorder Data in Log Files</title>
      <link>https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/</link>
      <pubDate>Mon, 14 Sep 2020 09:19:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/</guid>
      <description>LC 937 Reorder Data in Log Files You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs.</description>
    </item>
    
    <item>
      <title>53 Maximum Subarray</title>
      <link>https://foxisawesome.github.io/posts/53-maximum-subarray/</link>
      <pubDate>Sun, 13 Sep 2020 22:09:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/53-maximum-subarray/</guid>
      <description>LC 53 Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Solution 2020-09-13 Notes: 这是</description>
    </item>
    
    <item>
      <title>262 Trips and Users</title>
      <link>https://foxisawesome.github.io/sql/262-trips-and-users/</link>
      <pubDate>Sun, 13 Sep 2020 21:46:46 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/262-trips-and-users/</guid>
      <description>LC 262 Trips and Users Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users. For the above tables, your</description>
    </item>
    
    <item>
      <title>185 Department Top Three Salaries</title>
      <link>https://foxisawesome.github.io/sql/185-department-top-three-salaries/</link>
      <pubDate>Sun, 13 Sep 2020 21:43:06 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/185-department-top-three-salaries/</guid>
      <description>LC 185 Department Top Three Salaries Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe |</description>
    </item>
    
    <item>
      <title>175 Combine Two Tables</title>
      <link>https://foxisawesome.github.io/sql/175-combine-two-tables/</link>
      <pubDate>Sun, 13 Sep 2020 21:28:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/175-combine-two-tables/</guid>
      <description>LC 175 Combine Two Tables Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State Solution 2020-09-13 Notes: Easy 小题考查left join SELECT firstname, lastname, city, state FROM person a LEFT JOIN address b ON a.personid = b.personid</description>
    </item>
    
    <item>
      <title>176 Second Highest Salary</title>
      <link>https://foxisawesome.github.io/sql/176-second-highest-salary/</link>
      <pubDate>Sun, 13 Sep 2020 21:24:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/176-second-highest-salary/</guid>
      <description>LC 176 Second Highest Salary Write a SQL query to get the second highest salary from the Employee table. Solution 2020-09-13 Notes: 这easy题有个小坑，要是table 不存在second highest，于是subquery就不会</description>
    </item>
    
    <item>
      <title>146 LRU Cache</title>
      <link>https://foxisawesome.github.io/posts/146-lru-cache/</link>
      <pubDate>Sun, 13 Sep 2020 21:16:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/146-lru-cache/</guid>
      <description>LC 146 LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should</description>
    </item>
    
    <item>
      <title>99 Recover Binary Search Tree</title>
      <link>https://foxisawesome.github.io/posts/99-recover-binary-search-tree/</link>
      <pubDate>Sun, 13 Sep 2020 20:10:43 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/99-recover-binary-search-tree/</guid>
      <description>LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.
Recover the tree without changing its structure.
Input: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:
    </description>
    </item>
    
    <item>
      <title>92 Reverse Linked List ii</title>
      <link>https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/</link>
      <pubDate>Sun, 13 Sep 2020 19:51:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/</guid>
      <description>LC 92 Reverse Linked List ii Reverse a linked list from position m to n. Do it in one-pass. Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL Solution 2020-09-13 Notes: 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的util</description>
    </item>
    
    <item>
      <title>102 Binary Tree Level Order Traversal</title>
      <link>https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/</link>
      <pubDate>Sun, 13 Sep 2020 14:55:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/</guid>
      <description>LC 102 Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return [[3],[9,20],[15,7]] Solution 2020-09-13 Notes: 与LC 109 一样 Recursion 解法： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0,</description>
    </item>
    
    <item>
      <title>199 Binary Tree Right Side View</title>
      <link>https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/</link>
      <pubDate>Sun, 13 Sep 2020 14:39:30 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/</guid>
      <description>LC 199 Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- Solution 2020-09-13 Notes: 一刷虽然做出来了 但是在输出</description>
    </item>
    
    <item>
      <title>987 Vertical Order Traversal of a Binary Tree</title>
      <link>https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/</link>
      <pubDate>Sun, 13 Sep 2020 13:59:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/</guid>
      <description>LC 987 Vertical Order Traversal of a Binary Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes</description>
    </item>
    
    <item>
      <title>501 Find Mode in Binary Search Tree</title>
      <link>https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/</link>
      <pubDate>Sat, 12 Sep 2020 21:54:14 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/</guid>
      <description>LC 501 Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal</description>
    </item>
    
    <item>
      <title>621 Task Scheduler</title>
      <link>https://foxisawesome.github.io/posts/621-task-scheduler/</link>
      <pubDate>Sat, 12 Sep 2020 21:00:42 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/621-task-scheduler/</guid>
      <description>LC 621 Task Scheduler Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two</description>
    </item>
    
    <item>
      <title>300 Longest Increasing Subsequence</title>
      <link>https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/</link>
      <pubDate>Sat, 12 Sep 2020 20:05:08 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/</guid>
      <description>LC 300 Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Solution 2020-09-12 Notes: $\mathcal{O}(N^2)$的解，25%通过了。经典的d</description>
    </item>
    
  </channel>
</rss>
