<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>heap on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/heap/</link>
    <description>Recent content in heap on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 19 Oct 2020 16:16:26 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/heap/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>322 Coin Change</title>
      <link>https://foxisawesome.github.io/posts/322-coin-change/</link>
      <pubDate>Sat, 19 Sep 2020 21:28:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/322-coin-change/</guid>
      <description>LC 322 Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5</description>
    </item>
    
    <item>
      <title>692 Top K Frequent Words</title>
      <link>https://foxisawesome.github.io/posts/692-top-k-frequent-words/</link>
      <pubDate>Sat, 19 Sep 2020 21:00:53 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/692-top-k-frequent-words/</guid>
      <description>LC 692 Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Solution 2020-09-19 Notes: 重要的来了，一般，我们认为找出k个最大最小</description>
    </item>
    
    <item>
      <title>973 K Closest Points to Origin</title>
      <link>https://foxisawesome.github.io/posts/973-k-closest-points-to-origin/</link>
      <pubDate>Sat, 19 Sep 2020 20:47:04 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/973-k-closest-points-to-origin/</guid>
      <description>LC 973 K Closest Points to Origin We have a list of points on the plane. Find the K closest points to the origin (0, 0). Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) &amp;lt; sqrt(10), (-2, 2) is closer to the origin. We only want</description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://foxisawesome.github.io/posts/20-valid-parentheses/</link>
      <pubDate>Sat, 19 Sep 2020 20:37:05 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/20-valid-parentheses/</guid>
      <description>LC 20 Valid Parentheses Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solution 2020-09-19 Notes: 好经典的题。 思路如解。 class Solution: def isValid(self,</description>
    </item>
    
    <item>
      <title>953 Verifying an Alien Dictionary</title>
      <link>https://foxisawesome.github.io/posts/953-verifying-an-alien-dictionary/</link>
      <pubDate>Sat, 19 Sep 2020 20:17:38 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/953-verifying-an-alien-dictionary/</guid>
      <description>LC 953 Verifying an Alien Dictionary In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. Input: words = [&amp;quot;word&amp;quot;,&amp;quot;world&amp;quot;,&amp;quot;row&amp;quot;],</description>
    </item>
    
    <item>
      <title>70 Climbing Stairs</title>
      <link>https://foxisawesome.github.io/posts/70-climbing-stairs/</link>
      <pubDate>Tue, 15 Sep 2020 16:48:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/70-climbing-stairs/</guid>
      <description>LC 70 Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Solution 2020-09-15 Notes: 最经典的dp题了。dp[i] = dp[i-1] + dp[i-2], 主要是dp[i] 和</description>
    </item>
    
    <item>
      <title>91 Decode Ways</title>
      <link>https://foxisawesome.github.io/posts/91-decode-ways/</link>
      <pubDate>Tue, 15 Sep 2020 13:32:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/91-decode-ways/</guid>
      <description>LC 91 Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: &#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Input: &amp;ldquo;226&amp;rdquo; Output: 3 Explanation: It could be decoded as &amp;ldquo;BZ&amp;rdquo; (2 26), &amp;ldquo;VF&amp;rdquo; (22 6), or &amp;ldquo;BBF&amp;rdquo; (2 2 6). Solution 2020-09-15 Notes: 开</description>
    </item>
    
    <item>
      <title>238 Product of Array Except Self</title>
      <link>https://foxisawesome.github.io/posts/238-product-of-array-except-self/</link>
      <pubDate>Tue, 15 Sep 2020 13:22:13 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/238-product-of-array-except-self/</guid>
      <description>LC 238 Product of Array Except Self Given an array nums of n integers where n &amp;gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Input: [1,2,3,4] Output: [24,12,8,6] Solution 2020-09-15 Notes: 3-pass, space O(N) solution. L[i] = cumulative product of nums[:i], R[i] = cumulative product of nums[:i:-1] class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n</description>
    </item>
    
    <item>
      <title>56 Merge Intervals</title>
      <link>https://foxisawesome.github.io/posts/56-merge-intervals/</link>
      <pubDate>Tue, 15 Sep 2020 13:14:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/56-merge-intervals/</guid>
      <description>LC 56 Merge Intervals Given a collection of intervals, merge all overlapping intervals. Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Solution 2020-09-15 Notes: 先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。 class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: if not intervals:</description>
    </item>
    
    <item>
      <title>23 Merge K Sorted Lists</title>
      <link>https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/</link>
      <pubDate>Mon, 14 Sep 2020 21:04:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/</guid>
      <description>LC 23 Merge K Sorted Lists You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] merging them into one sorted list: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Solution 2020-09-14 Notes: 最简单暴力，最挫的方法。</description>
    </item>
    
    <item>
      <title>3 Longest Substring Without Repeating Characters</title>
      <link>https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Mon, 14 Sep 2020 16:25:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/</guid>
      <description>LC 3 Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters. Solution 2020-09-14 Notes: 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding w</description>
    </item>
    
    <item>
      <title>516 Longest Palindromic Subsequence</title>
      <link>https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/</link>
      <pubDate>Mon, 14 Sep 2020 15:20:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/</guid>
      <description>LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence&amp;rsquo;s length in s. You may assume that the maximum length of s is 1000.
 Solution 2020-09-14 Notes:
   class Solution: def longestPalindromeSubseq(self, s: str) -&amp;gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] !</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://foxisawesome.github.io/posts/5-longest-palindromic-substring/</link>
      <pubDate>Mon, 14 Sep 2020 10:05:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/5-longest-palindromic-substring/</guid>
      <description>LC 5 Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer. Solution 2020-09-14 Notes: 本质是dp，与LC 516相同 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: if not s: return &amp;quot;&amp;quot; n =</description>
    </item>
    
    <item>
      <title>937 Reorder Data in Log Files</title>
      <link>https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/</link>
      <pubDate>Mon, 14 Sep 2020 09:19:19 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/</guid>
      <description>LC 937 Reorder Data in Log Files You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs.</description>
    </item>
    
    <item>
      <title>53 Maximum Subarray</title>
      <link>https://foxisawesome.github.io/posts/53-maximum-subarray/</link>
      <pubDate>Sun, 13 Sep 2020 22:09:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/53-maximum-subarray/</guid>
      <description>LC 53 Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Solution 2020-11-03 Not</description>
    </item>
    
    <item>
      <title>262 Trips and Users</title>
      <link>https://foxisawesome.github.io/posts/262-trips-and-users/</link>
      <pubDate>Sun, 13 Sep 2020 21:46:46 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/262-trips-and-users/</guid>
      <description>LC 262 Trips and Users Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users. For the above tables, your</description>
    </item>
    
    <item>
      <title>185 Department Top Three Salaries</title>
      <link>https://foxisawesome.github.io/posts/185-department-top-three-salaries/</link>
      <pubDate>Sun, 13 Sep 2020 21:43:06 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/185-department-top-three-salaries/</guid>
      <description>LC 185 Department Top Three Salaries Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe |</description>
    </item>
    
    <item>
      <title>175 Combine Two Tables</title>
      <link>https://foxisawesome.github.io/posts/175-combine-two-tables/</link>
      <pubDate>Sun, 13 Sep 2020 21:28:29 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/175-combine-two-tables/</guid>
      <description>LC 175 Combine Two Tables Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State Solution 2020-09-13 Notes: Easy 小题考查left join SELECT firstname, lastname, city, state FROM person a LEFT JOIN address b ON a.personid = b.personid</description>
    </item>
    
    <item>
      <title>176 Second Highest Salary</title>
      <link>https://foxisawesome.github.io/posts/176-second-highest-salary/</link>
      <pubDate>Sun, 13 Sep 2020 21:24:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/176-second-highest-salary/</guid>
      <description>LC 176 Second Highest Salary Write a SQL query to get the second highest salary from the Employee table. Solution 2020-09-13 Notes: 这easy题有个小坑，要是table 不存在second highest，于是subquery就不会</description>
    </item>
    
    <item>
      <title>146 LRU Cache</title>
      <link>https://foxisawesome.github.io/posts/146-lru-cache/</link>
      <pubDate>Sun, 13 Sep 2020 21:16:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/146-lru-cache/</guid>
      <description>LC 146 LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should</description>
    </item>
    
  </channel>
</rss>
