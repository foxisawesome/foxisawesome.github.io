<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>backtracking on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/backtracking/</link>
    <description>Recent content in backtracking on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 20 Sep 2020 20:28:52 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/backtracking/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>134 Gas Station</title>
      <link>https://foxisawesome.github.io/posts/134-gas-station/</link>
      <pubDate>Wed, 23 Sep 2020 15:14:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/134-gas-station/</guid>
      <description>LC 134 Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station&amp;rsquo;s index if you</description>
    </item>
    
    <item>
      <title>103 Binary Tree Zigzag Level Order Traversal</title>
      <link>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Wed, 23 Sep 2020 14:58:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>LC 103 Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes&#39; values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution 2020-09-23 Notes: 一个</description>
    </item>
    
    <item>
      <title>1283 Find the Smallest Divisor Given a Threshold</title>
      <link>https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/</link>
      <pubDate>Wed, 23 Sep 2020 14:22:33 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/</guid>
      <description>LC 1283 Find the Smallest Divisor Given a Threshold a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor</description>
    </item>
    
    <item>
      <title>179 Largest Number</title>
      <link>https://foxisawesome.github.io/posts/179-largest-number/</link>
      <pubDate>Wed, 23 Sep 2020 11:12:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/179-largest-number/</guid>
      <description>LC 179 Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Input: [3,30,34,5,9] Output: &amp;quot;9534330&amp;quot; Solution 2020-09-23 Notes: 开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 &amp;amp; 54, 下一</description>
    </item>
    
    <item>
      <title>518 Coin Change 2</title>
      <link>https://foxisawesome.github.io/posts/518-coin-change-2/</link>
      <pubDate>Wed, 23 Sep 2020 10:32:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/518-coin-change-2/</guid>
      <description>LC 518 Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</description>
    </item>
    
    <item>
      <title>64 Minimum Path Sum</title>
      <link>https://foxisawesome.github.io/posts/64-minimum-path-sum/</link>
      <pubDate>Wed, 23 Sep 2020 09:56:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/64-minimum-path-sum/</guid>
      <description>LC 64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Input:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution 2020-09-23 Notes: 做这题时发现了好几个pyth</description>
    </item>
    
    <item>
      <title>802 Find Eventual Safe States</title>
      <link>https://foxisawesome.github.io/posts/802-find-eventual-safe-states/</link>
      <pubDate>Tue, 22 Sep 2020 13:01:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/802-find-eventual-safe-states/</guid>
      <description>LC 802 Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural</description>
    </item>
    
    <item>
      <title>1118 Number of Days in a Month</title>
      <link>https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/</link>
      <pubDate>Tue, 22 Sep 2020 12:12:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/</guid>
      <description>LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.
 Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -&amp;gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  </description>
    </item>
    
    <item>
      <title>210 Course Schedule II</title>
      <link>https://foxisawesome.github.io/posts/210-course-schedule-ii/</link>
      <pubDate>Tue, 22 Sep 2020 10:31:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/210-course-schedule-ii/</guid>
      <description>LC 210 Course Schedule II There are a total of n courses you have to take labelled from 0 to n - 1. Some courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai. Given the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to</description>
    </item>
    
    <item>
      <title>207 Course Schedule</title>
      <link>https://foxisawesome.github.io/posts/207-course-schedule/</link>
      <pubDate>Mon, 21 Sep 2020 22:16:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/207-course-schedule/</guid>
      <description>LC 207 Course Schedule There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Input: numCourses = 2,</description>
    </item>
    
    <item>
      <title>542 01 Matrix</title>
      <link>https://foxisawesome.github.io/posts/542-01-matrix/</link>
      <pubDate>Mon, 21 Sep 2020 21:01:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/542-01-matrix/</guid>
      <description>LC 542 01 Matrix Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. Input: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]] Solution 2020-09-21 Notes: 很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水</description>
    </item>
    
    <item>
      <title>200 Number of Islands</title>
      <link>https://foxisawesome.github.io/posts/200-number-of-islands/</link>
      <pubDate>Mon, 21 Sep 2020 20:29:23 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/200-number-of-islands/</guid>
      <description>LC 200 Number of Islands Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Input: grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] Output: 3 Solution 2020-09-21 Notes: 很经典的B</description>
    </item>
    
    <item>
      <title>133 Clone Graph</title>
      <link>https://foxisawesome.github.io/posts/133-clone-graph/</link>
      <pubDate>Mon, 21 Sep 2020 16:18:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/133-clone-graph/</guid>
      <description>LC 133 Clone Graph Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Solution 2020-09-21 Notes: 刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只</description>
    </item>
    
    <item>
      <title>1323 Maximum 69 Number</title>
      <link>https://foxisawesome.github.io/posts/1323-maximum-69-number/</link>
      <pubDate>Mon, 21 Sep 2020 15:51:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1323-maximum-69-number/</guid>
      <description>LC 1323 Maximum 69 Number Given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). Solution 2020-09-21 Notes: 开始时我想着转成str()后，用binary search出最</description>
    </item>
    
    <item>
      <title>47 Permutations II</title>
      <link>https://foxisawesome.github.io/posts/47-permutations-ii/</link>
      <pubDate>Mon, 21 Sep 2020 15:33:45 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/47-permutations-ii/</guid>
      <description>LC 47 Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Solution 2020-09-21 Notes: LC 46 的升级版。这题添加了nums里有duplicates的case。 为了保证输出时 distinct out 的条件，可以</description>
    </item>
    
    <item>
      <title>78 Subsets</title>
      <link>https://foxisawesome.github.io/posts/78-subsets/</link>
      <pubDate>Mon, 21 Sep 2020 14:49:34 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/78-subsets/</guid>
      <description>LC 78 Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Input: nums = [1,2,3] Output:[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]] Solution 2020-09-21 Notes: 简单的dfs题，有个新奇的点就是在dfs外面有个控制length的loop。刚开始我以为要</description>
    </item>
    
    <item>
      <title>77 Combinations</title>
      <link>https://foxisawesome.github.io/posts/77-combinations/</link>
      <pubDate>Mon, 21 Sep 2020 14:31:35 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/77-combinations/</guid>
      <description>LC 77 Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 &amp;hellip; n. Solution 2020-09-21 Notes: Dfs 模版搞一下。没啥特别的。 class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: out = [] nums = [i for i in range(1,n+1)] self.dfs(n,k,nums,[],out) return out def dfs(self, n, k, nums, path, out): if len(path)==k: out.append(path[:])</description>
    </item>
    
    <item>
      <title>40 Combination Sum Ii</title>
      <link>https://foxisawesome.github.io/posts/40-combination-sum-ii/</link>
      <pubDate>Mon, 21 Sep 2020 14:17:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/40-combination-sum-ii/</guid>
      <description>LC 40 Combination Sum Ii Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is:[[1, 7], [1, 2, 5], [2, 6],[1, 1, 6]] Solution 2020-09-21 Notes: 这题与39题</description>
    </item>
    
    <item>
      <title>39 Combination Sum</title>
      <link>https://foxisawesome.github.io/posts/39-combination-sum/</link>
      <pubDate>Mon, 21 Sep 2020 14:11:52 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/39-combination-sum/</guid>
      <description>LC 39 Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Input: candidates = [2,3,6,7], target = 7, A solution set is: [[7],[2,2,3]] Solution 2020-09-21 Notes: 简单的DFS题，注意：path要是list(),</description>
    </item>
    
    <item>
      <title>17 Letter Combinations of a Phone Number</title>
      <link>https://foxisawesome.github.io/posts/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Mon, 21 Sep 2020 14:04:33 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/17-letter-combinations-of-a-phone-number/</guid>
      <description>LC 17 Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Solution 2020-09-21 Notes: 很简单的一道backtracking题套模版就可以了。为了避免dups，每次传入r</description>
    </item>
    
  </channel>
</rss>
