<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>recursion on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/recursion/</link>
    <description>Recent content in recursion on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Oct 2020 15:49:03 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/recursion/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>27 Remove Element</title>
      <link>https://foxisawesome.github.io/posts/27-remove-element/</link>
      <pubDate>Wed, 23 Sep 2020 20:30:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/27-remove-element/</guid>
      <description>LC 27 Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length. Solution 2020-10-08 Notes: 三刷，用</description>
    </item>
    
    <item>
      <title>28 Implement Strstr</title>
      <link>https://foxisawesome.github.io/posts/28-implement-strstr/</link>
      <pubDate>Wed, 23 Sep 2020 20:08:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/28-implement-strstr/</guid>
      <description>LC 28 Implement Strstr Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2 Solution 2020-09-23 Notes: 官方解答里有中 $\mathcal{O}(N)$ 的解哦！ class Solution: def strStr(self, haystack: str, needle: str) -&amp;gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen]</description>
    </item>
    
    <item>
      <title>349 Intersection of Two Arrays</title>
      <link>https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/</link>
      <pubDate>Wed, 23 Sep 2020 20:03:57 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/</guid>
      <description>LC 349 Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Each element in the result must be unique. The result can be in any order. Solution 2020-09-23 Notes: 很多做法，set本身有intersection()的method。 class Solution: def</description>
    </item>
    
    <item>
      <title>350 Intersection of Two Arrays II</title>
      <link>https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Wed, 23 Sep 2020 19:54:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/</guid>
      <description>LC 350 Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Solution 2020-09-23 Notes: 简单题两种高效做法。 hashtable class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 &amp;gt; n1: return self.intersect(nums2, nums1)</description>
    </item>
    
    <item>
      <title>202 Happy Number</title>
      <link>https://foxisawesome.github.io/posts/202-happy-number/</link>
      <pubDate>Wed, 23 Sep 2020 19:33:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/202-happy-number/</guid>
      <description>LC 202 Happy Number Write an algorithm to determine if a number n is &amp;ldquo;happy&amp;rdquo;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers</description>
    </item>
    
    <item>
      <title>278 First Bad Version</title>
      <link>https://foxisawesome.github.io/posts/278-first-bad-version/</link>
      <pubDate>Wed, 23 Sep 2020 19:18:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/278-first-bad-version/</guid>
      <description>LC 278 First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,</description>
    </item>
    
    <item>
      <title>35 Search Insert Position</title>
      <link>https://foxisawesome.github.io/posts/35-search-insert-position/</link>
      <pubDate>Wed, 23 Sep 2020 19:09:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/35-search-insert-position/</guid>
      <description>LC 35 Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Solution 2020-09-23 Notes: 标准的left bound 的binary search 写法。 初秋的夜晚很舒服。 class Solution: def</description>
    </item>
    
    <item>
      <title>134 Gas Station</title>
      <link>https://foxisawesome.github.io/posts/134-gas-station/</link>
      <pubDate>Wed, 23 Sep 2020 15:14:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/134-gas-station/</guid>
      <description>LC 134 Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station&amp;rsquo;s index if you</description>
    </item>
    
    <item>
      <title>103 Binary Tree Zigzag Level Order Traversal</title>
      <link>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Wed, 23 Sep 2020 14:58:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>LC 103 Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution 2020-09-23 Notes: 一个</description>
    </item>
    
    <item>
      <title>1283 Find the Smallest Divisor Given a Threshold</title>
      <link>https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/</link>
      <pubDate>Wed, 23 Sep 2020 14:22:33 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/</guid>
      <description>LC 1283 Find the Smallest Divisor Given a Threshold a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor</description>
    </item>
    
    <item>
      <title>179 Largest Number</title>
      <link>https://foxisawesome.github.io/posts/179-largest-number/</link>
      <pubDate>Wed, 23 Sep 2020 11:12:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/179-largest-number/</guid>
      <description>LC 179 Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Input: [3,30,34,5,9] Output: &amp;quot;9534330&amp;quot; Solution 2020-09-23 Notes: 开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 &amp;amp; 54, 下一</description>
    </item>
    
    <item>
      <title>518 Coin Change 2</title>
      <link>https://foxisawesome.github.io/posts/518-coin-change-2/</link>
      <pubDate>Wed, 23 Sep 2020 10:32:12 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/518-coin-change-2/</guid>
      <description>LC 518 Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</description>
    </item>
    
    <item>
      <title>64 Minimum Path Sum</title>
      <link>https://foxisawesome.github.io/posts/64-minimum-path-sum/</link>
      <pubDate>Wed, 23 Sep 2020 09:56:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/64-minimum-path-sum/</guid>
      <description>LC 64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Input:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution 2020-09-23 Notes: 做这题时发现了好几个pyth</description>
    </item>
    
    <item>
      <title>802 Find Eventual Safe States</title>
      <link>https://foxisawesome.github.io/posts/802-find-eventual-safe-states/</link>
      <pubDate>Tue, 22 Sep 2020 13:01:55 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/802-find-eventual-safe-states/</guid>
      <description>LC 802 Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural</description>
    </item>
    
    <item>
      <title>1118 Number of Days in a Month</title>
      <link>https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/</link>
      <pubDate>Tue, 22 Sep 2020 12:12:50 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/</guid>
      <description>LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.
 Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -&amp;gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  </description>
    </item>
    
    <item>
      <title>210 Course Schedule II</title>
      <link>https://foxisawesome.github.io/posts/210-course-schedule-ii/</link>
      <pubDate>Tue, 22 Sep 2020 10:31:47 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/210-course-schedule-ii/</guid>
      <description>LC 210 Course Schedule II There are a total of n courses you have to take labelled from 0 to n - 1. Some courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai. Given the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to</description>
    </item>
    
    <item>
      <title>207 Course Schedule</title>
      <link>https://foxisawesome.github.io/posts/207-course-schedule/</link>
      <pubDate>Mon, 21 Sep 2020 22:16:02 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/207-course-schedule/</guid>
      <description>LC 207 Course Schedule There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Input: numCourses = 2,</description>
    </item>
    
    <item>
      <title>542 01 Matrix</title>
      <link>https://foxisawesome.github.io/posts/542-01-matrix/</link>
      <pubDate>Mon, 21 Sep 2020 21:01:17 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/542-01-matrix/</guid>
      <description>LC 542 01 Matrix Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. Input: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]] Solution 2020-09-21 Notes: 很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水</description>
    </item>
    
    <item>
      <title>200 Number of Islands</title>
      <link>https://foxisawesome.github.io/posts/200-number-of-islands/</link>
      <pubDate>Mon, 21 Sep 2020 20:29:23 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/200-number-of-islands/</guid>
      <description>LC 200 Number of Islands Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Input: grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] Output: 3 Solution 2020-09-21 Notes: 很经典的B</description>
    </item>
    
    <item>
      <title>133 Clone Graph</title>
      <link>https://foxisawesome.github.io/posts/133-clone-graph/</link>
      <pubDate>Mon, 21 Sep 2020 16:18:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/133-clone-graph/</guid>
      <description>LC 133 Clone Graph Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Solution 2020-09-21 Notes: 刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只</description>
    </item>
    
  </channel>
</rss>
