<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>stack on Q. Weng</title>
    <link>https://foxisawesome.github.io/tags/stack/</link>
    <description>Recent content in stack on Q. Weng</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 01 Oct 2020 14:11:32 -0400</lastBuildDate>
    
        <atom:link href="https://foxisawesome.github.io/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>180 Consecutive Numbers</title>
      <link>https://foxisawesome.github.io/sql/180-consecutive-numbers/</link>
      <pubDate>Thu, 24 Sep 2020 21:41:16 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/180-consecutive-numbers/</guid>
      <description>LC 180 Consecutive Numbers Write a SQL query to find all numbers that appear at least three times consecutively. Solution 2020-09-24 Notes: self join 的写法 SELECT DISTINCT a.num AS ConsecutiveNums FROM logs a JOIN logs b ON a.id+1 = b.id AND a.num=b.num JOIN logs c ON a.id+2 = c.id AND a.num=c.num LEAD() function 的写法： SELECT DISTINCT num AS consecutiveNums FROM ( SELECT id, num, LEAD(num,1)</description>
    </item>
    
    <item>
      <title>177 Nth Highest Salary</title>
      <link>https://foxisawesome.github.io/sql/177-nth-highest-salary/</link>
      <pubDate>Thu, 24 Sep 2020 21:16:18 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/177-nth-highest-salary/</guid>
      <description>LC 177 Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. Solution 2020-09-24 Notes: 这个sql function 的写法得背下来。不过也没什么难的。 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE m int; SET m = n-1; RETURN ( SELECT salary FROM employee GROUP BY 1 ORDER by</description>
    </item>
    
    <item>
      <title>875 Koko Eating Bananas</title>
      <link>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</link>
      <pubDate>Thu, 24 Sep 2020 13:51:49 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/875-koko-eating-bananas/</guid>
      <description>LC 875 Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them</description>
    </item>
    
    <item>
      <title>774 Minimize Max Distance to Gas Station</title>
      <link>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</link>
      <pubDate>Thu, 24 Sep 2020 13:49:22 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/</guid>
      <description>LC 774 Minimize Max Distance to Gas Station On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D. Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000</description>
    </item>
    
    <item>
      <title>410 Split Array Largest Sum</title>
      <link>https://foxisawesome.github.io/posts/410-split-array-largest-sum/</link>
      <pubDate>Thu, 24 Sep 2020 13:48:35 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/410-split-array-largest-sum/</guid>
      <description>LC 410 Split Array Largest Sum Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5]</description>
    </item>
    
    <item>
      <title>1011 Capacity to Ship Packages Within D Days</title>
      <link>https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/</link>
      <pubDate>Thu, 24 Sep 2020 13:46:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/</guid>
      <description>LC 1011 Capacity to Ship Packages Within D Days conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Thu, 24 Sep 2020 13:18:43 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/</guid>
      <description>LC 21 Merge Two Sorted Lists Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Solution 2020-09-24 Notes: 不要create 新的 ListNode along the way, making algo much faster. # Definition for singly-linked list. # class ListNode: #</description>
    </item>
    
    <item>
      <title>14 Longest Common Prefix</title>
      <link>https://foxisawesome.github.io/posts/14-longest-common-prefix/</link>
      <pubDate>Thu, 24 Sep 2020 13:13:11 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/14-longest-common-prefix/</guid>
      <description>LC 14 Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;quot;&amp;quot;. Input: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Solution 2020-09-24 Notes: 第三刷了，当年做的很痛苦的一道题。其实很简单。 class Solution: def longestCommonPrefix(self, strs: List[str]) -&amp;gt; str: if</description>
    </item>
    
    <item>
      <title>38 Count and Say</title>
      <link>https://foxisawesome.github.io/posts/38-count-and-say/</link>
      <pubDate>Thu, 24 Sep 2020 12:56:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/38-count-and-say/</guid>
      <description>LC 38 Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 Solution 2020-09-24 Notes: algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有</description>
    </item>
    
    <item>
      <title>1070 Product Sales Analysis III</title>
      <link>https://foxisawesome.github.io/sql/1070-product-sales-analysis-iii/</link>
      <pubDate>Wed, 23 Sep 2020 21:32:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/sql/1070-product-sales-analysis-iii/</guid>
      <description>LC 1070 Product Sales Analysis III Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold. Solution 2020-09-23 Notes: 这题的test case 1有问题，论坛里有类似讨论。 SELECT product_id, year AS first_year, quantity, price FROM ( SELECT product_id, year, quantity, price, ROW_NUMBER() OVER(PARTITION BY product_id</description>
    </item>
    
    <item>
      <title>1231 Divide Chocolate</title>
      <link>https://foxisawesome.github.io/posts/1231-divide-chocolate/</link>
      <pubDate>Wed, 23 Sep 2020 21:15:59 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/1231-divide-chocolate/</guid>
      <description>LC 1231 Divide Chocolate You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness. You want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks. Being generous, you will eat the piece with the minimum total sweetness and give the</description>
    </item>
    
    <item>
      <title>27 Remove Element</title>
      <link>https://foxisawesome.github.io/posts/27-remove-element/</link>
      <pubDate>Wed, 23 Sep 2020 20:30:03 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/27-remove-element/</guid>
      <description>LC 27 Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length. Solution 2020-10-08 Notes: 三刷，用</description>
    </item>
    
    <item>
      <title>28 Implement Strstr</title>
      <link>https://foxisawesome.github.io/posts/28-implement-strstr/</link>
      <pubDate>Wed, 23 Sep 2020 20:08:40 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/28-implement-strstr/</guid>
      <description>LC 28 Implement Strstr Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2 Solution 2020-09-23 Notes: 官方解答里有中 $\mathcal{O}(N)$ 的解哦！ class Solution: def strStr(self, haystack: str, needle: str) -&amp;gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen]</description>
    </item>
    
    <item>
      <title>349 Intersection of Two Arrays</title>
      <link>https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/</link>
      <pubDate>Wed, 23 Sep 2020 20:03:57 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/</guid>
      <description>LC 349 Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Each element in the result must be unique. The result can be in any order. Solution 2020-09-23 Notes: 很多做法，set本身有intersection()的method。 class Solution: def</description>
    </item>
    
    <item>
      <title>350 Intersection of Two Arrays II</title>
      <link>https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Wed, 23 Sep 2020 19:54:21 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/</guid>
      <description>LC 350 Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Solution 2020-09-23 Notes: 简单题两种高效做法。 hashtable class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 &amp;gt; n1: return self.intersect(nums2, nums1)</description>
    </item>
    
    <item>
      <title>202 Happy Number</title>
      <link>https://foxisawesome.github.io/posts/202-happy-number/</link>
      <pubDate>Wed, 23 Sep 2020 19:33:27 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/202-happy-number/</guid>
      <description>LC 202 Happy Number Write an algorithm to determine if a number n is &amp;ldquo;happy&amp;rdquo;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers</description>
    </item>
    
    <item>
      <title>278 First Bad Version</title>
      <link>https://foxisawesome.github.io/posts/278-first-bad-version/</link>
      <pubDate>Wed, 23 Sep 2020 19:18:01 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/278-first-bad-version/</guid>
      <description>LC 278 First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,</description>
    </item>
    
    <item>
      <title>35 Search Insert Position</title>
      <link>https://foxisawesome.github.io/posts/35-search-insert-position/</link>
      <pubDate>Wed, 23 Sep 2020 19:09:26 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/35-search-insert-position/</guid>
      <description>LC 35 Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Solution 2020-09-23 Notes: 标准的left bound 的binary search 写法。 初秋的夜晚很舒服。 class Solution: def</description>
    </item>
    
    <item>
      <title>134 Gas Station</title>
      <link>https://foxisawesome.github.io/posts/134-gas-station/</link>
      <pubDate>Wed, 23 Sep 2020 15:14:28 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/134-gas-station/</guid>
      <description>LC 134 Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station&amp;rsquo;s index if you</description>
    </item>
    
    <item>
      <title>103 Binary Tree Zigzag Level Order Traversal</title>
      <link>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Wed, 23 Sep 2020 14:58:07 -0400</pubDate>
      
      <guid>https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>LC 103 Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution 2020-09-23 Notes: 一个</description>
    </item>
    
  </channel>
</rss>
