{"categories":[{"title":"algo","uri":"https://foxisawesome.github.io/categories/algo/"},{"title":"ml","uri":"https://foxisawesome.github.io/categories/ml/"},{"title":"sql","uri":"https://foxisawesome.github.io/categories/sql/"}],"posts":[{"content":"LC 312 Burst Balloons   Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nInput: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --\u0026gt; [3,5,8] --\u0026gt; [3,8] --\u0026gt; [8] --\u0026gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167   Solution 2020-09-10 Notes:\n幼稚的一刷，能解对但是ETL. 用了memo：\n [1] +nums+[1] 小trick可以简化边界条件。 track 区间的index应该能优化不少。  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() return self.dfs(nums) def dfs(self, nums): if not nums: return 0 if str(nums) in self.memo: return self.memo[str(nums)] temp = [] nums = [1] + nums + [1] n = len(nums) for i in range(1,n-1): new_nums = nums[1:i]+nums[i+1:n-1] temp.append(nums[i]*nums[i-1]*nums[i+1] + self.dfs(new_nums)) self.memo[str(nums)] = max(temp) return self.memo[str(nums)] # Time O(N!) ?? # Space O()  看了答案，优化了一下：\n最关键的公式是：nums[i-1]*nums[k]*nums[j+1]: 含义如下\n  Dfs(i,j) return 的是刺破[i,j]区间上所有气球后得到的最大值，前提时所有气球都破了。\n  在[i,j]区间上，假设 [i,k-1], 和 [k+1,j] 已经被最优刺破，那么剩下的最后一个k-th 气球被刺破时，值就为nums[i-1]*nums[k]*nums[j+1]。是top-down的recursion。\n  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() nums = [1] + nums + [1] return self.dfs(nums,1,len(nums)-2) def dfs(self, nums, i, j): if not nums: return 0 if (i,j) in self.memo: return self.memo[(i,j)] ans = 0 for k in range(i,j+1): ans = max(ans, self.dfs(nums,i,k-1) + nums[i-1]*nums[k]*nums[j+1] + self.dfs(nums,k+1,j)) self.memo[(i,j)] = ans return self.memo[(i,j)] # Time O(N^3) # Space O(N^2)  ","id":0,"section":"posts","summary":"LC 312 Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum","tags":["leetcode","dp","recursion"],"title":"312 Burst Balloons","uri":"https://foxisawesome.github.io/312-burst-balloons/","year":"2020"},{"content":"LC 110 Balanced Binary Tree   Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\n a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n Given the following tree [3,9,20,null,null,15,7]:Return true.\n 3 / \\ 9 20 / \\ 15 7  Given the following tree [1,2,2,3,3,null,null,4,4]:Return false.\n 1 / \\ 2 2 / \\ 3 3 / \\ 4 4   Solution 2020-09-10 Notes:\n Time complexity is O(NlogN), 这个花花讲了原因不是很懂 其实isBalance()输出的时 需要判断left child and right child if existed.否则左右是两条单链的情况不能过。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True l = self.treeHeight(root.left) r = self.treeHeight(root.right) return (abs(l-r) \u0026lt; 2) and self.isBalanced(root.left) and self.isBalanced(root.right) def treeHeight(self,root): if not root: return 0 l = self.treeHeight(root.left) r = self.treeHeight(root.right) return max(l,r) + 1 # Time O(NlogN) # Space O(H)  ","id":1,"section":"posts","summary":"LC 110 Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Given the following tree [3,9,20,null,null,15,7]:Return true. 3 / \\ 9 20 / \\ 15 7 Given the following tree [1,2,2,3,3,null,null,4,4]:Return false. 1 / \\ 2","tags":["leetcode","tree"],"title":"110 Balanced Binary Tree","uri":"https://foxisawesome.github.io/110-balanced-binary-tree/","year":"2020"},{"content":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.   Solution 2020-09-10 Notes:\n Pretty similar to symetric tree. need to judge flipping or not flipping cases  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: TreeNode, root2: TreeNode) -\u0026gt; bool: if not root1 and not root2: return True if not root1 or not root2: return False # flipping l1 = self.flipEquiv(root1.left, root2.right) r1 = self.flipEquiv(root1.right, root2.left) # not flipping l2 = self.flipEquiv(root1.left, root2.left) r2 = self.flipEquiv(root1.right, root2.right) return root1.val == root2.val and ((l1 and r1) or (l2 and r2)) # Time O(N) # Space O(logN)  ","id":2,"section":"posts","summary":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.","tags":["leetcode","tree"],"title":"951 Flip Equivalent Binary Trees","uri":"https://foxisawesome.github.io/951-flip-equivalent-binary-trees/","year":"2020"},{"content":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case. need to create a mirror() with two arguments.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSymmetric_recur(self, root: TreeNode) -\u0026gt; bool: if not root: return True return self.mirror(root.left, root.right) def mirror(self, r1, r2): if not r1 and not r2: return True if not r1 or not r2: return False outer = self.mirror(r1.left, r2.right) inner = self.mirror(r1.right, r2.left) return r1.val==r2.val and outer and inner def isSymmetric_iter(self, root: TreeNode) -\u0026gt; bool: if not root: return True stack = [] stack.append((root.left, root.right)) while stack: l, r = stack.pop() if not l and not r: continue if not l or not r or l.val != r.val: return False stack.append((l.left, r.right)) stack.append((l.right,r.left)) return True # Time O(N) # Space O(logN)  ","id":3,"section":"posts","summary":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case.","tags":["leetcode","tree"],"title":"101 Symmetric Tree","uri":"https://foxisawesome.github.io/101-symmetric-tree/","year":"2020"},{"content":"LC 100 Same Tree   Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\n Solution 2020-09-09 Notes:\n Two roots 的pattern 和 single root一样。Tree 刷的略有感觉了！  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: if not p and not q: return True if not p or not q: return False l = self.isSameTree(p.left, q.left) r = self.isSameTree(p.right, q.right) return p.val == q.val and l and r # Time O(N) # Space O(logN)  ","id":4,"section":"posts","summary":"LC 100 Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Solution 2020-09-09 Notes: Two roots 的pattern 和 single root一样。Tree 刷的略有感","tags":["leetcode","tree"],"title":"100 Same Tree","uri":"https://foxisawesome.github.io/100-same-tree/","year":"2020"},{"content":"LC 112 Path Sum   Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1  return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\n Solution 2020-09-09 Notes:\n recursion 可以把pathSm()合并到主函数，因为input，output都一致。但我还是刷出来了！😊。 每一层传入的是 target-root.val, 穿出的是left bool or right bool 领悟是if not root: return None (or False in this case)是default，肯定要的。 iteration的做法在第二部分。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum_recur(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False return self.pathSum(root, sum) def pathSum(self, root, target): if not root: return if not root.left and not root.right: return root.val == target l = self.pathSum(root.left, target - root.val) r = self.pathSum(root.right, target - root.val) return l or r # Time O(N) # Space O(logN) def hasPathSum_iter(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False stack = [(root, root.val)] while stack: node, path = stack.pop() if not node.left and not node.right and path == sum: return True if node.left: stack.append((node.left, path + node.left.val)) if node.right: stack.append((node.right, path + node.right.val)) return False # Time O(N) # Space O(N)  ","id":5,"section":"posts","summary":"LC 112 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum","tags":["leetcode","tree"],"title":"112 Path Sum","uri":"https://foxisawesome.github.io/112-path-sum/","year":"2020"},{"content":"LC 104 Maximum Depth of Binary Tree   Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-09-09 Notes:\n 注意patterns. Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.maxDepth(root.left) r = self.maxDepth(root.right) return max(l,r)+1 # Time O(N) # Space: best scenario O(H)=O(logN)  ","id":6,"section":"posts","summary":"LC 104 Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 Solution 2020-09-09 Notes: 注意patterns. Beat the TREE! # Definition for","tags":["leetcode","tree"],"title":"104 Maximum Depth of Binary Tree","uri":"https://foxisawesome.github.io/104-maximum-depth-of-binary-tree/","year":"2020"},{"content":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.minDepth(root.left) r = self.minDepth(root.right) if not l and r: return r+1 if not r and l: return l+1 return min(l,r)+1 # Time O(N) # Space O(logN)  ","id":7,"section":"posts","summary":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node.","tags":["leetcode","tree"],"title":"111 Minimum Depth of Binary Tree","uri":"https://foxisawesome.github.io/111-minimum-depth-of-binary-tree/","year":"2020"},{"content":"LC 124 Binary Tree Maximum Path Sum   Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nInput: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42   Solution 2020-09-09 Notes:\n 因为要online update ans，所以得要个helper()。helper() 返回的是 maxPathSum。 line #23: 是因为每条sub-path只能取左child或者右child中的较大path。   类似题: LC 543  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: TreeNode) -\u0026gt; int: self.ans = -float('inf') self.helperMax(root) return self.ans def helperMax(self, root): if not root: return 0 left = self.helperMax(root.left) right = self.helperMax(root.right) left = left if left \u0026gt; 0 else 0 right = right if right \u0026gt; 0 else 0 self.ans = max(self.ans, left+right+root.val) return root.val + max(left, right) # Time O(N) # Space O(H)  ","id":8,"section":"posts","summary":"LC 124 Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15","tags":["leetcode","tree"],"title":"124 Binary Tree Maximum Path Sum","uri":"https://foxisawesome.github.io/124-binary-tree-maximum-path-sum/","year":"2020"},{"content":"LC 987 Vertical Order Traversal of a Binary Tree    Solution 2020-09-09T13:59:40-04:00 Notes:\n   # Time O() # Space O()  ","id":9,"section":"posts","summary":"LC 987 Vertical Order Traversal of a Binary Tree    Solution 2020-09-09T13:59:40-04:00 Notes:\n   # Time O() # Space O()  ","tags":["leetcode"],"title":"987 Vertical Order Traversal of a Binary Tree","uri":"https://foxisawesome.github.io/987-vertical-order-traversal-of-a-binary-tree/","year":"2020"},{"content":"LC 236 Lowest Common Ancestor of a Binary Tree   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n Solution 2020-09-09 Notes:\n 递归灵魂三问 (reference: labuladong)：  递归函数return的是什么？ 递归函数的arguments？ 如何利用递归函数的返回值？   part 1: 最底层返回条件，root== p 或 q时， 返回root。 这题底层就两种情况，啥也没找到 Null，找到p, q，就不再开新的recursion， 直接返回p, q。 part 2: 固定的binary tree recursion模版 part 3: 此处是post-order, 返回值的利用，就三种情况：a. p, q 同时都在root里, 那么root就是LCA, 把这个LCA一层层返回上去。 b. p,q 都不在root里, 返回None。c. p,q 其一在root里，那个层层返回p 或 q 的这两个单独节点，直到他们相遇的root才是LCA。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u0026gt; 'TreeNode': # part 1 if root is None: return None if root == p or root == q: return root # part 2 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # part 3 if left and right: return root if not left and not right: return None return left if left else right # Time O(N) # Space O(?)  ","id":10,"section":"posts","summary":"LC 236 Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be","tags":["leetcode","tree"],"title":"236 Lowest Common Ancestor of a Binary Tree","uri":"https://foxisawesome.github.io/236-lowest-common-ancestor-of-a-binary-tree/","year":"2020"},{"content":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:\n O(N) is easy.  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: l = 0 out = '' for i in s: while l \u0026lt; len(t): if t[l]==i: out += t[l] l +=1 break l += 1 return out == s # Time O(M), M:len(t) # Space O(1)   the follow-up of this questions: while s\u0026raquo;t, O(N) is not satisfied. here is O(MlogN) solution using binary search is pretty hard to think of:  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: d = dict() for i, val in enumerate(t): if val not in d: d[val] = [i] else: d[val].append(i) tar = 0 for i, val in enumerate(s): if val not in d: return False pos = self.leftBound(d[val],tar) if pos == len(d[val]): return False tar = d[val][pos] + 1 return True def leftBound(self, idx_ls, p): l, r = 0, len(idx_ls) while l \u0026lt; r: m = l + (r-l)//2 if idx_ls[m] \u0026lt; p: l = m + 1 elif idx_ls[m] \u0026gt;= p: r = m return l # Time O(MlogN), N:len(s), M:len(t) # Space O(M)  ","id":11,"section":"posts","summary":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:","tags":["leetcode","binarysearch"],"title":"392 Is Subsequence","uri":"https://foxisawesome.github.io/392-is-subsequence/","year":"2020"},{"content":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","id":12,"section":"posts","summary":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"268 Missing Number","uri":"https://foxisawesome.github.io/268-missing-number/","year":"2020"},{"content":"LC 645 Set Mismatch   The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n Solution 2020-09-08 Notes:\n 可以直接算出来， sum(1-n) - sum(set(nums)) 也可以用hash table的思想构造 count dict 来做， one-pass。要真用dict() 得two-pass了。还得pass一边dictionary。  class Solution: def findErrorNums(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) h = [0]*n for i in range(n): h[nums[i]-1] += 1 return [h.index(2)+1, h.index(0)+1] # Time O(N) # Space O(N)  ","id":13,"section":"posts","summary":"LC 645 Set Mismatch The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number","tags":["leetcode","hashtable"],"title":"645 Set Mismatch","uri":"https://foxisawesome.github.io/645-set-mismatch/","year":"2020"},{"content":"LC 234 Palindrome Linked List   Given a singly linked list, determine if it is a palindrome.\n Solution 2020-09-08 Notes:\n  Recursion solution参考了 labuladong\n  以下是一种比较直观但是不是optimal的解法\n  line 13 is a post-order traverse.\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: ListNode) -\u0026gt; bool: self.left = head return self.traverse(head) def traverse(self, right): if not right: return True res = self.traverse(right.next) res = res and right.val ==self.left.val self.left = self.left.next return res # Time O(N) # Space O(?)  ","id":14,"section":"posts","summary":"LC 234 Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Solution 2020-09-08 Notes: Recursion solution参考了 labuladong 以下是一种比较直观但是不是optimal的解法 line 13 is a post-order traverse. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"234 Palindrome Linked List","uri":"https://foxisawesome.github.io/234-palindrome-linked-list/","year":"2020"},{"content":"Summary:\n  it minimizes “within” cluster distance or equivalently maximizes “in between” cluster distance/variance.\n  K-means algorithm is closely ralated to E-M algorithm\nE-M (Expectation-Maximization) algorithm is a “soft” version of K-means\n  Algorithm intuition (see example implemented in numpy below ):\n  Pre-set $K$: use elbow plot: loss vs $K$ to determine K or use automatic: gap statistics method to determine $K$.\n  Randomly assign initial cluster centroid $k$. To make algorithm more efficient, set centroid “far away”.\n  while not converge, iterative descent algorithm\na. given cluster C, minimize cost function to find centroid of cluster\nb. given centroid, minimize cost function to find cluster $k$\n    E-M algorithm:\n  set $K=2$: “2 component Gaussian Mixture”, GMM\n  while not converge:\n​\ta. compute probability given fixing Gaussian pdf\n​\tb. based on Prob. calculate Gaussian distribution parameters\n    K-means / E-M is a non-convex optimization problem. it has local optima issue. initialization is important. to avoid this issue, one can run M times, choose the one has the min cost function/MSE.\n  cons: K-means is limited to linear cluster boundaries.\n  cons: slow for large # of samples.\n  import numpy as np from matplotlib import pyplot as plt def data_generator(): class_1_data = np.random.randn(100,2) + np.array([1,2]) class_2_data = np.random.randn(100,2) + np.array([-5,9]) class_3_data = np.random.randn(100,2) + np.array([8,2]) return np.concatenate([class_1_data, class_2_data, class_3_data], axis=0) def K_means(data, K, lr=0.2): D = data.shape[1] N = data.shape[0] category = np.zeros(N) centroid = np.random.randn(K, D) centroid_copy = centroid.copy() finished = False while not finished: # step 1: update data point's category for j in range(N): nearest_centroid = None nearest_centroid_dist = float('inf') for k in range(K): dist_j_k = np.linalg.norm(centroid[k] - data[j]) if dist_j_k \u0026lt; nearest_centroid_dist: nearest_centroid_dist = dist_j_k nearest_centroid = k category[j] = nearest_centroid # step 2: recalc centroid for j in range(K): new_centroid = np.mean(data[category == j], axis = 0) centroid[j] = new_centroid*lr + centroid[j]*(1-lr) # visualization print(centroid) plt.scatter(x=data[:,0], y=data[:,1], c=category) plt.plot(list(centroid[:,0]), list(centroid[:,1]), 'ro') plt.show() # step 3: iterate 1 and 2 # convergence check cg_rt = np.linalg.norm(np.linalg.norm(centroid - centroid_copy, axis = 0).reshape(-1)) centroid_copy = centroid.copy() if cg_rt \u0026lt; 0.01: finished = True  # data generator: data = data_generator() plt.scatter(data[:,0], data[:,1]) plt.show() # apply K-means K_means(data, 3)  ","id":15,"section":"posts","summary":"Summary:\n  it minimizes “within” cluster distance or equivalently maximizes “in between” cluster distance/variance.\n  K-means algorithm is closely ralated to E-M algorithm\nE-M (Expectation-Maximization) algorithm is a “soft” version of K-means\n  Algorithm intuition (see example implemented in numpy below ):\n  Pre-set $K$: use elbow plot: loss vs $K$ to determine K or use automatic: gap statistics method to determine $K$.\n  Randomly assign initial cluster centroid $k$.","tags":["kmeans"],"title":"ML Kmeans Algo Sample","uri":"https://foxisawesome.github.io/ml-kmeans/","year":"2020"},{"content":"LC 325 Maximum Size Subarray Sum Equals K   Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead.\nInput: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.   Solution 2020-09-08 Notes:\n 此题解法跟 LC560 一摸一样。用cumulative + hash table 的one-pass O(N). 因为hash table需要用来存nums的index dict()的value 需要是list  class Solution: def maxSubArrayLen(self, nums: List[int], k: int) -\u0026gt; int: if not nums: return 0 d = collections.defaultdict(list) cum_sum = 0 d[0].append(0) n = len(nums) ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans = max(ans, i-min(d[target_sum])+1) d[cum_sum].append(i+1) return ans # Time O(N) # Space O(N)  ","id":16,"section":"posts","summary":"LC 325 Maximum Size Subarray Sum Equals K Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead. Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Solution 2020-09-08 Notes: 此题解法跟","tags":["leetcode","array","hashtable"],"title":"325 Maximum Size Subarray Sum Equals K","uri":"https://foxisawesome.github.io/325-maximum-size-subarray-sum-equals-k/","year":"2020"},{"content":"LC 560 Subarray Sum Equals K   Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\nInput:nums = [1,1,1], k = 2 Output: 2   Solution 2020-09-08 Notes:\n  看了labuladong 的总结\n  预先算一个cumulative sum 的dictionary，只要 cum_sum - k in d 那么 ans 就叠加次数。\n  需要dict记录frequency, (nums可能有0)。\n  FB 热门题\n  class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: d = dict() n = len(nums) cum_sum = 0 d[cum_sum] = 1 ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans += d[target_sum] d[cum_sum] = d.get(cum_sum,0) + 1 return ans # Time O(N) # Space O(1)  ","id":17,"section":"posts","summary":"LC 560 Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Input:nums = [1,1,1], k = 2 Output: 2 Solution 2020-09-08 Notes: 看了labuladong 的总结 预先算一个cumulativ","tags":["leetcode","array","hashtable"],"title":"560 Subarray Sum Equals K","uri":"https://foxisawesome.github.io/560-subarray-sum-equals-k/","year":"2020"},{"content":"LC 1109 Corporate Flight Bookings   There are n flights, and they are labeled from 1 to n.\nWe have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive.\nReturn an array answer of length n, representing the number of seats booked on each flight in order of their label.\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25]   Solution 2020-09-08 Notes:\n 题目很绕口，核心是起点和终点之间的所有节点都会 carry over seats number。 用 labuladong的差分数列的算法只要 one-pass of booking array O(N). :  首先构造 diff_arr[i] = nums[i] - nums[i-1], where diff_arr[0] = nums[0] 这个操作 diff_arr[i] += val and diff_arr[j+1] -= val 就可以操作 nums[i], ..., nums[j] all +val. With corner case, if j+1 \u0026lt; len(nums):diff_arr[j+1] -= val  回复nums: nums[i] = diff_arr[i] + nums[i-1] 如此只要 one-pass 操作区间的节点就可以对整个数列进行多次计算，直接返回要求值。   类似的技术还有先计算 cumulative sum of nums 再操作，FB有很多热门题这么做。  class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u0026gt; List[int]: diff_arr = [0] * n # diff[i] = arr[i]- arrr[i-1] ans = [0] * n for book in bookings: i = book[0]-1 j = book[1]-1 seat = book[2] diff_arr[i] += seat if j+1 \u0026lt; n: diff_arr[j+1] -= seat ans[0] = diff_arr[0] for i in range(1,n): ans[i] = diff_arr[i] + ans[i-1] return ans # Time O(N) # Space O(N)  ","id":18,"section":"posts","summary":"LC 1109 Corporate Flight Bookings There are n flights, and they are labeled from 1 to n. We have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label. Input: bookings = [[1,2,10],[2,3,20],[2,5,25]],","tags":["leetcode","array"],"title":"1109 Corporate Flight Bookings","uri":"https://foxisawesome.github.io/1109-corporate-flight-bookings/","year":"2020"},{"content":"LC 1539 Kth Missing Positive Number   Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nInput: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.   Solution 2020-09-07 Notes:\n O(N) solution is pretty easy, but not optimal. the binary solution is optimal.  arr[i]-(i+1): 返回的是 arr[i]和i+1 之间miss了几个数，如果arr没miss数，返回的因该是0. 所以这个条件和k比较可以快速找到最接近的位置。 我疏忽的是：这题是求k-th missing value 的起始左边界，以下是搜索左边界的标准做法。 Binary search而不是找 exact的 target (需要保证存在唯一解，才能用)，是搜索target的左边界，所以在binary search时单独例举 arr[i]-(i+1)==k 跳出会报错。应该合并 \u0026gt;=两种情况这种写法才对。 另外这题是 1-indexed，所以会有 i+1, l+k 这种小细节要搞清。    class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr) while l\u0026lt;r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m return l+k # 2nd way of writing this left boundary search. same results. def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr)-1 while l\u0026lt;=r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m - 1 return l+k # Time O(logN) # Space O(1)  class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: stack = [] if arr[-1] - len(arr) \u0026lt; k: return arr[-1]+(k-arr[-1]+len(arr)) elif arr[-1] - len(arr) \u0026gt;= k: stack = [i for i in range(1, arr[-1]+1)] [stack.remove(i) for i in arr] return stack[k-1] # Time O(N) # Space O(N)  ","id":19,"section":"posts","summary":"LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary","tags":["leetcode","binarySearch"],"title":"1539 Kth Missing Positive Number","uri":"https://foxisawesome.github.io/1539-kth-missing-positive-number/","year":"2020"},{"content":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","id":20,"section":"posts","summary":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","tags":["leetcode","hashtable"],"title":"1512 Number of Good Pairs","uri":"https://foxisawesome.github.io/1512-number-of-good-pairs/","year":"2020"},{"content":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case. need to take int(a/b) I was scared what if the division tests on a infinite unreapted, then toasted. However, the test cases have none. convet all calc to postive nums once determined. Loop through mod and record each mod’s index place.  class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -\u0026gt; str: if denominator == 0: return '' ans = '-' if numerator * denominator \u0026lt; 0 else '' numerator, denominator = abs(numerator), abs(denominator) d = dict() div, mod = self.myDivmod(numerator, denominator) if mod == 0: ans += str(div) return ans ans += str(div) + '.' d[mod] = len(ans) while mod: div, mod = self.myDivmod(mod*10, denominator) ans += str(div) if mod in d: idx = d[mod] ans = ans[:idx] + '(' + ans[idx:] + ')' break else: d[mod] = len(ans) return ans def myDivmod(self, a, b): d = int(a/b) m = a - d*b return (d, m)  ","id":21,"section":"posts","summary":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case.","tags":["leetcode"],"title":"166 Fraction to Recurring Decimal","uri":"https://foxisawesome.github.io/166-fraction-to-recurring-decimal/","year":"2020"},{"content":"LC 159 Longest Substring With at Most Two Distinct Characters   Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters.\nInput: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5.   Solution 2020-09-05 Notes:\n 今天周末出去走了一圈，回家刷题效率可以啊。  class Solution: def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u0026gt; int: if not s: return 0 out = 0 n = len(s) for i in range(n): l = 1 while i+l \u0026lt; n and len(set(s[i:i+l+1])) \u0026lt; 3: l += 1 out = max(out, l) return out # Time O(N) # Space O(1)  ","id":22,"section":"posts","summary":"LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def","tags":["leetcode"],"title":"159 Longest Substring With at Most Two Distinct Characters","uri":"https://foxisawesome.github.io/159-longest-substring-with-at-most-two-distinct-characters/","year":"2020"},{"content":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.add(num) else: stack.remove(num) return stack.pop() # Time O(N) # Space O(N)  If we take XOR of zero and some bit, it will return that bit: $a \\oplus 0 = a$ If we take XOR of two same bits, it will return 0: $a \\oplus a = 0$\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for num in nums: a ^= num return a  class Solution(object): def singleNumber(self, nums): return 2 * sum(set(nums)) - sum(nums)  ","id":23,"section":"posts","summary":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.","tags":["leetcode"],"title":"136 Single Number","uri":"https://foxisawesome.github.io/136-single-number/","year":"2020"},{"content":"LC 187 Repeated Dna Sequences   All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n Solution 2020-09-05 Notes:\n 很简单的题，两个小陷进：  Substring = s[i-9:i+1] NOT s[i-10:i] because 0-indexed. avoid dups in the output.    class Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: n = len(s) if not s or n\u0026lt;10: return [] count = dict() out = [] for i in range(9,n): entry = s[i-9:i+1] ct = count.get(entry,0) + 1 count[entry]= ct if ct \u0026gt; 1 and entry not in out: out.append(entry) return out # Time O(N) # Space O(1)  ","id":24,"section":"posts","summary":"LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷","tags":["leetcode"],"title":"187 Repeated Dna Sequences","uri":"https://foxisawesome.github.io/187-repeated-dna-sequences/","year":"2020"},{"content":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","id":25,"section":"posts","summary":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","tags":["leetcode"],"title":"1249 Minimum Remove to Make Valid Parentheses","uri":"https://foxisawesome.github.io/1249-minimum-remove-to-make-valid-parentheses/","year":"2020"},{"content":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Sam e\n  class Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: count = dict() stack = [] for l in s: count[l] = count.get(l,0) + 1 for c in s: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":26,"section":"posts","summary":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration.","tags":["leetcode"],"title":"316 Remove Dup Letters","uri":"https://foxisawesome.github.io/316-remove-dup-letters/","year":"2020"},{"content":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Same as LC 316\n  class Solution: def smallestSubsequence(self, text: str) -\u0026gt; str: count = dict() stack = [] for l in text: count[l] = count.get(l,0) + 1 for c in text: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":27,"section":"posts","summary":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.","tags":["leetcode"],"title":"1081 Smallest Subsequence of Distinct Char","uri":"https://foxisawesome.github.io/1081-smallest-subsequence-of-distinct-char/","year":"2020"},{"content":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.get(nums[fast],0) + 1 if count[nums[fast]] \u0026lt;= 2: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":28,"section":"posts","summary":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.","tags":["leetcode","twopointers"],"title":"80 Remove Dup From Sorted Array II","uri":"https://foxisawesome.github.io/80-remove-dup-from-sorted-array-ii/","year":"2020"},{"content":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.   Solution 2020-09-04 Notes:\n Two pointers: slow and fast. updates when fast == slow.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: slow, fast = 0, 1 while fast \u0026lt; len(nums): if nums[fast] != nums[slow]: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":29,"section":"posts","summary":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.","tags":["leetcode","twopointers"],"title":"26 Remove Dup From Sorted Array","uri":"https://foxisawesome.github.io/26-remove-dup-from-sorted-array/","year":"2020"},{"content":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: nums.sort() return self.kSum(nums, target, 4) def kSum(self, nums: List[int], target: int, k: int) -\u0026gt; List[List[int]]: res = [] if len(nums)==0 or nums[0] * k \u0026gt; target or nums[-1] * k \u0026lt; target: return res if k == 2: return self.twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for _, val in enumerate(self.kSum(nums[i+1:], target-nums[i], k-1)): res.append([nums[i]] + val) return res def twoSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: res = [] lo, hi = 0, len(nums) - 1 while (lo \u0026lt; hi): sum = nums[lo] + nums[hi] if sum \u0026lt; target or (lo \u0026gt; 0 and nums[lo] == nums[lo - 1]): lo += 1 elif sum \u0026gt; target or (hi \u0026lt; len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res # Time O(N^(k-1)) # Space O(N)  ","id":30,"section":"posts","summary":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):","tags":["leetcode"],"title":"18 K Sum","uri":"https://foxisawesome.github.io/18-k-sum/","year":"2020"},{"content":"LC 140 Word Break II   Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\nInput: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ]   Solution 2020-09-03 Notes:\n 第一次尝试，哇！这不是和 word break 一摸一样嘛。照模版写了个bt如下，试了两个例子都过了。提交了才发现，严重超时。一看官方解答是dp做的，感叹要不怎么是medium，一题是hard呢。但我觉得我要能加上memo 跟下面的dfs应该是同理。 于是看了大牛的解答，带memo的recursion是可以过的  # backtracking, exceed time limit! class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) out = [] self.backtracking(s,wordDict,[],out,n) return out def backtracking(self, s, wordDict, path, out, n): m = len(s) if m == 0: out.append(\u0026quot; \u0026quot;.join(path)) return for i in range(m): if s[:i+1] in wordDict: path.append(s[:i+1]) for self.backtracking(s[i+1:], wordDict, path, out, n) path.pop() # Time O() # Space O()  recursion with memo:\n need to add () to this res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)). Otherwise, it will interperate as res.append((w + '') if not r else (\u0026quot; \u0026quot; + r))  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: res = [] memo = dict() return self.dfs(s,wordDict,memo) def dfs(self, s,wordDict,memo): if s in memo: return memo[s] if not s: return [\u0026quot;\u0026quot;] res = [] for w in wordDict: if s[:len(w)] == w: for r in self.dfs(s[len(w):], wordDict, memo): res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)) memo[s] = res return res  ","id":31,"section":"posts","summary":"LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] Solution 2020-09-03 Notes: 第一","tags":["leetcode","dp","recursion","backtracking"],"title":"140 Word Break II","uri":"https://foxisawesome.github.io/140-word-break-ii/","year":"2020"},{"content":"LC 128 Longest Consecutive Sequence   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Solution 2020-09-03 Notes:\n  题目 time complexity 要求O(N)，那没其他办法只能 hash table做了，看了花花的视频， 没话说一讲就很简单了。\n  solution #1: 用dictionary做，key记录nums里的每个数，val=但这个数字的最长连续数字长度。查看num-1 和 num+1的val. online 求最长长度。\n  solution #2: 用set做, if num-1 not in the set, then num is the starting point of a consecutive list. Count the length until num+l not in the set. offline getting longest length.\n  class Solution: def longestConsecutive_solu1(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #1 h = dict() # key: num, val: consecutive length until key out = 0 for i in nums: if i in h: continue l = h[i-1] if i-1 in h else 0 r = h[i+1] if i+1 in h else 0 h[i] = h[i-l] = h[i+r] = l+r+1 out = max(out, h[i]) return out def longestConsecutive_solu2(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #2 h = set(nums) out = 0 for num in nums: if num-1 not in h: l = 1 while num+l in h: l += 1 out = max(out, l) return out # Time O(N) # Space O(N)  ","id":32,"section":"posts","summary":"LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: 题目 time complexity 要求O(N)，那没其","tags":["leetcode"],"title":"128 Longest Consecutive Sequence","uri":"https://foxisawesome.github.io/128-longest-consecutive-sequence/","year":"2020"},{"content":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n Solution 2020-09-02 Notes:\n Height of a tree: max(left_height, right_height) + 1 width of a tree (diameter): max(left_height + right_height) Diameter needs to be calculated along the way in this case.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: if not root: return 0 self.diameter = 0 self.DFS(root) return self.diameter def DFS(self, root) -\u0026gt; int: # DFS returns the height if not root: return 0 L_height = self.DFS(root.left) R_height = self.DFS(root.right) self.diameter = max(self.diameter, L_height+R_height) return max(L_height, R_height) + 1 # Time O(N) # Space O(N)  ","id":33,"section":"posts","summary":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].","tags":["leetcode","tree"],"title":"543 Diameter of Binary Tree","uri":"https://foxisawesome.github.io/543-diameter-of-binary-tree/","year":"2020"},{"content":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.\n  Algo #2: one pass, same time complexity. some details need to figure out.\n  rotation algo: r, c = c, n-r-1\n  row in range(n//2+n%2) and col in range(n//2)\n  while rotating the k, cycle from the last element: t[(k-1)%4]\n    class Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: n = len(matrix) # two-pass: 1. transpose; 2. reverse rows for i in range(n): for j in range(i,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() # one-pass: for i in range(n//2+n%2): for j in range(n//2): r, c = i, j t = [0]*4 for k in range(4): t[k] = matrix[r][c] r, c = c, n-r-1 for k in range(4): matrix[r][c] = t[(k-1)%4] r, c = c, n-r-1 # Time O(N^2) # Space O(1)  ","id":34,"section":"posts","summary":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.","tags":["leetcode"],"title":"48 Rotate Image","uri":"https://foxisawesome.github.io/48-rotate-image/","year":"2020"},{"content":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).\nMore formally, the probability of picking index i is w[i] / sum(w).\n Solution 2020-09-02 Notes:\n first, construct cumulative sum / total sum list. binary search for the nearest element \u0026gt; rand.uniform(0,1). I used closed interval in binary search, hence return l. No == case, because the robablilty of element exactly equal to random draw is 0.  class Solution: import random def __init__(self, w: List[int]): self.w = w self.w_sum = [] wsum = 0 tot = sum(self.w) for i in w: wsum += i prob = wsum/tot self.w_sum.append(prob) def pickIndex(self) -\u0026gt; int: target = random.uniform(0,1) l, r = 0, len(self.w)-1 while l \u0026lt;= r: m = l + (r-l)//2 if self.w_sum[m] \u0026gt; target: r = m - 1 elif self.w_sum[m] \u0026lt; target: l = m + 1 return l # Time O(N) + O(logN) # Space O(N)  ","id":35,"section":"posts","summary":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.","tags":["leetcode"],"title":"528 Random Pick With Weight","uri":"https://foxisawesome.github.io/528-random-pick-with-weight/","year":"2020"},{"content":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7   Solution 2020-09-02 Notes:\n Scan two linked lists first, using stack to store the node value. use the same LC 2 add two numbers to add them up from the end. Use LC 206 reverse linked list to store reversely along the way.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while stack1 and stack2: carry, r = divmod(stack1.pop() + stack2.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp stack = stack1 if stack1 else stack2 while stack: carry, r = divmod(stack.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp if carry != 0: temp = head head = ListNode(carry) head.next = temp return head # Time O(N) # Space O(1)  ","id":36,"section":"posts","summary":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists?","tags":["leetcode","linkedList"],"title":"445 Add Two Num II","uri":"https://foxisawesome.github.io/445-add-two-num-ii/","year":"2020"},{"content":"LC 295 Find Median From Data Stream   Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Solution 2020-09-01 Notes:\n  Follow 了花花酱的solu#1。 python the heapq implementation is a bit messy, while involving max heapq. python heapq library default heap is min-heap. filp all nums to -num to a heap, then it becomes a max-heap. Recover while pop.\n  Algo 想法挺简单但很巧: 分两堆：small (max-heap) 在左，large (min-heap)在右。\n Step1: add number to small heap while num \u0026lt;= small[0] Step2: balancing two heaps, 0\u0026lt;=len(small)-len(large)\u0026lt;2    class MedianFinder: import heapq def __init__(self): self.large = [] # min heap, right heap self.small = [] # max heap, left heap def addNum(self, num: int) -\u0026gt; None: if not self.small or num \u0026lt;= -self.small[0] : #default heapq is min heap, use -1*num will turn it as max heapq heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # balance two heaps if len(self.small) \u0026lt; len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) - len(self.large) == 2: heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -\u0026gt; float: if len(self.small) == len(self.large): return (-self.small[0] + self.large[0])/2 else: return -self.small[0] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() # Time O(nlogn) # Space O(N)  ","id":37,"section":"posts","summary":"LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow 了花花酱的so","tags":["leetcode"],"title":"295 Find Median From Data Stream","uri":"https://foxisawesome.github.io/295-find-median-from-data-stream/","year":"2020"},{"content":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head l_tail = slow = fast = head while fast and fast.next: l_tail = slow slow = slow.next fast = fast.next.next l_tail.next = None l = self.sortList(head) r = self.sortList(slow) return self.mergeTwoSorted(l,r) def mergeTwoSorted(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = dummy = ListNode(0) while l1 and l2: if l1.val \u0026lt; l2.val: head.next = l1 l1 = l1.next else: head.next = l2 l2 = l2.next head = head.next head.next = l1 if l1 else l2 return dummy.next # Time O(nlogn): merge sort # Space O(1): actually not O(1), since recursion is not O(1)  ","id":38,"section":"posts","summary":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.","tags":["leetcode","linkedList"],"title":"148 Sort List","uri":"https://foxisawesome.github.io/148-sort-list/","year":"2020"},{"content":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.   Solution 2020-09-01 Notes:\n classic DFS/backtracking problem. The biggest thing I\u0026rsquo;ve learnt from this: to return True/False instead of a list of retults. one needs to pass the true from bottom to top. Line 31-32 is doing this! Otherwise, if only line 23, on the the bottom DFS functions returns True, other lays return None.  class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: n = len(board) m = len(board[0]) directions = [[1,0], [-1,0], [0,1], [0,-1]] inits = [] for i in range(n): for j in range(m): if board[i][j] == word[0]: inits.append((i,j)) while inits: start = inits.pop() visited = set() visited.add(start) if self.dfs(board, word, directions, word[0], start, visited, m,n): return True return False def dfs(self, board, word, directions, path, point, visited,m,n): i, j = point[0], point[1] if path == word: return True for d in directions: x0, y0 = d[0], d[1] x1, y1 = x0+i, y0+j if 0\u0026lt;=x1\u0026lt;n and 0\u0026lt;=y1\u0026lt;m and (x1,y1) not in visited and board[x1][y1]==word[len(path)]: next_pt = (x1,y1) visited.add(next_pt) if self.dfs(board, word, directions, path+board[x1][y1],next_pt,visited,m,n): return True visited.remove(next_pt) # Time O(N*3^L), where L is the length of word # Space O(N)  ","id":39,"section":"posts","summary":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true.","tags":["leetcode","backtracking","DFS"],"title":"79 Word Search","uri":"https://foxisawesome.github.io/79-word-search/","year":"2020"},{"content":"LC 981 Time Based Key Value Store   Create a timebased key-value store class TimeMap, that supports two operations.\n set(string key, string value, int timestamp)   Stores the key and value, along with the given timestamp.  get(string key, int timestamp)   Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).   Solution 2020-09-01 Notes:\n 抄了一遍：这个reference  class TimeMap: def __init__(self): self.v_ = collections.defaultdict(list) self.t_ = collections.defaultdict(list) def set(self, key: str, value: str, timestamp: int) -\u0026gt; None: self.t_[key].append(timestamp) self.v_[key].append(value) def get(self, key: str, timestamp: int) -\u0026gt; str: if key not in self.t_: return \u0026quot;\u0026quot; # bisect is efficient algo to search key i = bisect.bisect_right(self.t_[key], timestamp) if i: return self.v_[key][i-1] return \u0026quot;\u0026quot; # Your TimeMap object will be instantiated and called as such: # obj = TimeMap() # obj.set(key,value,timestamp) # param_2 = obj.get(key,timestamp)  ","id":40,"section":"posts","summary":"LC 981 Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are","tags":["leetcode"],"title":"981 Time Based Key Value Store","uri":"https://foxisawesome.github.io/981-time-based-key-value-store/","year":"2020"},{"content":"LC 1041 Robot Bounded in Circle \n On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:\n \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n 2020-08-31 Notes:\n 没见过这种implementation。好经典的做法，二刷希望能刷出来。  class Solution: def isRobotBounded(self, instructions: str) -\u0026gt; bool: # north = 0, east = 1, south = 2, west = 3 directions = [[0,1],[1,0],[0,-1],[-1,0]] x = y = 0 idx = 0 for i in instructions: if i == 'L': idx = (idx + 3) % 4 elif i == 'R': idx = (idx + 1) % 4 else: x += directions[idx][0] y += directions[idx][1] return (x==0 and y==0) or idx != 0  ","id":41,"section":"posts","summary":"LC 1041 Robot Bounded in Circle On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in","tags":["leetcode"],"title":"1041 Robot Bounded in Circle","uri":"https://foxisawesome.github.io/1041-robot-bounded-in-circle/","year":"2020"},{"content":"LC 957 Prison Cells \n There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can\u0026rsquo;t have two adjacent neighbors.)\nWe describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\n 2020-08-31 Notes:\n  这题做了好久，好多corner case没过。最后才明白：\n  cycle = 14\n  two cases:\n​\ta. head in the cycle of 14; days %= 14\n​\tb. head not in the cycle of 14. in this case, days = (days-1)%14,\n    class Solution: def nextDay(self, cells): cells_nd = [0] for i in range(1,len(cells)-1): if cells[i-1] == cells[i+1]: cells_nd.append(1) else: cells_nd.append(0) cells_nd.append(0) return cells_nd def prisonAfterNDays(self, cells: List[int], N: int) -\u0026gt; List[int]: if not cells: return [] if N == 0: return cells memo = dict() memo[str(cells[:])] = 0 n = len(cells) for d in range(1,N+1): cells = self.nextDay(cells) print(d,cells) if str(cells) in memo: cycle = d - memo[str(cells)] break memo[str(cells[:])] = d # cycle is always 14. But two cases: 1. head is in the cycle; 2. head is not in the cycle. if d \u0026lt; N: if memo[str(cells)]==0: # head in the cycle case days = (N)%cycle else: # head not in the cycle case. days = (N-1)%cycle for d in range(days): cells = self.nextDay(cells) return cells  ","id":42,"section":"posts","summary":"LC 957 Prison Cells There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the","tags":["leetcode"],"title":"957 Prison Cells","uri":"https://foxisawesome.github.io/957-prison-cells/","year":"2020"},{"content":"LC 735 Aseroid Collision \n We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.  Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other.  Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.  Example 4:\nInput: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   2020-08-31 Notes:\n 一次就做对了如下。虽然不简洁，但能用上recursion，也算挺开心了。 一看官方解答，跟简洁，能combine 很多的case。而且最关键的：while+ continue+break的组合完美的绕开了recursion的做法。看了下时间比较差距不大。  class Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: stack = self.helper(stack, a) return stack def helper(self, stack, a): if not stack: stack.append(a) elif stack[-1] * a \u0026gt; 0 or stack[-1] \u0026lt; 0 and a \u0026gt; 0: stack.append(a) elif abs(stack[-1]) == abs(a): stack.pop() elif abs(stack[-1]) \u0026lt; abs(a): stack.pop() return self.helper(stack, a) return stack # Time O(N) # Space O(N)  官方解答：\nclass Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: while stack and a \u0026lt; 0 \u0026lt; stack[-1]: if stack[-1] \u0026lt; -a: stack.pop() continue elif stack[-1] == -a: stack.pop() break else: stack.append(a) return stack  ","id":43,"section":"posts","summary":"LC 735 Aseroid Collision We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size,","tags":["leetcode","recursion","stack"],"title":"735 Aseroid Collision","uri":"https://foxisawesome.github.io/735-aseroid-collision/","year":"2020"},{"content":"LC 141 Linked List Cycle \n Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.   08/29/2020 Notes:\n Fast two steps at a time, slow pointer one step a time. 一次也就过了。  class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if not head: return slow = fast = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False  ","id":44,"section":"posts","summary":"LC 141 Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There","tags":["leetcode","linkedList"],"title":"141 Linked List Cycle","uri":"https://foxisawesome.github.io/141-linked-list-cycle/","year":"2020"},{"content":"LC 328\n Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL   linked list 终于在周末刷出感觉了。这题也一遍就过了。\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return odd = p1 = ListNode(1) even = p2 = ListNode(0) count = 1 while head: if count % 2 == 1: odd.next = ListNode(head.val) odd = odd.next else: even.next = ListNode(head.val) even = even.next head = head.next count += 1 odd.next = p2.next return p1.next  ","id":45,"section":"posts","summary":"LC 328 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL linked list 终于在周末刷出感","tags":["leetcode","linkedList"],"title":"328 Odd Even Linked List","uri":"https://foxisawesome.github.io/328-odd-even-linked-list/","year":"2020"},{"content":"LC 1266\n On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.   一遍就过的题，没啥好说的。\nclass Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -\u0026gt; int: n = len(points) m = len(points[0]) time = 0 if not points or n == 0 or m == 0: return time for i in range(1, n): x1, y1 = points[i-1] x2, y2 = points[i] time += max(abs(x1-x2), abs(y1-y2)) return time  ","id":46,"section":"posts","summary":"LC 1266 On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points. You can move according to the next rules: In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to","tags":["leetcode"],"title":"1266 Minimum Time Visiting All Points","uri":"https://foxisawesome.github.io/1266-minimum-time-visiting-all-points/","year":"2020"},{"content":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:\n BST has a property that: if in-order traverse, the output is a sorted list. Time complex is O(N), if store everything, then space complexity is O(N). I can only maintain min_diff in each root step to reduce space complexity to O(1). recursion here is pretty easy: standard in-order traversal recursion.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getMinimumDifference(self, root: TreeNode) -\u0026gt; int: self.prev = None self.min_diff = float('inf') self.inorder(root) return self.min_diff def inorder(self, root): if not root: return self.inorder(root.left) if self.prev is not None: self.min_diff = min(self.min_diff, root.val - self.prev) self.prev = root.val self.inorder(root.right)  ","id":47,"section":"posts","summary":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:","tags":["leetcode","tree","BST"],"title":"530 Min Abs Dif BST","uri":"https://foxisawesome.github.io/530-min-abs-dif-bst/","year":"2020"},{"content":"LC 98 Valid BST\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  08/30/2020 Notes:\n two ways: 1. Check if a sorted list returned after in-order traversal. 2. check if alway root.right.val \u0026gt; root.val \u0026gt; root.left.val I used the first way. 这又是个很高级的recursion。  class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: self.prev = None return self.inorder(root) def inorder(self, root): if not root: return True if not self.inorder(root.left): return False if self.prev is not None and root.val \u0026lt;= self.prev: return False self.prev = root.val return self.inorder(root.right)  ","id":48,"section":"posts","summary":"LC 98 Valid BST Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example","tags":["leetcode","tree","BST"],"title":"98 Valid BST","uri":"https://foxisawesome.github.io/98-valid-bst/","year":"2020"},{"content":"LC 701\n Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5  You can return this binary search tree:\n 4 / \\ 2 7 / \\ / 1 3 5  This tree is also valid:\n 5 / \\ 2 7 / \\ 1 3 \\ 4   08/30/2020 Notes:\n 这个recursion 好高级，似懂非懂回头还得在刷。 一定要明确 resursion function return 的是什么。 这个return的是TreeNode。  9/10/2020 Note:\n刷了一阵tree之后终于搞懂了，给tree添加leaf node的操作是 root.left = TreeNode(val), 所以if not root: return root.val. 最后添加完之后就是return这个root 一层一层返回。\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def insertIntoBST(self, root: TreeNode, val: int) -\u0026gt; TreeNode: if not root: return TreeNode(val) if root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root  ","id":49,"section":"posts","summary":"LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST","tags":["leetcode","tree","BST"],"title":"701 Insert Into BST","uri":"https://foxisawesome.github.io/701-insert-into-bst/","year":"2020"},{"content":"滑动窗口算法的思路是这样：\n1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。\n2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。\n3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到right到达字符串S的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\nrefrence: wx:labuladong\nCode Template:\ndef slidingWindow(s: str, t: str) -\u0026gt; str: target, window = {}, {} for i in t: target[i] = target.get(i,0) + 1 left, right, valid = 0, 0, 0 while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] # move right index right += 1 # 进行窗口内数据的一系列更新 ... # /*** debug 输出的位置 ***/ print('s: '+s2[left:right]+' window' + str(window) + ' valid: ' + str(valid)) # see if needs to shrink window while (window shrinking condition): d = s[left] left += 1 # 进行窗口内数据的一系列更新 ... return ...  ","id":50,"section":"posts","summary":"滑动窗口算法的思路是这样： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)","tags":["template"],"title":"Sliding Window Note","uri":"https://foxisawesome.github.io/sliding-window-note/","year":"2020"},{"content":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post!\nIt takes a while for me to get how exactly Linked List works. I used following utility functions to keep my leetcode solutions and run codes locally.\nNote:\n say head = ListNode(0), then head = head.next is to iterate to next node on the Linked List. use head.next = a to point to next node.  # My liked list utility functions: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def list2ListNode(list): head = LinkedList = ListNode(0) for i in range(len(list)): LinkedList.next = ListNode(list[i]) LinkedList = LinkedList.next return head.next def printListNode(p): head = ListNode(0) head.next = p out = [] while p: out.append(p.val) p = p.next return out # e.g.: indata = [1,2,3,4,5,6] head = ListNode.list2ListNode(indata) ListNode.printListNode(head)  ","id":51,"section":"posts","summary":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post! It takes a while for me to get how exactly Linked List","tags":["template","linkedList"],"title":"Linked List Note (First Post)","uri":"https://foxisawesome.github.io/linked-list-note/","year":"2020"},{"content":"LC 42 Trapping Rain Water   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n Solution 2020-08-05 Notes:\n 短边原理，左右指针同时走，r_max 大时短边在left，所以计算left side。 每一格计算下相较于短边的容水量即可  左右指针的 while loop，设为 l\u0026lt;=r 或者 了l\u0026lt;r 都一样，因为l=r跳出时只可能r_max = l_max = height[r]=height[l], water=0.    class Solution: def trap(self, height: List[int]) -\u0026gt; int: if not height: return 0 l, r = 0, len(height)-1 l_max, r_max = height[0], height[-1] ans = 0 while l \u0026lt; r: l_max = max(l_max, height[l]) r_max = max(r_max, height[r]) if l_max \u0026lt; r_max: ans += l_max - height[l] l += 1 else: ans += r_max - height[r] r -= 1 return ans # Time O(N) # Space O(1)  ","id":52,"section":"posts","summary":"LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: 短边原理，左右指针同时走，r_max 大时短边在left，所以计算lef","tags":["leetcode"],"title":"42 Trapping Rain Water","uri":"https://foxisawesome.github.io/42-trapping-rain-water/","year":"2020"},{"content":"LC 206 Reverse Linked List   Reverse a singly linked list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   Solution 2020-09-01 Notes:\n  这题刷了不下10遍了，终于明白iteration这里的四步操作了。\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: # iteration def reverseList_iter(self, head: ListNode) -\u0026gt; ListNode: if not head: return None prev = None curr = head while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev   recursion的做法还是似懂非懂，还得再看看。感觉TreeNode, ListNode 的recursion 都是if not head/root: return head/root。 另外，recession 这里返回的是 以head.next为头reversed 的list，只需要再把head.next\t reverse 下就好了。  # recursion def reverseList_rec(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p # Time O(N) for iteration # Space O(1)  ","id":53,"section":"posts","summary":"LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL Solution 2020-09-01 Notes: 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next","tags":["leetcode","linkedList"],"title":"206 Reverse Linked List","uri":"https://foxisawesome.github.io/206-reverse-linked-list/","year":"2020"},{"content":"LC 2 Add Two Num   You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807.   Solution 2020-07-02 Notes:\n 比较简单，但是 don’t forget line 17 and 25。  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: head = out = ListNode(0) carry = 0 while l1 and l2: carry, m = divmod(l1.val + l2.val + carry, 10) out.next = ListNode(m) l1 = l1.next l2 = l2.next out = out.next l = l1 if l1 else l2 while l: carry, m = divmod(l.val + carry, 10) out.next = ListNode(m) out = out.next l = l.next if carry \u0026gt; 0: out.next = ListNode(carry) return head.next # Time O(N) # Space O(1)  ","id":54,"section":"posts","summary":"LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt;","tags":["leetcode","linkedList"],"title":"2 Add Two Num","uri":"https://foxisawesome.github.io/2-add-two-num/","year":"2020"},{"content":"LC 69 Sqrtx   Implement int sqrt(int x).\nSqrt(8) = 2\n Solution 2020-03-07 Notes:\n 标准的binary search 模版， right 从x//2开始。  class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x: return mid elif mid**2 \u0026gt; x: right = mid -1 elif mid**2 \u0026lt; x: left = mid + 1 # exit at [right, left], hence return right return right # Time O(logN) # Space O(1)  ","id":55,"section":"posts","summary":"LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: 标准的binary search 模版， right 从x//2开始。 class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x:","tags":["leetcode","binarySearch"],"title":"69 Sqrtx","uri":"https://foxisawesome.github.io/69-sqrtx/","year":"2020"},{"content":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","id":56,"section":"posts","summary":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","tags":["leetcode","array","dictionary"],"title":"1 Two Sum","uri":"https://foxisawesome.github.io/1-two-sum/","year":"2020"}],"tags":[{"title":"array","uri":"https://foxisawesome.github.io/tags/array/"},{"title":"backtracking","uri":"https://foxisawesome.github.io/tags/backtracking/"},{"title":"binarySearch","uri":"https://foxisawesome.github.io/tags/binarysearch/"},{"title":"BST","uri":"https://foxisawesome.github.io/tags/bst/"},{"title":"DFS","uri":"https://foxisawesome.github.io/tags/dfs/"},{"title":"dictionary","uri":"https://foxisawesome.github.io/tags/dictionary/"},{"title":"dp","uri":"https://foxisawesome.github.io/tags/dp/"},{"title":"hashtable","uri":"https://foxisawesome.github.io/tags/hashtable/"},{"title":"kmeans","uri":"https://foxisawesome.github.io/tags/kmeans/"},{"title":"leetcode","uri":"https://foxisawesome.github.io/tags/leetcode/"},{"title":"linkedList","uri":"https://foxisawesome.github.io/tags/linkedlist/"},{"title":"recursion","uri":"https://foxisawesome.github.io/tags/recursion/"},{"title":"stack","uri":"https://foxisawesome.github.io/tags/stack/"},{"title":"template","uri":"https://foxisawesome.github.io/tags/template/"},{"title":"tree","uri":"https://foxisawesome.github.io/tags/tree/"},{"title":"twopointers","uri":"https://foxisawesome.github.io/tags/twopointers/"}]}