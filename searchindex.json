{"categories":[{"title":"algo","uri":"https://foxisawesome.github.io/categories/algo/"},{"title":"note","uri":"https://foxisawesome.github.io/categories/note/"},{"title":"sql","uri":"https://foxisawesome.github.io/categories/sql/"}],"posts":[{"content":"LC 1098 Unpopular Books   Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23.\nThe query result format is in the following example:\nBooks table: +---------+--------------------+----------------+ | book_id | name | available_from | +---------+--------------------+----------------+ | 1 | \u0026quot;Kalila And Demna\u0026quot; | 2010-01-01 | | 2 | \u0026quot;28 Letters\u0026quot; | 2012-05-12 | | 3 | \u0026quot;The Hobbit\u0026quot; | 2019-06-10 | | 4 | \u0026quot;13 Reasons Why\u0026quot; | 2019-06-01 | | 5 | \u0026quot;The Hunger Games\u0026quot; | 2008-09-21 | +---------+--------------------+----------------+ Orders table: +----------+---------+----------+---------------+ | order_id | book_id | quantity | dispatch_date | +----------+---------+----------+---------------+ | 1 | 1 | 2 | 2018-07-26 | | 2 | 1 | 1 | 2018-11-05 | | 3 | 3 | 8 | 2019-06-11 | | 4 | 4 | 6 | 2019-06-05 | | 5 | 4 | 5 | 2019-06-20 | | 6 | 5 | 9 | 2009-02-02 | | 7 | 5 | 8 | 2010-04-13 | +----------+---------+----------+---------------+ Result table: +-----------+--------------------+ | book_id | name | +-----------+--------------------+ | 1 | \u0026quot;Kalila And Demna\u0026quot; | | 2 | \u0026quot;28 Letters\u0026quot; | | 5 | \u0026quot;The Hunger Games\u0026quot; | +-----------+--------------------+   Solution 2020-10-29 Notes:   做这题时发现了一个问题就是 condition in on cluase (while using LEFT join) will have totally different effect from condition in the where clause. The reason is here: on clause is applied when joining.\n  问题是这样的：\nSELECT a.* FROM books a LEFT JOIN orders b ON a.book_id = b.book_id AND DATEDIFF('2019-06-23', a.available_from) \u0026gt;= 30\nvs\nSELECT a.* FROM books a LEFT JOIN orders b ON a.book_id = b.book_id WHERE DATEDIFF('2019-06-23', a.available_from) \u0026gt;= 30\n第一个 AND DATEDIFF('2019-06-23', a.available_from) \u0026gt;= 30完全没效果。感觉解是不是很对。\n  SELECT book_id, name FROM ( SELECT a.*, SUM(CASE WHEN DATEDIFF('2019-06-23',dispatch_date)\u0026lt;=365 THEN quantity ELSE 0 END) AS ct FROM books a LEFT JOIN orders b ON a.book_id = b.book_id WHERE DATEDIFF('2019-06-23', a.available_from) \u0026gt;= 30 GROUP BY a.book_id ) c WHERE ct \u0026lt; 10 ORDER BY book_id  ","id":0,"section":"posts","summary":"LC 1098 Unpopular Books Write an SQL query that reports the books that have sold less than 10 copies in the last year, excluding books that have been available for less than 1 month from today. Assume today is 2019-06-23. The query result format is in the following example: Books table: +---------+--------------------+----------------+ | book_id | name | available_from | +---------+--------------------+----------------+ | 1 | \u0026quot;Kalila And Demna\u0026quot; | 2010-01-01 | |","tags":["leetcode","dia_sql"],"title":"1098 Unpopular Books","uri":"https://foxisawesome.github.io/posts/1098-unpopular-books/","year":"2020"},{"content":"LC 1082 Sales Analysis I   Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.\n Solution 2020-10-29 Notes:  Window function solution, which is faster  SELECT seller_id FROM ( SELECT *, RANK() OVER(ORDER BY SUM(price) DESC) AS rk FROM sales GROUP BY seller_id ) a WHERE rk = 1   aggregation func solution  SELECT seller_id FROM sales GROUP BY 1 HAVING SUM(price) = (SELECT SUM(price) FROM sales GROUP BY seller_id ORDER BY 1 DESC LIMIT 1)  ","id":1,"section":"posts","summary":"LC 1082 Sales Analysis I   Write an SQL query that reports the best seller by total sales price, If there is a tie, report them all.\n Solution 2020-10-29 Notes:  Window function solution, which is faster  SELECT seller_id FROM ( SELECT *, RANK() OVER(ORDER BY SUM(price) DESC) AS rk FROM sales GROUP BY seller_id ) a WHERE rk = 1   aggregation func solution  SELECT seller_id FROM sales GROUP BY 1 HAVING SUM(price) = (SELECT SUM(price) FROM sales GROUP BY seller_id ORDER BY 1 DESC LIMIT 1)  ","tags":["leetcode"],"title":"1082 Sales Analysis I","uri":"https://foxisawesome.github.io/posts/1082-sales-analysis-i/","year":"2020"},{"content":"LC 1077 Project Employees III   Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years.\n Solution 2020-10-29 Notes:  秒了  SELECT project_id, employee_id FROM ( SELECT a.*, RANK() OVER(PARTITION BY project_id ORDER BY experience_years DESC) AS rk FROM project a JOIN employee b ON a.employee_id = b.employee_id ) c WHERE rk = 1  ","id":2,"section":"posts","summary":"LC 1077 Project Employees III Write an SQL query that reports the most experienced employees in each project. In case of a tie, report all employees with the maximum number of experience years. Solution 2020-10-29 Notes: 秒了 SELECT project_id, employee_id FROM ( SELECT a.*, RANK() OVER(PARTITION BY project_id ORDER BY experience_years DESC) AS rk FROM project a JOIN employee b ON a.employee_id = b.employee_id ) c WHERE rk =","tags":["leetcode"],"title":"1077 Project Employees III","uri":"https://foxisawesome.github.io/posts/1077-project-employees-iii/","year":"2020"},{"content":"LC 1069 Product Sales Analysis II   Write an SQL query that reports the total quantity sold for every product id.\n Solution 2020-10-29 Notes: SELECT product_id, SUM(quantity) AS total_quantity FROM sales GROUP BY 1 ORDER BY 1  ","id":3,"section":"posts","summary":"LC 1069 Product Sales Analysis II   Write an SQL query that reports the total quantity sold for every product id.\n Solution 2020-10-29 Notes: SELECT product_id, SUM(quantity) AS total_quantity FROM sales GROUP BY 1 ORDER BY 1  ","tags":["leetcode"],"title":"1069 Product Sales Analysis II","uri":"https://foxisawesome.github.io/posts/1069-product-sales-analysis-ii/","year":"2020"},{"content":"LC 1068 Product Sales Analysis I   Write an SQL query that reports all product names of the products in the Sales table along with their selling year and price.\n Solution 2020-10-29 Notes: select a.product_name, b.year, b.price from product a join sales b on a.product_id = b.product_id order by year, price ;  ","id":4,"section":"posts","summary":"LC 1068 Product Sales Analysis I   Write an SQL query that reports all product names of the products in the Sales table along with their selling year and price.\n Solution 2020-10-29 Notes: select a.product_name, b.year, b.price from product a join sales b on a.product_id = b.product_id order by year, price ;  ","tags":["leetcode"],"title":"1068 Product Sales Analysis I","uri":"https://foxisawesome.github.io/posts/1068-product-sales-analysis-i/","year":"2020"},{"content":"LC 601 Human Traffic of Stadium   Write an SQL query to display the records with three or more rows with consecutive id\u0026rsquo;s, and the number of people is greater than or equal to 100 for each.\nReturn the result table ordered by visit_date in ascending order.\nThe query result format is in the following example.\nStadium table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ Result table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+   Solution 2020-10-27 Notes:  it is slower than version #2. But it is resolving the problem in a more automatic way.  SELECT id, visit_date, people FROM ( SElECT *, COUNT(id) OVER(PARTITION BY mask) AS ct FROM ( SELECT *, id - ROW_NUMBER() OVER() AS mask FROM stadium WHERE people \u0026gt;= 100 ) a ) b WHERE ct \u0026gt;= 3 ORDER BY visit_date   v2  SELECT id, visit_date , people FROM stadium WHERE 3 \u0026lt;= ( SELECT COUNT(s.people) FROM stadium AS s WHERE s.people \u0026gt;= 100 AND s.id \u0026gt;= stadium.id AND s.id \u0026lt;= stadium.id+2 ) OR 3 \u0026lt;= ( SELECT COUNT(s.people) FROM stadium AS s WHERE s.people \u0026gt;= 100 AND s.id \u0026gt;= stadium.id-1 AND s.id \u0026lt;= stadium.id+1 ) OR 3 \u0026lt;= ( SELECT COUNT(s.people) FROM stadium AS s WHERE s.people \u0026gt;= 100 AND s.id \u0026gt;= stadium.id-2 AND s.id \u0026lt;= stadium.id )  ","id":5,"section":"posts","summary":"LC 601 Human Traffic of Stadium   Write an SQL query to display the records with three or more rows with consecutive id\u0026rsquo;s, and the number of people is greater than or equal to 100 for each.\nReturn the result table ordered by visit_date in ascending order.\nThe query result format is in the following example.\nStadium table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 1 | 2017-01-01 | 10 | | 2 | 2017-01-02 | 109 | | 3 | 2017-01-03 | 150 | | 4 | 2017-01-04 | 99 | | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+ Result table: +------+------------+-----------+ | id | visit_date | people | +------+------------+-----------+ | 5 | 2017-01-05 | 145 | | 6 | 2017-01-06 | 1455 | | 7 | 2017-01-07 | 199 | | 8 | 2017-01-09 | 188 | +------+------------+-----------+   Solution 2020-10-27 Notes:  it is slower than version #2.","tags":["leetcode"],"title":"601 Human Traffic of Stadium","uri":"https://foxisawesome.github.io/posts/601-human-traffic-of-stadium/","year":"2020"},{"content":"LC 614 Second Degree Follower   In facebook, there is a follow table with two columns: followee, follower.\nPlease write a sql query to get the amount of each follower’s follower if he/she has one.\nFor example:\n+-------------+------------+ | followee | follower | +-------------+------------+ | A | B | | B | C | | B | D | | D | E | +-------------+------------+  should output:\n+-------------+------------+ | follower | num | +-------------+------------+ | B | 2 | | D | 1 | +-------------+------------+  Explaination: Both B and D exist in the follower list, when as a followee, B\u0026rsquo;s follower is C and D, and D\u0026rsquo;s follower is E. A does not exist in follower list.\n Solution 2020-10-25 Notes: SELECT a.follower, COUNT( DISTINCT b.follower) AS num FROM follow a JOIN follow b ON a.follower = b.followee GROUP BY 1  ","id":6,"section":"posts","summary":"LC 614 Second Degree Follower   In facebook, there is a follow table with two columns: followee, follower.\nPlease write a sql query to get the amount of each follower’s follower if he/she has one.\nFor example:\n+-------------+------------+ | followee | follower | +-------------+------------+ | A | B | | B | C | | B | D | | D | E | +-------------+------------+  should output:\n+-------------+------------+ | follower | num | +-------------+------------+ | B | 2 | | D | 1 | +-------------+------------+  Explaination: Both B and D exist in the follower list, when as a followee, B\u0026rsquo;s follower is C and D, and D\u0026rsquo;s follower is E.","tags":["leetcode"],"title":"614 Second Degree Follower","uri":"https://foxisawesome.github.io/posts/614-second-degree-follower/","year":"2020"},{"content":"LC 608 Tree Node   Given a table tree, id is identifier of the tree node and p_id is its parent node\u0026rsquo;s id.\n+----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+  Each node in the tree can be one of three types:\n Leaf: if the node is a leaf node. Root: if the node is the root of the tree. Inner: If the node is neither a leaf node nor a root node.  Write a query to print the node id and the type of the node. Sort your output by the node id. The result for the above sample is:\n Solution 2020-10-25 Notes: 这个不是很efficient\nSELECT DISTINCT id, CASE WHEN parent IS NULL THEN 'Root' WHEN child IS NULL THEN 'Leaf' ELSE 'Inner' END AS type FROM ( SELECT a.p_id AS parent, a.id, b.id AS child FROM tree a LEFT JOIN tree b ON a.id = b.p_id ) c  2020-02-07 Notes: 这个简洁高效\nselect id, case when p_id is NULL then 'Root' when id not in (select distinct p_id from tree where p_id is not null) then 'Leaf' else 'Inner' end as Type from tree  ","id":7,"section":"posts","summary":"LC 608 Tree Node Given a table tree, id is identifier of the tree node and p_id is its parent node\u0026rsquo;s id. +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ Each node in the tree can be one of three types: Leaf: if the node","tags":["leetcode","dia_sql"],"title":"608 Tree Node","uri":"https://foxisawesome.github.io/posts/608-tree-node/","year":"2020"},{"content":"LC 610 Triangle Judgement   Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z.\n| x | y | z | |----|----|----| | 13 | 15 | 30 | | 10 | 20 | 15 |  For the sample data above, your query should return the follow result:\n| x | y | z | triangle | |----|----|----|----------| | 13 | 15 | 30 | No | | 10 | 20 | 15 | Yes |   Solution 2020-10-25 Notes: 秒了\nselect x, y, z, case when x+y \u0026gt; z and x+z \u0026gt; y and y+z \u0026gt;x then 'Yes' else 'No' end as triangle from triangle  ","id":8,"section":"posts","summary":"LC 610 Triangle Judgement Could you help Tim by writing a query to judge whether these three sides can form a triangle, assuming table triangle holds the length of the three sides x, y and z. | x | y | z | |----|----|----| | 13 | 15 | 30 | | 10 | 20 | 15 | For the sample data above, your query should return the follow result:","tags":["leetcode"],"title":"610 Triangle Judgement","uri":"https://foxisawesome.github.io/posts/610-triangle-judgement/","year":"2020"},{"content":"LC 612 Shortest Distance in a Plane   Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane.\nWrite a query to find the shortest distance between these points rounded to 2 decimals.\n| x | y | |----|----| | -1 | -1 | | 0 | 0 | | -1 | -2 |  The shortest distance is 1.00 from point (-1,-1) to (-1,2). So the output should be:\n| shortest | |----------| | 1.00 |   Solution 2020-10-25 Notes: 秒了\nSELECT MIN(ROUND( SQRT( POWER(a.x-b.x,2) + POWER(a.y-b.y,2)) ,2)) AS shortest FROM point_2d a JOIN point_2d b ON CONCAT(a.x,a.y) != CONCAT(b.x,b.y)  ","id":9,"section":"posts","summary":"LC 612 Shortest Distance in a Plane Table point_2d holds the coordinates (x,y) of some unique points (more than two) in a plane. Write a query to find the shortest distance between these points rounded to 2 decimals. | x | y | |----|----| | -1 | -1 | | 0 | 0 | | -1 | -2 | The shortest distance is 1.00 from point (-1,-1) to (-1,2). So","tags":["leetcode"],"title":"612 Shortest Distance in a Plane","uri":"https://foxisawesome.github.io/posts/612-shortest-distance-in-a-plane/","year":"2020"},{"content":"LC 586 Customer Placing the Largest Number of Orders   Query the customer_number from the *orders* table for the customer who has placed the largest number of orders.\nIt is guaranteed that exactly one customer will have placed more orders than any other customer.\n Solution 2020-10-24 Notes: 秒了\nselect customer_number from (select customer_number, count(order_number) as ct from orders group by 1 order by ct desc) a limit 1  ","id":10,"section":"posts","summary":"LC 586 Customer Placing the Largest Number of Orders Query the customer_number from the *orders* table for the customer who has placed the largest number of orders. It is guaranteed that exactly one customer will have placed more orders than any other customer. Solution 2020-10-24 Notes: 秒了 select customer_number from (select customer_number, count(order_number) as ct from orders group by 1 order by ct desc) a limit 1","tags":["leetcode"],"title":"586 Customer Placing the Largest Number of Orders","uri":"https://foxisawesome.github.io/posts/586-customer-placing-the-largest-number-of-orders/","year":"2020"},{"content":"LC 580 Count Student Number in Departments   Write a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students).\nSort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name. *student* table:\n| student_id | student_name | gender | dept_id | |------------|--------------|--------|---------| | 1 | Jack | M | 1 | | 2 | Jane | F | 1 | | 3 | Mark | M | 2 |  *department* table:\n| dept_id | dept_name | |---------|-------------| | 1 | Engineering | | 2 | Science | | 3 | Law |  The Output should be:\n| dept_name | student_number | |-------------|----------------| | Engineering | 2 | | Science | 1 | | Law | 0 |   Solution 2020-10-24 Notes: 秒了\nSELECT dept_name, IFNULL(ct,0) AS student_number FROM department a LEFT JOIN (SELECT dept_id, COUNT(*) AS ct FROM student GROUP BY 1) b ON a.dept_id = b.dept_id ORDER BY 2 DESC, 1  ","id":11,"section":"posts","summary":"LC 580 Count Student Number in Departments Write a query to print the respective department name and number of students majoring in each department for all departments in the department table (even ones with no current students). Sort your results by descending number of students; if two or more departments have the same number of students, then sort those departments alphabetically by department name. *student* table: | student_id | student_name","tags":["leetcode"],"title":"580 Count Student Number in Departments","uri":"https://foxisawesome.github.io/posts/580-count-student-number-in-departments/","year":"2020"},{"content":"LC 578 Get Highest Answer Rate Question   Get the highest answer rate question from a table survey_log with these columns: id, action, question_id, answer_id, q_num, timestamp.\nid means user id; action has these kind of values: \u0026ldquo;show\u0026rdquo;, \u0026ldquo;answer\u0026rdquo;, \u0026ldquo;skip\u0026rdquo;; answer_id is not null when action column is \u0026ldquo;answer\u0026rdquo;, while is null for \u0026ldquo;show\u0026rdquo; and \u0026ldquo;skip\u0026rdquo;; q_num is the numeral order of the question in current session.\nWrite a sql query to identify the question which has the highest answer rate.\nExample:\nInput: +------+-----------+--------------+------------+-----------+------------+ | id | action | question_id | answer_id | q_num | timestamp | +------+-----------+--------------+------------+-----------+------------+ | 5 | show | 285 | null | 1 | 123 | | 5 | answer | 285 | 124124 | 1 | 124 | | 5 | show | 369 | null | 2 | 125 | | 5 | skip | 369 | null | 2 | 126 | +------+-----------+--------------+------------+-----------+------------+ Output: +-------------+ | survey_log | +-------------+ | 285 | +-------------+   Solution 2020-10-24 Notes: SELECT question_id AS survey_log FROM ( SELECT question_id, SUM(CASE WHEN action='answer' THEN 1 ELSE 0 END) / SUM(CASE WHEN action='show' THEN 1 ELSE 0 END) AS rt FROM survey_log GROUP BY 1 ORDER BY 2 DESC ) a LIMIT 1  ","id":12,"section":"posts","summary":"LC 578 Get Highest Answer Rate Question   Get the highest answer rate question from a table survey_log with these columns: id, action, question_id, answer_id, q_num, timestamp.\nid means user id; action has these kind of values: \u0026ldquo;show\u0026rdquo;, \u0026ldquo;answer\u0026rdquo;, \u0026ldquo;skip\u0026rdquo;; answer_id is not null when action column is \u0026ldquo;answer\u0026rdquo;, while is null for \u0026ldquo;show\u0026rdquo; and \u0026ldquo;skip\u0026rdquo;; q_num is the numeral order of the question in current session.\nWrite a sql query to identify the question which has the highest answer rate.","tags":["leetcode"],"title":"578 Get Highest Answer Rate Question","uri":"https://foxisawesome.github.io/posts/578-get-highest-answer-rate-question/","year":"2020"},{"content":"LC 570 Managers With at Least 5 Direct Reports   The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.\n+------+----------+-----------+----------+ |Id |Name |Department |ManagerId | +------+----------+-----------+----------+ |101 |John |A |null | |102 |Dan |A |101 | |103 |James |A |101 | |104 |Amy |A |101 | |105 |Anne |A |101 | |106 |Ron |B |101 | +------+----------+-----------+----------+  Given the Employee table, write a SQL query that finds out managers with at least 5 direct report. For the above table, your SQL query should return:\n+-------+ | Name | +-------+ | John | +-------+   Solution 2020-10-24 Notes:  秒了  SELECT a.name FROM employee a JOIN (SELECT managerid, COUNT(*) AS ct FROM employee GROUP BY 1) b ON a.id = b.managerid AND b.ct\u0026gt;=5  ","id":13,"section":"posts","summary":"LC 570 Managers With at Least 5 Direct Reports The Employee table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id. +------+----------+-----------+----------+ |Id |Name |Department |ManagerId | +------+----------+-----------+----------+ |101 |John |A |null | |102 |Dan |A |101 | |103 |James |A |101 | |104 |Amy |A |101 | |105 |Anne |A |101 | |106 |Ron |B |101 |","tags":["leetcode"],"title":"570 Managers With at Least 5 Direct Reports","uri":"https://foxisawesome.github.io/posts/570-managers-with-at-least-5-direct-reports/","year":"2020"},{"content":"LC 550 Game Play Analysis Iv   Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of players.\nThe query result format is in the following example:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-03-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+ | fraction | +-----------+ | 0.33 | +-----------+   Solution 2020-10-24 Notes:  秒了  SELECT ROUND( SUM(CASE WHEN DATEDIFF(lead1,event_date)=1 THEN 1 ELSE 0 END) / SUM(1) ,2) AS fraction FROM ( SELECT *, LEAD(event_date,1) OVER(PARTITION BY player_id ORDER BY event_date) AS lead1, ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS nr FROM activity ) a WHERE nr = 1  ","id":14,"section":"posts","summary":"LC 550 Game Play Analysis Iv Write an SQL query that reports the fraction of players that logged in again on the day after the day they first logged in, rounded to 2 decimal places. In other words, you need to count the number of players that logged in for at least two consecutive days starting from their first login date, then divide that number by the total number of","tags":["leetcode"],"title":"550 Game Play Analysis Iv","uri":"https://foxisawesome.github.io/posts/550-game-play-analysis-iv/","year":"2020"},{"content":"LC 511 Game Play Analysis I   Write an SQL query that reports the first login date for each player.\nThe query result format is in the following example:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+-------------+ | player_id | first_login | +-----------+-------------+ | 1 | 2016-03-01 | | 2 | 2017-06-25 | | 3 | 2016-03-02 | +-----------+-------------+   Solution 2020-10-24 Notes:  秒了  SELECT player_id, MIN(event_date) AS first_login FROM activity GROUP BY 1 ORDER BY 1  ","id":15,"section":"posts","summary":"LC 511 Game Play Analysis I Write an SQL query that reports the first login date for each player. The query result format is in the following example: Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3","tags":["leetcode"],"title":"511 Game Play Analysis I","uri":"https://foxisawesome.github.io/posts/511-game-play-analysis-i/","year":"2020"},{"content":"LC 1501 Countries You Can Safely Invest In   Write an SQL query to find the countries where this company can invest.\nReturn the result table in any order.\nThe query result format is in the following example.\nPerson table: +----+----------+--------------+ | id | name | phone_number | +----+----------+--------------+ | 3 | Jonathan | 051-1234567 | | 12 | Elvis | 051-7654321 | | 1 | Moncef | 212-1234567 | | 2 | Maroua | 212-6523651 | | 7 | Meir | 972-1234567 | | 9 | Rachel | 972-0011100 | +----+----------+--------------+ Country table: +----------+--------------+ | name | country_code | +----------+--------------+ | Peru | 051 | | Israel | 972 | | Morocco | 212 | | Germany | 049 | | Ethiopia | 251 | +----------+--------------+ Calls table: +-----------+-----------+----------+ | caller_id | callee_id | duration | +-----------+-----------+----------+ | 1 | 9 | 33 | | 2 | 9 | 4 | | 1 | 2 | 59 | | 3 | 12 | 102 | | 3 | 12 | 330 | | 12 | 3 | 5 | | 7 | 9 | 13 | | 7 | 1 | 3 | | 9 | 7 | 1 | | 1 | 7 | 7 | +-----------+-----------+----------+ Result table: +----------+ | country | +----------+ | Peru | +----------+   Solution 2020-10-22 Notes:  这个连接的好复杂。  SELECT a.name AS country FROM person p JOIN calls c ON p.id=c.caller_id OR c.callee_id=p.id JOIN country a ON a.country_code = LEFT(p.phone_number,3) GROUP BY 1 HAVING AVG(duration) \u0026gt; (SELECT AVG(duration) FROM calls)  ","id":16,"section":"posts","summary":"LC 1501 Countries You Can Safely Invest In Write an SQL query to find the countries where this company can invest. Return the result table in any order. The query result format is in the following example. Person table: +----+----------+--------------+ | id | name | phone_number | +----+----------+--------------+ | 3 | Jonathan | 051-1234567 | | 12 | Elvis | 051-7654321 | | 1 | Moncef | 212-1234567 | |","tags":["leetcode","dia_sql"],"title":"1501 Countries You Can Safely Invest In","uri":"https://foxisawesome.github.io/posts/1501-countries-you-can-safely-invest-in/","year":"2020"},{"content":"LC 1097 Game Play Analysis V   We define the install date of a player to be the first login day of that player.\nWe also define day 1 retention of some date X to be the number of players whose install date is X and they logged back in on the day right after X, divided by the number of players whose install date is X, rounded to 2 decimal places.\nWrite an SQL query that reports for each install date, the number of players that installed the game on that day and the day 1 retention.\nexample:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-03-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-01 | 0 | | 3 | 4 | 2016-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +------------+----------+----------------+ | install_dt | installs | Day1_retention | +------------+----------+----------------+ | 2016-03-01 | 2 | 0.50 | | 2017-06-25 | 1 | 0.00 | +------------+----------+----------------+   Solution 2020-10-22 Notes:  秒了  SELECT event_date AS install_dt, SUM(1) AS installs, ROUND( SUM(CASE WHEN DATEDIFF(next_log,event_date)=1 THEN 1 ELSE 0 END) / SUM(1),2) AS Day1_retention FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS nr, LEAD(event_date,1) OVER(PARTITION BY player_id ORDER BY event_date) AS next_log FROM activity ) a WHERE nr = 1 GROUP BY event_date  ","id":17,"section":"posts","summary":"LC 1097 Game Play Analysis V We define the install date of a player to be the first login day of that player. We also define day 1 retention of some date X to be the number of players whose install date is X and they logged back in on the day right after X, divided by the number of players whose install date is X, rounded to 2 decimal","tags":["leetcode"],"title":"1097 Game Play Analysis V","uri":"https://foxisawesome.github.io/posts/1097-game-play-analysis-v/","year":"2020"},{"content":"LC 647 Palindromic Substrings   Given a string, your task is to count how many palindromic substrings in this string.\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.\nInput: \u0026quot;abc\u0026quot; Output: 3 Explanation: Three palindromic strings: \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;.  Input: \u0026quot;aaa\u0026quot; Output: 6 Explanation: Six palindromic strings: \u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;aaa\u0026quot;.   Solution 2020-10-21 Notes:  dp[i][j]: if s[i:j+1] is palindromic. dp[j][i] = (s[j]==s[i]) and (i-j\u0026lt;2 or dp[j+1][i-1])  class Solution: def countSubstrings(self, s: str) -\u0026gt; int: n = len(s) dp = [[0] * n for _ in range(n)] c = 0 for i in range(n): for j in range(i): dp[j][i] = (s[j]==s[i]) and (i-j\u0026lt;2 or dp[j+1][i-1]) if dp[j][i]: c += 1 dp[i][i] = 1 c += 1 return c # Time O(N^2) # Space O(N^2)   expand around the corner  class Solution: def countSubstrings(self, s: str) -\u0026gt; int: n = len(s) ans = 0 for center in range(2*n-1): l = center // 2 r = l + center % 2 while l \u0026gt;= 0 and r \u0026lt; n and s[l]==s[r]: ans += 1 l -= 1 r += 1 return ans  ","id":18,"section":"posts","summary":"LC 647 Palindromic Substrings   Given a string, your task is to count how many palindromic substrings in this string.\nThe substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.\nInput: \u0026quot;abc\u0026quot; Output: 3 Explanation: Three palindromic strings: \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;.  Input: \u0026quot;aaa\u0026quot; Output: 6 Explanation: Six palindromic strings: \u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;aa\u0026quot;, \u0026quot;aaa\u0026quot;.   Solution 2020-10-21 Notes:  dp[i][j]: if s[i:j+1] is palindromic.","tags":["leetcode","dp","dia"],"title":"647 Palindromic Substrings","uri":"https://foxisawesome.github.io/posts/647-palindromic-substrings/","year":"2020"},{"content":"LC 1353 Maximum Number of Events That Can Be Attended   Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.\nYou can attend an event i at any day d where startTimei \u0026lt;= d \u0026lt;= endTimei. Notice that you can only attend one event at any time d.\nReturn the maximum number of events you can attend.\nInput: events = [[1,2],[2,3],[3,4]] Output: 3 Explanation: You can attend all the three events. One way to attend them all is as shown. Attend the first event on day 1. Attend the second event on day 2. Attend the third event on day 3.  Example 2:\nInput: events= [[1,2],[2,3],[3,4],[1,2]] Output: 4  Example 3:\nInput: events = [[1,4],[4,4],[2,2],[3,4],[1,1]] Output: 4  Example 4:\nInput: events = [[1,100000]] Output: 1   Solution 2020-10-21 Notes:  这题思路很简单但是会TLE。  class Solution: def maxEvents(self, events: List[List[int]]) -\u0026gt; int: events.sort(key=lambda x:(x[1], x[0])) used_day = set() for e in events: for d in range(e[0], e[1] + 1): if d not in used_day: used_day.add(d) break return len(used_day) # Time O(E*D) # Space O(E*D)  大神的解是我见到唯一能过的。speechless。\ndef maxEvents(self, A): A.sort(reverse=1) h = [] res = d = 0 while A or h: if not h: d = A[-1][0] while A and A[-1][0] \u0026lt;= d: heapq.heappush(h, A.pop()[1]) heapq.heappop(h) res += 1 d += 1 while h and h[0] \u0026lt; d: heapq.heappop(h) return res  ","id":19,"section":"posts","summary":"LC 1353 Maximum Number of Events That Can Be Attended Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi. You can attend an event i at any day d where startTimei \u0026lt;= d \u0026lt;= endTimei. Notice that you can only attend one event at any time d. Return the maximum number of events you can attend. Input: events =","tags":["leetcode","greedy","dia"],"title":"1353 Maximum Number of Events That Can Be Attended","uri":"https://foxisawesome.github.io/posts/1353-maximum-number-of-events-that-can-be-attended/","year":"2020"},{"content":"LC 901 Online Stock Span   Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock\u0026rsquo;s price for the current day.\nThe span of the stock\u0026rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today\u0026rsquo;s price.\nFor example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].\nInput: [\u0026quot;StockSpanner\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;,\u0026quot;next\u0026quot;], [[],[100],[80],[60],[70],[60],[75],[85]] Output: [null,1,1,1,2,1,4,6] Explanation: First, S = StockSpanner() is initialized. Then: S.next(100) is called and returns 1, S.next(80) is called and returns 1, S.next(60) is called and returns 1, S.next(70) is called and returns 2, S.next(60) is called and returns 1, S.next(75) is called and returns 4, S.next(85) is called and returns 6.   Solution 2020-10-21 Notes:  典型的monotonic stack的题。brute force 会TLE。  class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u0026gt; int: c = 1 while self.stack and price \u0026gt;= self.stack[-1][0]: c += self.stack.pop()[1] self.stack.append((price,c)) return c # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price) # Time O(N) # Space O(N)  ","id":20,"section":"posts","summary":"LC 901 Online Stock Span Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock\u0026rsquo;s price for the current day. The span of the stock\u0026rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today\u0026rsquo;s price. For example, if the","tags":["leetcode","monotonic","dia"],"title":"901 Online Stock Span","uri":"https://foxisawesome.github.io/posts/901-online-stock-span/","year":"2020"},{"content":"LC 152 Maximum Product Subarray   Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\nInput: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6.   Solution 2020-10-21 Notes:  最大值可能来自三种来源：nums[i], prev_max X nums[i], prev_min X numi[i] 优化了的dp。  class Solution: def maxProduct(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = max_ = min_ = nums[0] for i in range(1,n): prev_max, prev_min = max_, min_ max_ = max(nums[i], prev_max*nums[i], prev_min*nums[i]) min_ = min(nums[i], prev_min*nums[i], prev_max*nums[i]) ans = max(ans, max_) return ans # Time O(N) # Space O(1)  dp 的最初形式。\nclass Solution: def maxProduct(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) max_ = [0]*n min_ = [0]*n ans = max_[0] = min_[0] = nums[0] for i in range(1,n): max_[i] = max(nums[i], max_[i-1]*nums[i], min_[i-1]*nums[i]) min_[i] = min(nums[i], min_[i-1]*nums[i], max_[i-1]*nums[i]) ans = max(ans, max_[i]) return ans # Time O(N) # Space O(N)  ","id":21,"section":"posts","summary":"LC 152 Maximum Product Subarray Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Solution 2020-10-21 Notes: 最大值可能来自三种来源：nums[i], prev_max X nums[i], prev_min X numi[i] 优化了","tags":["leetcode","dp"],"title":"152 Maximum Product Subarray","uri":"https://foxisawesome.github.io/posts/152-maximum-product-subarray/","year":"2020"},{"content":"LC 1398 Customers Who Bought Products a and B but Not C   Write an SQL query to report the customer_id and customer_name of customers who bought products \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo; but did not buy the product \u0026ldquo;C\u0026rdquo; since we want to recommend them buy this product.\nReturn the result table ordered by customer_id.\n Solution 2020-10-21 Notes:  秒了  SELECT a.* FROM customers a JOIN ( SELECT * FROM orders GROUP BY customer_id HAVING SUM(CASE WHEN product_name='A' THEN 1 ELSE 0 END) \u0026gt; 0 AND SUM(CASE WHEN product_name='B' THEN 1 ELSE 0 END) \u0026gt; 0 AND SUM(CASE WHEN product_name='C' THEN 1 ELSE 0 END) = 0 ) b ON a.customer_id = b.customer_id ORDER BY customer_id  ","id":22,"section":"posts","summary":"LC 1398 Customers Who Bought Products a and B but Not C Write an SQL query to report the customer_id and customer_name of customers who bought products \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo; but did not buy the product \u0026ldquo;C\u0026rdquo; since we want to recommend them buy this product. Return the result table ordered by customer_id. Solution 2020-10-21 Notes: 秒了 SELECT a.* FROM customers a JOIN ( SELECT * FROM orders GROUP BY","tags":["leetcode"],"title":"1398 Customers Who Bought Products a and B but Not C","uri":"https://foxisawesome.github.io/posts/1398-customers-who-bought-products-a-and-b-but-not-c/","year":"2020"},{"content":"LC 1308 Running Total for Different Genders   Write an SQL query to find the total score for each gender at each day.\nOrder the result table by gender and day\nThe query result format is in the following example:\nScores table: +-------------+--------+------------+--------------+ | player_name | gender | day | score_points | +-------------+--------+------------+--------------+ | Aron | F | 2020-01-01 | 17 | | Alice | F | 2020-01-07 | 23 | | Bajrang | M | 2020-01-07 | 7 | | Khali | M | 2019-12-25 | 11 | | Slaman | M | 2019-12-30 | 13 | | Joe | M | 2019-12-31 | 3 | | Jose | M | 2019-12-18 | 2 | | Priya | F | 2019-12-31 | 23 | | Priyanka | F | 2019-12-30 | 17 | +-------------+--------+------------+--------------+ Result table: +--------+------------+-------+ | gender | day | total | +--------+------------+-------+ | F | 2019-12-30 | 17 | | F | 2019-12-31 | 40 | | F | 2020-01-01 | 57 | | F | 2020-01-07 | 80 | | M | 2019-12-18 | 2 | | M | 2019-12-25 | 13 | | M | 2019-12-30 | 26 | | M | 2019-12-31 | 29 | | M | 2020-01-07 | 36 | +--------+------------+-------+   Solution 2020-10-21 Notes:  秒了  SELECT gender, day, SUM(score_points) OVER(PARTITION BY gender ORDER BY day) AS total FROM scores ORDER BY 1,2  ","id":23,"section":"posts","summary":"LC 1308 Running Total for Different Genders Write an SQL query to find the total score for each gender at each day. Order the result table by gender and day The query result format is in the following example: Scores table: +-------------+--------+------------+--------------+ | player_name | gender | day | score_points | +-------------+--------+------------+--------------+ | Aron | F | 2020-01-01 | 17 | | Alice | F | 2020-01-07 | 23 |","tags":["leetcode"],"title":"1308 Running Total for Different Genders","uri":"https://foxisawesome.github.io/posts/1308-running-total-for-different-genders/","year":"2020"},{"content":"LC 1393 Capital Gainloss   Write an SQL query to report the Capital gain/loss for each stock.\nThe capital gain/loss of a stock is total gain or loss after buying and selling the stock one or many times.\nReturn the result table in any order.\nThe query result format is in the following example:\nStocks table: +---------------+-----------+---------------+--------+ | stock_name | operation | operation_day | price | +---------------+-----------+---------------+--------+ | Leetcode | Buy | 1 | 1000 | | Corona Masks | Buy | 2 | 10 | | Leetcode | Sell | 5 | 9000 | | Handbags | Buy | 17 | 30000 | | Corona Masks | Sell | 3 | 1010 | | Corona Masks | Buy | 4 | 1000 | | Corona Masks | Sell | 5 | 500 | | Corona Masks | Buy | 6 | 1000 | | Handbags | Sell | 29 | 7000 | | Corona Masks | Sell | 10 | 10000 | +---------------+-----------+---------------+--------+ Result table: +---------------+-------------------+ | stock_name | capital_gain_loss | +---------------+-------------------+ | Corona Masks | 9500 | | Leetcode | 8000 | | Handbags | -23000 | +---------------+-------------------+   Solution 2020-10-21 Notes:  秒了  SELECT stock_name, SUM(CASE WHEN operation='buy' THEN -price ELSE price END) AS capital_gain_loss FROM stocks GROUP BY 1 ORDER BY 1  ","id":24,"section":"posts","summary":"LC 1393 Capital Gainloss Write an SQL query to report the Capital gain/loss for each stock. The capital gain/loss of a stock is total gain or loss after buying and selling the stock one or many times. Return the result table in any order. The query result format is in the following example: Stocks table: +---------------+-----------+---------------+--------+ | stock_name | operation | operation_day | price | +---------------+-----------+---------------+--------+ | Leetcode | Buy","tags":["leetcode"],"title":"1393 Capital Gainloss","uri":"https://foxisawesome.github.io/posts/1393-capital-gainloss/","year":"2020"},{"content":"LC 1445 Apples Oranges   Write an SQL query to report the difference between number of apples and oranges sold each day.\nReturn the result table ordered by sale_date in format (\u0026lsquo;YYYY-MM-DD\u0026rsquo;).\nThe query result format is in the following example:\nSales table: +------------+------------+-------------+ | sale_date | fruit | sold_num | +------------+------------+-------------+ | 2020-05-01 | apples | 10 | | 2020-05-01 | oranges | 8 | | 2020-05-02 | apples | 15 | | 2020-05-02 | oranges | 15 | | 2020-05-03 | apples | 20 | | 2020-05-03 | oranges | 0 | | 2020-05-04 | apples | 15 | | 2020-05-04 | oranges | 16 | +------------+------------+-------------+ Result table: +------------+--------------+ | sale_date | diff | +------------+--------------+ | 2020-05-01 | 2 | | 2020-05-02 | 0 | | 2020-05-03 | 20 | | 2020-05-04 | -1 | +------------+--------------+   Solution 2020-10-21 Notes:  秒了  SELECT sale_date, SUM(CASE WHEN fruit='apples' THEN sold_num ELSE -sold_num END) AS diff FROM sales GROUP BY 1 ORDER BY 1  ","id":25,"section":"posts","summary":"LC 1445 Apples Oranges Write an SQL query to report the difference between number of apples and oranges sold each day. Return the result table ordered by sale_date in format (\u0026lsquo;YYYY-MM-DD\u0026rsquo;). The query result format is in the following example: Sales table: +------------+------------+-------------+ | sale_date | fruit | sold_num | +------------+------------+-------------+ | 2020-05-01 | apples | 10 | | 2020-05-01 | oranges | 8 | | 2020-05-02 | apples |","tags":["leetcode"],"title":"1445 Apples Oranges","uri":"https://foxisawesome.github.io/posts/1445-apples-oranges/","year":"2020"},{"content":"LC 1270 All People Report to the Given Manager   Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company.\nThe indirect relation between managers will not exceed 3 managers as the company is small.\nReturn result table in any order without duplicates.\nThe query result format is in the following example:\nEmployees table: +-------------+---------------+------------+ | employee_id | employee_name | manager_id | +-------------+---------------+------------+ | 1 | Boss | 1 | | 3 | Alice | 3 | | 2 | Bob | 1 | | 4 | Daniel | 2 | | 7 | Luis | 4 | | 8 | Jhon | 3 | | 9 | Angela | 8 | | 77 | Robert | 1 | +-------------+---------------+------------+ Result table: +-------------+ | employee_id | +-------------+ | 2 | | 77 | | 4 | | 7 | +-------------+   Solution 2020-10-21 Notes:  三张表的self join。 table b is bottom level \u0026lt;\u0026mdash;- table a \u0026lt;\u0026mdash;- table c  SELECT DISTINCT b.employee_id FROM employees a JOIN employees b ON b.manager_id = a.employee_id JOIN employees c ON a.manager_id = c.employee_id AND c.manager_id = 1 WHERE b.employee_id != 1 ;  ","id":26,"section":"posts","summary":"LC 1270 All People Report to the Given Manager Write an SQL query to find employee_id of all employees that directly or indirectly report their work to the head of the company. The indirect relation between managers will not exceed 3 managers as the company is small. Return result table in any order without duplicates. The query result format is in the following example: Employees table: +-------------+---------------+------------+ | employee_id |","tags":["leetcode"],"title":"1270 All People Report to the Given Manager","uri":"https://foxisawesome.github.io/posts/1270-all-people-report-to-the-given-manager/","year":"2020"},{"content":"LC 383 Ransom Note   Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\nEach letter in the magazine string can only be used once in your ransom note.\nInput: ransomNote = \u0026quot;a\u0026quot;, magazine = \u0026quot;b\u0026quot; Output: false   Solution 2020-10-19 Notes:  edge case is acutally hard to get them right in the first place  class Solution: def canConstruct(self, ransomNote: str, magazine: str) -\u0026gt; bool: if not ransomNote: return True if not magazine: return False d = collections.Counter(magazine) for j in list(ransomNote): if d[j] \u0026gt; 0: d[j] -= 1 else: return False return True # Time O(M+N) # Space O(1)  ","id":27,"section":"posts","summary":"LC 383 Ransom Note   Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.\nEach letter in the magazine string can only be used once in your ransom note.\nInput: ransomNote = \u0026quot;a\u0026quot;, magazine = \u0026quot;b\u0026quot; Output: false   Solution 2020-10-19 Notes:  edge case is acutally hard to get them right in the first place  class Solution: def canConstruct(self, ransomNote: str, magazine: str) -\u0026gt; bool: if not ransomNote: return True if not magazine: return False d = collections.","tags":["leetcode","hashtable"],"title":"383 Ransom Note","uri":"https://foxisawesome.github.io/posts/383-ransom-note/","year":"2020"},{"content":"LC 682 Baseball Game   You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores.\nAt the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:\n An integer x - Record a new score of x. \u0026quot;+\u0026quot; - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores. \u0026quot;D\u0026quot; - Record a new score that is double the previous score. It is guaranteed there will always be a previous score. \u0026quot;C\u0026quot; - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score.  Return the sum of all the scores on the record.\nInput: ops = [\u0026quot;5\u0026quot;,\u0026quot;-2\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;] Output: 27 Explanation: \u0026quot;5\u0026quot; - Add 5 to the record, record is now [5]. \u0026quot;-2\u0026quot; - Add -2 to the record, record is now [5, -2]. \u0026quot;4\u0026quot; - Add 4 to the record, record is now [5, -2, 4]. \u0026quot;C\u0026quot; - Invalidate and remove the previous score, record is now [5, -2]. \u0026quot;D\u0026quot; - Add 2 * -2 = -4 to the record, record is now [5, -2, -4]. \u0026quot;9\u0026quot; - Add 9 to the record, record is now [5, -2, -4, 9]. \u0026quot;+\u0026quot; - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5]. \u0026quot;+\u0026quot; - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14]. The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.   Solution 2020-10-19 Notes:  秒了  class Solution: def calPoints(self, ops: List[str]) -\u0026gt; int: ans = [] for op in ops: if op[-1].isdigit(): ans.append(int(op)) elif op=='+': ans.append(sum(ans[-2:])) elif op=='D': ans.append(ans[-1]*2) elif op=='C': ans.pop() print(ans) return sum(ans) # Time O(N) # Space O(N)  ","id":28,"section":"posts","summary":"LC 682 Baseball Game You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores. At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:","tags":["leetcode","string"],"title":"682 Baseball Game","uri":"https://foxisawesome.github.io/posts/682-baseball-game/","year":"2020"},{"content":"LC 1167 Minimum Cost to Connect Sticks   You have some number of sticks with positive integer lengths. These lengths are given as an array sticks, where sticks[i] is the length of the ith stick.\nYou can connect any two sticks of lengths x and y into one stick by paying a cost of x + y. You must connect all the sticks until there is only one stick remaining.\nReturn the minimum cost of connecting all the given sticks into one stick in this way.\nInput: sticks = [2,4,3] Output: 14 Explanation: You start with sticks = [2,4,3]. 1. Combine sticks 2 and 3 for a cost of 2 + 3 = 5. Now you have sticks = [5,4]. 2. Combine sticks 5 and 4 for a cost of 5 + 4 = 9. Now you have sticks = [9]. There is only one stick left, so you are done. The total cost is 5 + 9 = 14.   Solution 2020-10-19 Notes:  很容易就想到了用 priority queue的做法从题目的example initiate heap by heapq.heapify() Heapq.heappop() give的min  class Solution: def connectSticks(self, sticks: List[int]) -\u0026gt; int: n = len(sticks) ans = 0 if n == 1: return ans heapq.heapify(sticks) while len(sticks) \u0026gt; 1: t = heapq.heappop(sticks) + heapq.heappop(sticks) heapq.heappush(sticks,t) ans += t return ans # Time O(NlogN) # Space O(1)  ","id":29,"section":"posts","summary":"LC 1167 Minimum Cost to Connect Sticks You have some number of sticks with positive integer lengths. These lengths are given as an array sticks, where sticks[i] is the length of the ith stick. You can connect any two sticks of lengths x and y into one stick by paying a cost of x + y. You must connect all the sticks until there is only one stick remaining. Return","tags":["leetcode","heap"],"title":"1167 Minimum Cost to Connect Sticks","uri":"https://foxisawesome.github.io/posts/1167-minimum-cost-to-connect-sticks/","year":"2020"},{"content":"LC 1083 Sales Analysis II   Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table.\nThe query result format is in the following example:\nProduct table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone | 1400 | +------------+--------------+------------+ Sales table: +-----------+------------+----------+------------+----------+-------+ | seller_id | product_id | buyer_id | sale_date | quantity | price | +-----------+------------+----------+------------+----------+-------+ | 1 | 1 | 1 | 2019-01-21 | 2 | 2000 | | 1 | 2 | 2 | 2019-02-17 | 1 | 800 | | 2 | 1 | 3 | 2019-06-02 | 1 | 800 | | 3 | 3 | 3 | 2019-05-13 | 2 | 2800 | +-----------+------------+----------+------------+----------+-------+ Result table: +-------------+ | buyer_id | +-------------+ | 1 | +-------------+ The buyer with id 1 bought an S8 but didn't buy an iPhone. The buyer with id 3 bought both.   Solution 2020-10-19 Notes:  好难的easy 题！  SELECT s.buyer_id FROM Sales AS s INNER JOIN Product AS p ON s.product_id = p.product_id GROUP BY s.buyer_id HAVING SUM(CASE WHEN p.product_name = 'S8' THEN 1 ELSE 0 END) \u0026gt; 0 AND SUM(CASE WHEN p.product_name = 'iPhone' THEN 1 ELSE 0 END) = 0;  ","id":30,"section":"posts","summary":"LC 1083 Sales Analysis II Write an SQL query that reports the buyers who have bought S8 but not iPhone. Note that S8 and iPhone are products present in the Product table. The query result format is in the following example: Product table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone","tags":["leetcode","dia_sql"],"title":"1083 Sales Analysis II","uri":"https://foxisawesome.github.io/posts/1083-sales-analysis-ii/","year":"2020"},{"content":"LC 1495 Friendly Movies Streamed Last Month   Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.\nReturn the result table in any order.\n Solution 2020-10-19 Notes: select distinct title from content a join TVProgram b on a.content_id = b.content_id where a.kids_content = 'Y' and a.content_type = 'Movies' and month(b.program_date) = 6  ","id":31,"section":"posts","summary":"LC 1495 Friendly Movies Streamed Last Month   Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.\nReturn the result table in any order.\n Solution 2020-10-19 Notes: select distinct title from content a join TVProgram b on a.content_id = b.content_id where a.kids_content = 'Y' and a.content_type = 'Movies' and month(b.program_date) = 6  ","tags":["leetcode"],"title":"1495 Friendly Movies Streamed Last Month","uri":"https://foxisawesome.github.io/posts/1495-friendly-movies-streamed-last-month/","year":"2020"},{"content":"LC 1076 Project Employees II   Write an SQL query that reports all the projects that have the most employees.\nThe query result format is in the following example:\nProject table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Result table: +-------------+ | project_id | +-------------+ | 1 | +-------------+ The first project has 3 employees while the second one has 2.   Solution 2020-10-19 Notes:  两种方法都要背熟 sol. 1  SELECT project_id FROM project GROUP BY project_id HAVING COUNT(employee_id) = (SELECT COUNT(employee_id) FROM project GROUP BY project_id ORDER BY 1 DESC LIMIT 1)   sol. 2  SELECT project_id FROM ( SELECT *, RANK() OVER(ORDER BY COUNT(employee_id) DESC) AS rk FROM project GROUP BY project_id ) a WHERE rk = 1  ","id":32,"section":"posts","summary":"LC 1076 Project Employees II Write an SQL query that reports all the projects that have the most employees. The query result format is in the following example: Project table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Result table: +-------------+ | project_id | +-------------+","tags":["leetcode","dia_sql"],"title":"1076 Project Employees II","uri":"https://foxisawesome.github.io/posts/1076-project-employees-ii/","year":"2020"},{"content":"LC 619 Biggest Single Number   Table my_numbers contains many numbers in column num including duplicated ones. Can you write a SQL query to find the biggest number, which only appears once\n Solution 2020-10-19 Notes: # 1 SELECT MAX(a.num) AS num FROM ( SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1 ) a #2 SELECT MAX(num) AS num FROM ( SELECT *, COUNT(*) OVER(PARTITION BY num) AS ct FROM my_numbers ) a WHERE ct = 1  ","id":33,"section":"posts","summary":"LC 619 Biggest Single Number   Table my_numbers contains many numbers in column num including duplicated ones. Can you write a SQL query to find the biggest number, which only appears once\n Solution 2020-10-19 Notes: # 1 SELECT MAX(a.num) AS num FROM ( SELECT num FROM my_numbers GROUP BY num HAVING COUNT(num) = 1 ) a #2 SELECT MAX(num) AS num FROM ( SELECT *, COUNT(*) OVER(PARTITION BY num) AS ct FROM my_numbers ) a WHERE ct = 1  ","tags":["leetcode"],"title":"619 Biggest Single Number","uri":"https://foxisawesome.github.io/posts/619-biggest-single-number/","year":"2020"},{"content":"LC 196 Delete Duplicate Emails   Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\n+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows:\n+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+   Solution 2020-10-19 Notes: delete b from person a, person b where a.email = b.email and b.id \u0026gt; a.id ;  ","id":34,"section":"posts","summary":"LC 196 Delete Duplicate Emails   Write a SQL query to delete all duplicate email entries in a table named Person, keeping only unique emails based on its smallest Id.\n+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id is the primary key column for this table.  For example, after running your query, the above Person table should have the following rows:","tags":["leetcode","dia"],"title":"196 Delete Duplicate Emails","uri":"https://foxisawesome.github.io/posts/196-delete-duplicate-emails/","year":"2020"},{"content":"LC 597 Friend Requests I Overall Acceptance Rate   Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.\n Solution 2020-10-19 Notes: SELECT round(ifnull( (select count(*) from (select distinct requester_id, accepter_id from request_accepted) a) / (select count(*) from (select distinct sender_id, send_to_id from friend_request) b) ,0),2) as accept_rate  ","id":35,"section":"posts","summary":"LC 597 Friend Requests I Overall Acceptance Rate   Write a query to find the overall acceptance rate of requests rounded to 2 decimals, which is the number of acceptance divide the number of requests.\n Solution 2020-10-19 Notes: SELECT round(ifnull( (select count(*) from (select distinct requester_id, accepter_id from request_accepted) a) / (select count(*) from (select distinct sender_id, send_to_id from friend_request) b) ,0),2) as accept_rate  ","tags":["leetcode"],"title":"597 Friend Requests I Overall Acceptance Rate","uri":"https://foxisawesome.github.io/posts/597-friend-requests-i-overall-acceptance-rate/","year":"2020"},{"content":"LC 584 Find Customer Referee   Write a query to return the list of customers NOT referred by the person with id \u0026lsquo;2\u0026rsquo;.\n Solution 2020-10-19 Notes: SELECT name FROM customer WHERE referee_id != '2' OR referee_id IS NULL  ","id":36,"section":"posts","summary":"LC 584 Find Customer Referee   Write a query to return the list of customers NOT referred by the person with id \u0026lsquo;2\u0026rsquo;.\n Solution 2020-10-19 Notes: SELECT name FROM customer WHERE referee_id != '2' OR referee_id IS NULL  ","tags":["leetcode"],"title":"584 Find Customer Referee","uri":"https://foxisawesome.github.io/posts/584-find-customer-referee/","year":"2020"},{"content":"LC 1148 Article Views I   Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id.\nThe query result format is in the following example:\nViews table: +------------+-----------+-----------+------------+ | article_id | author_id | viewer_id | view_date | +------------+-----------+-----------+------------+ | 1 | 3 | 5 | 2019-08-01 | | 1 | 3 | 6 | 2019-08-02 | | 2 | 7 | 7 | 2019-08-01 | | 2 | 7 | 6 | 2019-08-02 | | 4 | 7 | 1 | 2019-07-22 | | 3 | 4 | 4 | 2019-07-21 | | 3 | 4 | 4 | 2019-07-21 | +------------+-----------+-----------+------------+ Result table: +------+ | id | +------+ | 4 | | 7 | +------+   Solution 2020-10-19 Notes:  秒了  SELECT DISTINCT author_id AS id FROM views WHERE author_id = viewer_id ORDER BY 1  ","id":37,"section":"posts","summary":"LC 1148 Article Views I Write an SQL query to find all the authors that viewed at least one of their own articles, sorted in ascending order by their id. The query result format is in the following example: Views table: +------------+-----------+-----------+------------+ | article_id | author_id | viewer_id | view_date | +------------+-----------+-----------+------------+ | 1 | 3 | 5 | 2019-08-01 | | 1 | 3 | 6 | 2019-08-02 |","tags":["leetcode"],"title":"1148 Article Views I","uri":"https://foxisawesome.github.io/posts/1148-article-views-i/","year":"2020"},{"content":"LC 1050 Actors and Directors Who Cooperated at Least Three Times   Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor have cooperated with the director at least 3 times.\nActorDirector table: +-------------+-------------+-------------+ | actor_id | director_id | timestamp | +-------------+-------------+-------------+ | 1 | 1 | 0 | | 1 | 1 | 1 | | 1 | 1 | 2 | | 1 | 2 | 3 | | 1 | 2 | 4 | | 2 | 1 | 5 | | 2 | 1 | 6 | +-------------+-------------+-------------+ Result table: +-------------+-------------+ | actor_id | director_id | +-------------+-------------+ | 1 | 1 | +-------------+-------------+ The only pair is (1, 1) where they cooperated exactly 3 times.   Solution 2020-10-19 Notes:  秒了  SELECT actor_id, director_id FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY actor_id, director_id) AS nr FROM actordirector ) a WHERE nr = 3  ","id":38,"section":"posts","summary":"LC 1050 Actors and Directors Who Cooperated at Least Three Times Write a SQL query for a report that provides the pairs (actor_id, director_id) where the actor have cooperated with the director at least 3 times. ActorDirector table: +-------------+-------------+-------------+ | actor_id | director_id | timestamp | +-------------+-------------+-------------+ | 1 | 1 | 0 | | 1 | 1 | 1 | | 1 | 1 | 2 | | 1","tags":["leetcode"],"title":"1050 Actors and Directors Who Cooperated at Least Three Times","uri":"https://foxisawesome.github.io/posts/1050-actors-and-directors-who-cooperated-at-least-three-times/","year":"2020"},{"content":"LC 183 Customers Who Never Order   Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything.\n Solution 2020-10-19 Notes:  秒了  SELECT name AS customers FROM customers WHERE id NOT IN (SELECT customerID FROM orders)  ","id":39,"section":"posts","summary":"LC 183 Customers Who Never Order Suppose that a website contains two tables, the Customers table and the Orders table. Write a SQL query to find all customers who never order anything. Solution 2020-10-19 Notes: 秒了 SELECT name AS customers FROM customers WHERE id NOT IN (SELECT customerID FROM orders)","tags":["leetcode"],"title":"183 Customers Who Never Order","uri":"https://foxisawesome.github.io/posts/183-customers-who-never-order/","year":"2020"},{"content":"LC 512 Game Play Analysis II   Write a SQL query that reports the device that is first logged in for each player.\nThe query result format is in the following example:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 2 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+-----------+ | player_id | device_id | +-----------+-----------+ | 1 | 2 | | 2 | 3 | | 3 | 1 | +-----------+-----------+   Solution 2020-10-19 Notes:  秒了  SELECT player_id, device_id FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY player_id ORDER BY event_date) AS nr FROM activity ) a WHERE nr = 1  ","id":40,"section":"posts","summary":"LC 512 Game Play Analysis II Write a SQL query that reports the device that is first logged in for each player. The query result format is in the following example: Activity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 2 | 3 | 2017-06-25 | 1","tags":["leetcode"],"title":"512 Game Play Analysis II","uri":"https://foxisawesome.github.io/posts/512-game-play-analysis-ii/","year":"2020"},{"content":"LC 1290 Convert Binary Number in a Linked List to Integer   Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\nReturn the decimal value of the number in the linked list.\nInput: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10   Solution 2020-10-19 Notes:  虽然秒了，但距离最优解的距离如下：  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def getDecimalValue(self, head: ListNode) -\u0026gt; int: if not head: return stack = [] while head: stack.append(head.val) head = head.next c, ans = 0, 0 while stack: ans += stack.pop() * 2**(c) c += 1 return ans # Time O(N) # Space O(N)   最优解：  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def getDecimalValue(self, head: ListNode) -\u0026gt; int: ans = 0 while head: ans = 2*ans + head.val head = head.next return ans # Time O(N) # Space O(1)  ","id":41,"section":"posts","summary":"LC 1290 Convert Binary Number in a Linked List to Integer Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5)","tags":["leetcode","linkedlist"],"title":"1290 Convert Binary Number in a Linked List to Integer","uri":"https://foxisawesome.github.io/posts/1290-convert-binary-number-in-a-linked-list-to-integer/","year":"2020"},{"content":"LC 1086 High Five   Given a list of scores of different students, return the average score of each student\u0026rsquo;s top five scores in the order of each student\u0026rsquo;s id.\nEach entry items[i] has items[i][0] the student\u0026rsquo;s id, and items[i][1] the student\u0026rsquo;s score. The average score is calculated using integer division.\n Solution 2020-10-19 Notes:  秒了  class Solution: def highFive(self, items: List[List[int]]) -\u0026gt; List[List[int]]: d = collections.defaultdict(list) for i in items: d[i[0]].append(i[1]) ans = [] for k, v in d.items(): score = [0]*2 score[0] = k v.sort(reverse=True) score[1] = sum(v[:5])//5 ans.append(score) return ans # Time O(NlogN) # Space O(N)  ","id":42,"section":"posts","summary":"LC 1086 High Five Given a list of scores of different students, return the average score of each student\u0026rsquo;s top five scores in the order of each student\u0026rsquo;s id. Each entry items[i] has items[i][0] the student\u0026rsquo;s id, and items[i][1] the student\u0026rsquo;s score. The average score is calculated using integer division. Solution 2020-10-19 Notes: 秒了 class Solution: def highFive(self, items: List[List[int]]) -\u0026gt; List[List[int]]: d = collections.defaultdict(list) for i in items:","tags":["leetcode","array"],"title":"1086 High Five","uri":"https://foxisawesome.github.io/posts/1086-high-five/","year":"2020"},{"content":"LC 1252 Cells With Odd Values in a Matrix   Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.\nReturn the number of cells with odd values in the matrix after applying the increment to all indices.\n Solution 2020-10-19 Notes:  很巧的一个小题。odd_row 和 odd_col 分开处理。用bit operator: 1 ^ 1 = 0  class Solution: def oddCells(self, n: int, m: int, indices: List[List[int]]) -\u0026gt; int: odd_row, odd_col = [False] * n, [False] * m for i, j in indices: odd_row[i] ^= True odd_col[j] ^= True return sum(odd_row)*m + sum(odd_col)*n - 2*sum(odd_row)*sum(odd_col) # Time O(L+M+N) # Space O(M+N)  ","id":43,"section":"posts","summary":"LC 1252 Cells With Odd Values in a Matrix Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1. Return the number of cells with odd values in the matrix after applying the increment to all","tags":["leetcode","matrix","dia"],"title":"1252 Cells With Odd Values in a Matrix","uri":"https://foxisawesome.github.io/posts/1252-cells-with-odd-values-in-a-matrix/","year":"2020"},{"content":"LC 1021 Remove Outermost Parentheses   A valid parentheses string is either empty (\u0026quot;\u0026quot;), \u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \u0026quot;\u0026quot;, \u0026quot;()\u0026quot;, \u0026quot;(())()\u0026quot;, and \u0026quot;(()(()))\u0026quot; are all valid parentheses strings.\nA valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings.\nReturn S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.\nInput: \u0026quot;(()())(())\u0026quot; Output: \u0026quot;()()()\u0026quot; Explanation: The input string is \u0026quot;(()())(())\u0026quot;, with primitive decomposition \u0026quot;(()())\u0026quot; + \u0026quot;(())\u0026quot;. After removing outer parentheses of each part, this is \u0026quot;()()\u0026quot; + \u0026quot;()\u0026quot; = \u0026quot;()()()\u0026quot;.   Solution 2020-10-19 Notes:  思路对了 但是程序效率还有点低。  class Solution: def removeOuterParentheses(self, S: str) -\u0026gt; str: if not S: return \u0026quot;\u0026quot; stack = [] l, r = 0, 0 ans = '' for i,s in enumerate(S): if s == '(': stack.append(s) elif s ==')': stack.pop() if len(stack) == 0: ans += S[l+1:r] l = i+1 r += 1 return ans # Time O(N) # Space O(N)  ","id":44,"section":"posts","summary":"LC 1021 Remove Outermost Parentheses A valid parentheses string is either empty (\u0026quot;\u0026quot;), \u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \u0026quot;\u0026quot;, \u0026quot;()\u0026quot;, \u0026quot;(())()\u0026quot;, and \u0026quot;(()(()))\u0026quot; are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S","tags":["leetcode","stack"],"title":"1021 Remove Outermost Parentheses","uri":"https://foxisawesome.github.io/posts/1021-remove-outermost-parentheses/","year":"2020"},{"content":"LC 1322 Ads Performance   Write an SQL query to find the ctr of each Ad.\nRound ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie.\nThe query result format is in the following example:\nAds table: +-------+---------+---------+ | ad_id | user_id | action | +-------+---------+---------+ | 1 | 1 | Clicked | | 2 | 2 | Clicked | | 3 | 3 | Viewed | | 5 | 5 | Ignored | | 1 | 7 | Ignored | | 2 | 7 | Viewed | | 3 | 5 | Clicked | | 1 | 4 | Viewed | | 2 | 11 | Viewed | | 1 | 2 | Clicked | +-------+---------+---------+ Result table: +-------+-------+ | ad_id | ctr | +-------+-------+ | 1 | 66.67 | | 3 | 50.00 | | 2 | 33.33 | | 5 | 0.00 | +-------+-------+ for ad_id = 1, ctr = (2/(2+1)) * 100 = 66.67   Solution 2020-10-18 Notes:  秒了！ 看7月的时候首刷的提交还build了好几层sub-querry\u0026hellip;  SELECT ad_id, ROUND( IFNULL( SUM(CASE WHEN action='Clicked' THEN 1 ELSE 0 END) / SUM(CASE WHEN action!='Ignored' THEN 1 ELSE 0 END)*100 ,0) ,2)AS ctr FROM ads GROUP BY 1 ORDER BY 2 DESC, 1  ","id":45,"section":"posts","summary":"LC 1322 Ads Performance Write an SQL query to find the ctr of each Ad. Round ctr to 2 decimal points. Order the result table by ctr in descending order and by ad_id in ascending order in case of a tie. The query result format is in the following example: Ads table: +-------+---------+---------+ | ad_id | user_id | action | +-------+---------+---------+ | 1 | 1 | Clicked | | 2","tags":["leetcode"],"title":"1322 Ads Performance","uri":"https://foxisawesome.github.io/posts/1322-ads-performance/","year":"2020"},{"content":"LC 1543 Fix Product Name Format   Write an SQL query to report\n product_name in lowercase without leading or trailing white spaces. sale_date in the format ('YYYY-MM') total the number of times the product was sold in this month.  Return the result table ordered by product_name in ascending order, in case of a tie order it by sale_date in ascending order.\nThe query result format is in the following example.\nSales +------------+------------------+--------------+ | sale_id | product_name | sale_date | +------------+------------------+--------------+ | 1 | LCPHONE | 2000-01-16 | | 2 | LCPhone | 2000-01-17 | | 3 | LcPhOnE | 2000-02-18 | | 4 | LCKeyCHAiN | 2000-02-19 | | 5 | LCKeyChain | 2000-02-28 | | 6 | Matryoshka | 2000-03-31 | +------------+------------------+--------------+ Result table: +--------------+--------------+----------+ | product_name | sale_date | total | +--------------+--------------+----------+ | lcphone | 2000-01 | 2 | | lckeychain | 2000-02 | 2 | | lcphone | 2000-02 | 1 | | matryoshka | 2000-03 | 1 | +--------------+--------------+----------+ In January, 2 LcPhones were sold, please note that the product names are not case sensitive and may contain spaces. In Februery, 2 LCKeychains and 1 LCPhone were sold. In March, 1 matryoshka was sold.   Solution 2020-10-18 Notes:  秒了. LOWER() + TRIM()  SELECT LOWER( TRIM(product_name) ) AS product_name, LEFT(sale_date, 7) AS sale_date, SUM(1) AS total FROM sales GROUP BY 1,2 ORDER BY 1,2  ","id":46,"section":"posts","summary":"LC 1543 Fix Product Name Format Write an SQL query to report product_name in lowercase without leading or trailing white spaces. sale_date in the format ('YYYY-MM') total the number of times the product was sold in this month. Return the result table ordered by product_name in ascending order, in case of a tie order it by sale_date in ascending order. The query result format is in the following example. Sales","tags":["leetcode"],"title":"1543 Fix Product Name Format","uri":"https://foxisawesome.github.io/posts/1543-fix-product-name-format/","year":"2020"},{"content":"LC 607 Sales Person   Given three tables: salesperson, company, orders. Output all the names in the table salesperson, who didn’t have sales to company \u0026lsquo;RED\u0026rsquo;.\n Solution 2020-10-18 Notes:  秒了  SELECT DISTINCT name FROM salesperson WHERE sales_id NOT IN (SELECT sales_id FROM orders WHERE com_id IN (SELECT com_id FROM company WHERE name='RED'))  ","id":47,"section":"posts","summary":"LC 607 Sales Person Given three tables: salesperson, company, orders. Output all the names in the table salesperson, who didn’t have sales to company \u0026lsquo;RED\u0026rsquo;. Solution 2020-10-18 Notes: 秒了 SELECT DISTINCT name FROM salesperson WHERE sales_id NOT IN (SELECT sales_id FROM orders WHERE com_id IN (SELECT com_id FROM company WHERE name='RED'))","tags":["leetcode"],"title":"607 Sales Person","uri":"https://foxisawesome.github.io/posts/607-sales-person/","year":"2020"},{"content":"LC 1294 Weather Type in Each Country   Write an SQL query to find the type of weather in each country for November 2019.\nThe type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise.\nReturn result table in any order.\n Solution 2020-10-18 Notes:  秒了  SELECT country_name, (CASE WHEN AVG(weather_state)\u0026lt;=15 THEN 'Cold' WHEN AVG(weather_state)\u0026gt;=25 THEN 'Hot' ELSE 'Warm' END) AS weather_type FROM countries a JOIN weather b ON a.country_id = b.country_id WHERE LEFT(day,7) = '2019-11' GROUP BY 1  ","id":48,"section":"posts","summary":"LC 1294 Weather Type in Each Country Write an SQL query to find the type of weather in each country for November 2019. The type of weather is Cold if the average weather_state is less than or equal 15, Hot if the average weather_state is greater than or equal 25 and Warm otherwise. Return result table in any order. Solution 2020-10-18 Notes: 秒了 SELECT country_name, (CASE WHEN AVG(weather_state)\u0026lt;=15 THEN","tags":["leetcode"],"title":"1294 Weather Type in Each Country","uri":"https://foxisawesome.github.io/posts/1294-weather-type-in-each-country/","year":"2020"},{"content":"LC 361 Bomb Enemy   Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb. The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed. Note: You can only put the bomb at an empty cell.\nExample:\nInput: [[\u0026quot;0\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;],[\u0026quot;E\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;W\u0026quot;,\u0026quot;E\u0026quot;],[\u0026quot;0\u0026quot;,\u0026quot;E\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;]] Output: 3 Explanation: For the given grid, 0 E 0 0 E 0 W E 0 E 0 0 Placing a bomb at (1,1) kills 3 enemies.   Solution 2020-10-18 Notes:  Brute force.  class Solution: def maxKilledEnemies(self, grid: List[List[str]]) -\u0026gt; int: if not grid: return 0 nr, nc = len(grid), len(grid[0]) ans = 0 for i in range(nr): for j in range(nc): if grid[i][j]=='0': ans = max(ans, self.killCount(grid,i,j,nr,nc)) return ans def killCount(self, grid, i, j, nr, nc): count, rd, ru, cr, cl = 0, i+1, i-1, j+1, j-1 while rd \u0026lt; nr and grid[rd][j]!='W': if grid[rd][j]=='E': count += 1 rd += 1 while ru \u0026gt;= 0 and grid[ru][j]!='W': if grid[ru][j]=='E': count += 1 ru -= 1 while cl \u0026gt;= 0 and grid[i][cl]!='W': if grid[i][cl]=='E': count += 1 cl -= 1 while cr \u0026lt; nc and grid[i][cr]!='W': if grid[i][cr]=='E': count += 1 cr += 1 return count # Time O((MN)^2) # Space O(1)  ","id":49,"section":"posts","summary":"LC 361 Bomb Enemy   Given a 2D grid, each cell is either a wall 'W', an enemy 'E' or empty '0' (the number zero), return the maximum enemies you can kill using one bomb. The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed. Note: You can only put the bomb at an empty cell.","tags":["leetcode","array"],"title":"361 Bomb Enemy","uri":"https://foxisawesome.github.io/posts/361-bomb-enemy/","year":"2020"},{"content":"LC 723 Candy Crush   This question is about implementing a basic elimination algorithm for Candy Crush.\nGiven a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player\u0026rsquo;s move. Now, you need to restore the board to a stable state by crushing candies according to the following rules:\n If three or more candies of the same type are adjacent vertically or horizontally, \u0026ldquo;crush\u0026rdquo; them all at the same time - these positions become empty. After crushing all candies simultaneously, if an empty space on the board has candies on top of itself, then these candies will drop until they hit a candy or bottom at the same time. (No new candies will drop outside the top boundary.) After the above steps, there may exist more candies that can be crushed. If so, you need to repeat the above steps. If there does not exist more candies that can be crushed (ie. the board is stable), then return the current board.  You need to perform the above rules until the board becomes stable, then return the current board.\nInput: board = [[110,5,112,113,114],[210,211,5,213,214],[310,311,3,313,314],[410,411,412,5,414],[5,1,512,3,3],[610,4,1,613,614],[710,1,2,713,714],[810,1,2,1,1],[1,1,2,2,2],[4,1,4,4,1014]] Output: [[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[110,0,0,0,114],[210,0,0,0,214],[310,0,0,113,314],[410,0,0,213,414],[610,211,112,313,614],[710,311,412,613,714],[810,411,512,713,1014]] Explanation:   Solution 2020-10-18 Notes:  这题看着复杂其实看了答案，brute force就是很优的解了。 algo 分三部分：  scan board. 找三连击的points 把三连击的点设为0 然后drop by column. Slow, fast pointers from the bottom to drop remaining stones.   |= means union sets. If setting remove as list, it is actually faster.  class Solution: def candyCrush(self, board: List[List[int]]) -\u0026gt; List[List[int]]: nr, nc = len(board), len(board[0]) while True: remove = set() for i in range(nr): for j in range(nc): if board[i][j] and j\u0026gt;1 and board[i][j]==board[i][j-1]==board[i][j-2]: remove |= {(i,j),(i,j-1),(i,j-2)} if board[i][j] and i\u0026gt;1 and board[i-2][j]==board[i-1][j]==board[i][j]: remove |= {(i-2,j),(i-1,j),(i,j)} if not remove: break for r,c in remove: board[r][c] = 0 for j in range(nc): s, f = 0, 0 while f \u0026lt; nr: if board[~f][j]!=0: board[~s][j], board[~f][j] = board[~f][j], board[~s][j] s += 1 f += 1 return board # Time O(?) # Space O(1)  ","id":50,"section":"posts","summary":"LC 723 Candy Crush This question is about implementing a basic elimination algorithm for Candy Crush. Given a 2D integer array board representing the grid of candy, different positive integers board[i][j] represent different types of candies. A value of board[i][j] = 0 represents that the cell at position (i, j) is empty. The given board represents the state of the game following the player\u0026rsquo;s move. Now, you need to restore","tags":["leetcode","matrix","array","dia"],"title":"723 Candy Crush","uri":"https://foxisawesome.github.io/posts/723-candy-crush/","year":"2020"},{"content":"LC 1470 Shuffle the Array   Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].\nReturn the array in the form [x1,y1,x2,y2,...,xn,yn].\n Solution 2020-10-18 Notes:  不能这么写 [i,j for i, j in zip(nums[:n],nums[n:])]  class Solution: def shuffle(self, nums: List[int], n: int) -\u0026gt; List[int]: ans = [] for i, j in zip(nums[:n], nums[n:]): ans += [i] + [j] return ans # Time O(N) # Space O(N)  ","id":51,"section":"posts","summary":"LC 1470 Shuffle the Array Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn]. Solution 2020-10-18 Notes: 不能这么写 [i,j for i, j in zip(nums[:n],nums[n:])] class Solution: def shuffle(self, nums: List[int], n: int) -\u0026gt; List[int]: ans = [] for i, j in zip(nums[:n], nums[n:]): ans += [i] + [j] return ans # Time O(N) # Space O(N)","tags":["leetcode","array"],"title":"1470 Shuffle the Array","uri":"https://foxisawesome.github.io/posts/1470-shuffle-the-array/","year":"2020"},{"content":"LC 1431 Kids With the Greatest Number of Candies   Given the array candies and the integer extraCandies, where candies[i] represents the number of candies that the *ith* kid has.\nFor each kid check if there is a way to distribute extraCandies among the kids such that he or she can have the greatest number of candies among them. Notice that multiple kids can have the greatest number of candies.\nInput: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: Kid 1 has 2 candies and if he or she receives all extra candies (3) will have 5 candies --- the greatest number of candies among the kids. Kid 2 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. Kid 3 has 5 candies and this is already the greatest number of candies among the kids. Kid 4 has 1 candy and even if he or she receives all extra candies will only have 4 candies. Kid 5 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids.   Solution 2020-10-18 Notes:  秒了  class Solution: def kidsWithCandies(self, candies: List[int], extraCandies: int) -\u0026gt; List[bool]: n = len(candies) ans = [True]* n max_ = max(candies) for i, c in enumerate(candies): if c + extraCandies \u0026lt; max_: ans[i] = False return ans # Time O(N) # Space O(N)  ","id":52,"section":"posts","summary":"LC 1431 Kids With the Greatest Number of Candies Given the array candies and the integer extraCandies, where candies[i] represents the number of candies that the *ith* kid has. For each kid check if there is a way to distribute extraCandies among the kids such that he or she can have the greatest number of candies among them. Notice that multiple kids can have the greatest number of candies. Input:","tags":["leetcode","array"],"title":"1431 Kids With the Greatest Number of Candies","uri":"https://foxisawesome.github.io/posts/1431-kids-with-the-greatest-number-of-candies/","year":"2020"},{"content":"LC 1480 Running Sum of 1d Array   Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).\nReturn the running sum of nums.\n Solution 2020-10-18 Notes:  Pre-sum. 秒了  class Solution: def runningSum(self, nums: List[int]) -\u0026gt; List[int]: if not nums: return [] n = len(nums) ans = [0] * n ans[0] = nums[0] for i in range(1,n): ans[i] = nums[i] + ans[i-1] return ans # Time O(N) # Space O(N)  ","id":53,"section":"posts","summary":"LC 1480 Running Sum of 1d Array Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. Solution 2020-10-18 Notes: Pre-sum. 秒了 class Solution: def runningSum(self, nums: List[int]) -\u0026gt; List[int]: if not nums: return [] n =","tags":["leetcode","array"],"title":"1480 Running Sum of 1d Array","uri":"https://foxisawesome.github.io/posts/1480-running-sum-of-1d-array/","year":"2020"},{"content":"LC 1119 Remove Vowels From a String   Given a string S, remove the vowels 'a', 'e', 'i', 'o', and 'u' from it, and return the new string.\n Solution 2020-10-18 Notes:  秒了  class Solution: def removeVowels(self, S: str) -\u0026gt; str: v = set(['a','e','i','o','u']) ans = [] for s in S: if s not in v: ans.append(s) return ''.join(ans) # Time O(N) # Space O(N)  ","id":54,"section":"posts","summary":"LC 1119 Remove Vowels From a String Given a string S, remove the vowels 'a', 'e', 'i', 'o', and 'u' from it, and return the new string. Solution 2020-10-18 Notes: 秒了 class Solution: def removeVowels(self, S: str) -\u0026gt; str: v = set(['a','e','i','o','u']) ans = [] for s in S: if s not in v: ans.append(s) return ''.join(ans) # Time O(N) # Space O(N)","tags":["leetcode","string"],"title":"1119 Remove Vowels From a String","uri":"https://foxisawesome.github.io/posts/1119-remove-vowels-from-a-string/","year":"2020"},{"content":"LC 1342 Number of Steps to Reduce a Number to Zero   Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.\nInput: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3. Step 4) 3 is odd; subtract 1 and obtain 2. Step 5) 2 is even; divide by 2 and obtain 1. Step 6) 1 is odd; subtract 1 and obtain 0.   Solution 2020-10-18 Notes:  秒了  class Solution: def numberOfSteps (self, num: int) -\u0026gt; int: ans = 0 if num == 0: return ans while num \u0026gt; 0: num, r = divmod(num,2) ans += 1 + r return ans - 1 # Time O(logN) # Space O(1)  ","id":55,"section":"posts","summary":"LC 1342 Number of Steps to Reduce a Number to Zero Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd;","tags":["leetcode","math"],"title":"1342 Number of Steps to Reduce a Number to Zero","uri":"https://foxisawesome.github.io/posts/1342-number-of-steps-to-reduce-a-number-to-zero/","year":"2020"},{"content":"LC 1141 User Activity for the Past 30 Days I   Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on some day if he/she made at least one activity on that day.\nThe query result format is in the following example:\nActivity table: +---------+------------+---------------+---------------+ | user_id | session_id | activity_date | activity_type | +---------+------------+---------------+---------------+ | 1 | 1 | 2019-07-20 | open_session | | 1 | 1 | 2019-07-20 | scroll_down | | 1 | 1 | 2019-07-20 | end_session | | 2 | 4 | 2019-07-20 | open_session | | 2 | 4 | 2019-07-21 | send_message | | 2 | 4 | 2019-07-21 | end_session | | 3 | 2 | 2019-07-21 | open_session | | 3 | 2 | 2019-07-21 | send_message | | 3 | 2 | 2019-07-21 | end_session | | 4 | 3 | 2019-06-25 | open_session | | 4 | 3 | 2019-06-25 | end_session | +---------+------------+---------------+---------------+ Result table: +------------+--------------+ | day | active_users | +------------+--------------+ | 2019-07-20 | 2 | | 2019-07-21 | 2 | +------------+--------------+ Note that we do not care about days with zero active users.   Solution 2020-10-17 Notes:  秒了  select activity_date as day, count(distinct user_id) as active_users from Activity where datediff('2019-07-27', activity_date) \u0026lt; 30 group by activity_date  ","id":56,"section":"posts","summary":"LC 1141 User Activity for the Past 30 Days I Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. A user was active on some day if he/she made at least one activity on that day. The query result format is in the following example: Activity table: +---------+------------+---------------+---------------+ | user_id | session_id | activity_date | activity_type | +---------+------------+---------------+---------------+ |","tags":["leetcode"],"title":"1141 User Activity for the Past 30 Days I","uri":"https://foxisawesome.github.io/posts/1141-user-activity-for-the-past-30-days-i/","year":"2020"},{"content":"LC 1623 All Valid Triplets That Can Represent a Country   Write an SQL query to find all the possible triplets representing the country under the given constraints.\nReturn the result table in any order.\nThe query result format is in the following example.\nSchoolA table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | +------------+--------------+ SchoolB table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 3 | Tom | +------------+--------------+ SchoolC table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 3 | Tom | | 2 | Jerry | | 10 | Alice | +------------+--------------+ Result table: +----------+----------+----------+ | member_A | member_B | member_C | +----------+----------+----------+ | Alice | Tom | Jerry | | Bob | Tom | Alice | +----------+----------+----------+ Let us see all the possible triplets. - (Alice, Tom, Tom) --\u0026gt; Rejected because member_B and member_C have the same name and the same ID. - (Alice, Tom, Jerry) --\u0026gt; Valid triplet. - (Alice, Tom, Alice) --\u0026gt; Rejected because member_A and member_C have the same name. - (Bob, Tom, Tom) --\u0026gt; Rejected because member_B and member_C have the same name and the same ID. - (Bob, Tom, Jerry) --\u0026gt; Rejected because member_A and member_C have the same ID. - (Bob, Tom, Alice) --\u0026gt; Valid triplet.   Solution 2020-10-17 Notes:  Cartisian join  SELECT a.student_name AS member_A, b.student_name AS member_B, c.student_name AS member_C FROM schoolA a, schoolB b, schoolC c WHERE a.student_id != b.student_id AND a.student_name != b.student_name AND a.student_id != c.student_id AND a.student_name != c.student_name AND c.student_id != b.student_id AND c.student_name != b.student_name  ","id":57,"section":"posts","summary":"LC 1623 All Valid Triplets That Can Represent a Country   Write an SQL query to find all the possible triplets representing the country under the given constraints.\nReturn the result table in any order.\nThe query result format is in the following example.\nSchoolA table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | +------------+--------------+ SchoolB table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 3 | Tom | +------------+--------------+ SchoolC table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 3 | Tom | | 2 | Jerry | | 10 | Alice | +------------+--------------+ Result table: +----------+----------+----------+ | member_A | member_B | member_C | +----------+----------+----------+ | Alice | Tom | Jerry | | Bob | Tom | Alice | +----------+----------+----------+ Let us see all the possible triplets.","tags":["leetcode"],"title":"1623 All Valid Triplets That Can Represent a Country","uri":"https://foxisawesome.github.io/posts/1623-all-valid-triplets-that-can-represent-a-country/","year":"2020"},{"content":"LC 1159 Market Analysis II   Write an SQL query to find for each user, whether the brand of the second item (by date) they sold is their favorite brand. If a user sold less than two items, report the answer for that user as no.\nIt is guaranteed that no seller sold more than one item on a day.\nThe query result format is in the following example:\nUsers table: +---------+------------+----------------+ | user_id | join_date | favorite_brand | +---------+------------+----------------+ | 1 | 2019-01-01 | Lenovo | | 2 | 2019-02-09 | Samsung | | 3 | 2019-01-19 | LG | | 4 | 2019-05-21 | HP | +---------+------------+----------------+ Orders table: +----------+------------+---------+----------+-----------+ | order_id | order_date | item_id | buyer_id | seller_id | +----------+------------+---------+----------+-----------+ | 1 | 2019-08-01 | 4 | 1 | 2 | | 2 | 2019-08-02 | 2 | 1 | 3 | | 3 | 2019-08-03 | 3 | 2 | 3 | | 4 | 2019-08-04 | 1 | 4 | 2 | | 5 | 2019-08-04 | 1 | 3 | 4 | | 6 | 2019-08-05 | 2 | 2 | 4 | +----------+------------+---------+----------+-----------+ Items table: +---------+------------+ | item_id | item_brand | +---------+------------+ | 1 | Samsung | | 2 | Lenovo | | 3 | LG | | 4 | HP | +---------+------------+ Result table: +-----------+--------------------+ | seller_id | 2nd_item_fav_brand | +-----------+--------------------+ | 1 | no | | 2 | yes | | 3 | yes | | 4 | no | +-----------+--------------------+ The answer for the user with id 1 is no because they sold nothing. The answer for the users with id 2 and 3 is yes because the brands of their second sold items are their favorite brands. The answer for the user with id 4 is no because the brand of their second sold item is not their favorite brand.   Solution 2020-10-17 Notes:  秒了。  SELECT c.user_id AS seller_id, CASE WHEN c.favorite_brand = d.item_brand THEN 'yes' ELSE 'no' END AS 2nd_item_fav_brand FROM users c LEFT JOIN ( SELECT a.*, b.item_brand, ROW_NUMBER() OVER(PARTITION BY seller_id ORDER BY order_date) AS nr FROM orders a JOIN items b ON a.item_id = b.item_id ) d ON c.user_id = d.seller_id AND nr = 2  ","id":58,"section":"posts","summary":"LC 1159 Market Analysis II Write an SQL query to find for each user, whether the brand of the second item (by date) they sold is their favorite brand. If a user sold less than two items, report the answer for that user as no. It is guaranteed that no seller sold more than one item on a day. The query result format is in the following example: Users table:","tags":["leetcode"],"title":"1159 Market Analysis II","uri":"https://foxisawesome.github.io/posts/1159-market-analysis-ii/","year":"2020"},{"content":"LC 1517 Find Users With Valid E-Mails   Write an SQL query to find the users who have valid emails.\nA valid e-mail has a prefix name and a domain where:\n The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.' and/or dash '-'. The prefix name must start with a letter. The domain is '@leetcode.com'.  Return the result table in any order.\nThe query result format is in the following example.\nUsers +---------+-----------+-------------------------+ | user_id | name | mail | +---------+-----------+-------------------------+ | 1 | Winston | winston@leetcode.com | | 2 | Jonathan | jonathanisgreat | | 3 | Annabelle | bella-@leetcode.com | | 4 | Sally | sally.come@leetcode.com | | 5 | Marwan | quarz#2020@leetcode.com | | 6 | David | david69@gmail.com | | 7 | Shapiro | .shapo@leetcode.com | +---------+-----------+-------------------------+ Result table: +---------+-----------+-------------------------+ | user_id | name | mail | +---------+-----------+-------------------------+ | 1 | Winston | winston@leetcode.com | | 3 | Annabelle | bella-@leetcode.com | | 4 | Sally | sally.come@leetcode.com | +---------+-----------+-------------------------+ The mail of user 2 doesn't have a domain. The mail of user 5 has # sign which is not allowed. The mail of user 6 doesn't have leetcode domain. The mail of user 7 starts with a period.   Solution 2020-10-17 Notes:  REGEXP:  ^ matches the begining, first [a-z]controls the beginning starts with letter. [a-z|0-9|._-] $ matches the end * controls matches zeor or many in [a-z|0-9|.-_]    SELECT user_id, name, mail FROM Users WHERE LOWER(mail) REGEXP '^[a-z][a-z|0-9|._-]*@leetcode.com$'  ","id":59,"section":"posts","summary":"LC 1517 Find Users With Valid E-Mails   Write an SQL query to find the users who have valid emails.\nA valid e-mail has a prefix name and a domain where:\n The prefix name is a string that may contain letters (upper or lower case), digits, underscore '_', period '.' and/or dash '-'. The prefix name must start with a letter. The domain is '@leetcode.com'.  Return the result table in any order.","tags":["leetcode","dia_sql"],"title":"1517 Find Users With Valid E-Mails","uri":"https://foxisawesome.github.io/posts/1517-find-users-with-valid-e-mails/","year":"2020"},{"content":"LC 1511 Customer Order Frequency   Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020.\nReturn the result table in any order.\nThe query result format is in the following example.\nCustomers +--------------+-----------+-------------+ | customer_id | name | country | +--------------+-----------+-------------+ | 1 | Winston | USA | | 2 | Jonathan | Peru | | 3 | Moustafa | Egypt | +--------------+-----------+-------------+ Product +--------------+-------------+-------------+ | product_id | description | price | +--------------+-------------+-------------+ | 10 | LC Phone | 300 | | 20 | LC T-Shirt | 10 | | 30 | LC Book | 45 | | 40 | LC Keychain | 2 | +--------------+-------------+-------------+ Orders +--------------+-------------+-------------+-------------+-----------+ | order_id | customer_id | product_id | order_date | quantity | +--------------+-------------+-------------+-------------+-----------+ | 1 | 1 | 10 | 2020-06-10 | 1 | | 2 | 1 | 20 | 2020-07-01 | 1 | | 3 | 1 | 30 | 2020-07-08 | 2 | | 4 | 2 | 10 | 2020-06-15 | 2 | | 5 | 2 | 40 | 2020-07-01 | 10 | | 6 | 3 | 20 | 2020-06-24 | 2 | | 7 | 3 | 30 | 2020-06-25 | 2 | | 9 | 3 | 30 | 2020-05-08 | 3 | +--------------+-------------+-------------+-------------+-----------+ Result table: +--------------+------------+ | customer_id | name | +--------------+------------+ | 1 | Winston | +--------------+------------+ Winston spent $300 (300 * 1) in June and $100 ( 10 * 1 + 45 * 2) in July 2020. Jonathan spent $600 (300 * 2) in June and $20 ( 2 * 10) in July 2020. Moustafa spent $110 (10 * 2 + 45 * 2) in June and $0 in July 2020.   Solution 2020-10-17 Notes:  ROW_NUMBER() 来抓取两个月都满足condition的customer  with full_order as ( select left(a.order_date, 7) as yymm, a.customer_id, b.name, sum(a.quantity * c.price) as amount from orders a join customers b on a.customer_id = b.customer_id join product c on a.product_id = c.product_id group by 1,2 ) SELECT DISTINCT customer_id, name FROM (SELECT *, ROW_NUMBER() OVER(PARTITION BY customer_id) AS nr FROM full_order WHERE yymm IN ('2020-06','2020-07') AND amount \u0026gt;= 100 ) a WHERE nr = 2  ","id":60,"section":"posts","summary":"LC 1511 Customer Order Frequency Write an SQL query to report the customer_id and customer_name of customers who have spent at least $100 in each month of June and July 2020. Return the result table in any order. The query result format is in the following example. Customers +--------------+-----------+-------------+ | customer_id | name | country | +--------------+-----------+-------------+ | 1 | Winston | USA | | 2 | Jonathan | Peru","tags":["leetcode"],"title":"1511 Customer Order Frequency","uri":"https://foxisawesome.github.io/posts/1511-customer-order-frequency/","year":"2020"},{"content":"LC 1479 Sales by Day of the Week   Write an SQL query to report how many units in each category have been ordered on each day of the week.\nReturn the result table ordered by category.\n Solution 2020-10-16 Notes:  DAYOFWEEK() : ‘2’ is Mon. MYSQL does not have pivot function, use below template  WITH combo AS ( SELECT b.*, DAYOFWEEK(order_date) AS week, item_category FROM items a LEFT JOIN orders b ON a.item_id = b.item_id ) SELECT category, SUM(CASE WHEN week = '2' THEN ct ELSE 0 END) AS 'Monday', SUM(CASE WHEN week = '3' THEN ct ELSE 0 END)AS 'Tuesday', SUM(CASE WHEN week = '4' THEN ct ELSE 0 END) AS 'Wednesday', SUM(CASE WHEN week = '5' THEN ct ELSE 0 END) AS 'Thursday', SUM(CASE WHEN week = '6' THEN ct ELSE 0 END) AS 'Friday', SUM(CASE WHEN week = '7' THEN ct ELSE 0 END) AS 'Saturday', SUM(CASE WHEN week = '1' THEN ct ELSE 0 END) AS 'Sunday' FROM ( SELECT item_category AS category, week, SUM(quantity) AS ct FROM combo GROUP BY 1,2 ) a GROUP BY category ORDER BY category  ","id":61,"section":"posts","summary":"LC 1479 Sales by Day of the Week   Write an SQL query to report how many units in each category have been ordered on each day of the week.\nReturn the result table ordered by category.\n Solution 2020-10-16 Notes:  DAYOFWEEK() : ‘2’ is Mon. MYSQL does not have pivot function, use below template  WITH combo AS ( SELECT b.*, DAYOFWEEK(order_date) AS week, item_category FROM items a LEFT JOIN orders b ON a.","tags":["leetcode","dia"],"title":"1479 Sales by Day of the Week","uri":"https://foxisawesome.github.io/posts/1479-sales-by-day-of-the-week/","year":"2020"},{"content":"LC 615 Average Salary Departments vs Company   Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company\u0026rsquo;s average salary.\nTable: salary\n| id | employee_id | amount | pay_date | |----|-------------|--------|------------| | 1 | 1 | 9000 | 2017-03-31 | | 2 | 2 | 6000 | 2017-03-31 | | 3 | 3 | 10000 | 2017-03-31 | | 4 | 1 | 7000 | 2017-02-28 | | 5 | 2 | 6000 | 2017-02-28 | | 6 | 3 | 8000 | 2017-02-28 |  The employee_id column refers to the employee_id in the following table employee.\n| employee_id | department_id | |-------------|---------------| | 1 | 1 | | 2 | 2 | | 3 | 2 |  So for the sample data above, the result is:\n| pay_month | department_id | comparison | |-----------|---------------|-------------| | 2017-03 | 1 | higher | | 2017-03 | 2 | lower | | 2017-02 | 1 | same | | 2017-02 | 2 | same |   Solution 2020-10-16 Notes:  秒了  WITH combo AS (SELECT a.*, b.department_id,LEFT(pay_date,7) AS pay_month FROM salary a JOIN employee b ON a.employee_id = b.employee_id) SELECT DISTINCT pay_month, department_id, CASE WHEN avg_dpt \u0026gt; avg_com THEN 'higher' WHEN avg_dpt \u0026lt; avg_com THEN 'lower' ELSE 'same' END AS comparison FROM( SELECT pay_month, department_id, AVG(amount) OVER(PARTITION BY pay_month, department_id) AS avg_dpt, AVG(amount) OVER(PARTITION BY pay_month) AS avg_com FROM combo ) a  ","id":62,"section":"posts","summary":"LC 615 Average Salary Departments vs Company Given two tables as below, write a query to display the comparison result (higher/lower/same) of the average salary of employees in a department to the company\u0026rsquo;s average salary. Table: salary | id | employee_id | amount | pay_date | |----|-------------|--------|------------| | 1 | 1 | 9000 | 2017-03-31 | | 2 | 2 | 6000 | 2017-03-31 | | 3 | 3 |","tags":["leetcode"],"title":"615 Average Salary Departments vs Company","uri":"https://foxisawesome.github.io/posts/615-average-salary-departments-vs-company/","year":"2020"},{"content":"LC 1024 Video Stitching   You are given a series of video clips from a sporting event that lasted T seconds. These video clips can be overlapping with each other and have varied lengths.\nEach video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1]. We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]). If the task is impossible, return -1.\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10 Output: 3 Explanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips. Then, we can reconstruct the sporting event as follows: We cut [1,9] into segments [1,2] + [2,8] + [8,9]. Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].   Solution 2020-10-15 Notes:  看了大神的解答，太妙了。 algo的想法是，先把starting time 升序排列。因为找的是个数，所以计数的时候不需要等到遇到最优解才 count ++，只要符合 start \u0026lt; i \u0026lt;= end就可以计数器了。 但在每个iteration，都要update当前的end time。每次update end 其实就是遇到了当前为止的最优区间。 细节的话，一定要从 [-1,0] init，因为要求全区间是[0,T]。  class Solution: def videoStitching(self, clips: List[List[int]], T: int) -\u0026gt; int: clips.sort(key = lambda x: x[0]) start, end = -1, 0 ans = 0 for i, j in clips: if end \u0026gt;= T or i \u0026gt; end: break elif start \u0026lt; i \u0026lt;= end: ans += 1 start = end end = max(end, j) return ans if end \u0026gt;= T else -1 # Time O(NlogN) # Space O(1)  ","id":63,"section":"posts","summary":"LC 1024 Video Stitching You are given a series of video clips from a sporting event that lasted T seconds. These video clips can be overlapping with each other and have varied lengths. Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1]. We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0,","tags":["leetcode","greedy","dia"],"title":"1024 Video Stitching","uri":"https://foxisawesome.github.io/posts/1024-video-stitching/","year":"2020"},{"content":"LC 452 Minimum Number of Arrows to Burst Balloons   There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it\u0026rsquo;s horizontal, y-coordinates don\u0026rsquo;t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.\nAn arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.\nGiven an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.\nInput: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).   Solution 2020-10-15 Notes:  greedy 解区间问题。先按 ending 升序排序。然后start如果在interval间，就可以share shot。但没share一次，intervals的start 要被跟新成overlapping的 (这一步其实多余，因为start用不上)。不能share shot，就开一个新的。  class Solution: def findMinArrowShots(self, points: List[List[int]]) -\u0026gt; int: if not points: return 0 points.sort(key= lambda x: x[1]) start, end = points[0] ans = 1 for i, j in points[1:]: if i \u0026gt; end: ans += 1 start, end = i, j return ans # Time O(NlogN) # Space O(1)  ","id":64,"section":"posts","summary":"LC 452 Minimum Number of Arrows to Burst Balloons There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it\u0026rsquo;s horizontal, y-coordinates don\u0026rsquo;t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end. An arrow can be shot up exactly vertically from different points","tags":["leetcode","greedy"],"title":"452 Minimum Number of Arrows to Burst Balloons","uri":"https://foxisawesome.github.io/posts/452-minimum-number-of-arrows-to-burst-balloons/","year":"2020"},{"content":"LC 435 Non Overlapping Intervals   Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nInput: [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.   Solution 2020-10-15 Notes:  Greedy 算法解决的一类 区间问题。 这题的思路是，先把每个区间的ending 升序排列。remove minium == keep maximun intervals. 所以从ending 最小开始，只要starting 在之前的ending 就remove掉。 剩下的就是最多的没有overlap的小区间。  class Solution: def eraseOverlapIntervals(self, intervals: List[List[int]]) -\u0026gt; int: if not intervals: return 0 intervals.sort(key = lambda x: x[1]) e = intervals[0][1] ans = 0 for i, j in intervals[1:]: if i \u0026lt; e: ans += 1 else: e = j return ans # Time O(NlogN) # Space O(1)  ","id":65,"section":"posts","summary":"LC 435 Non Overlapping Intervals Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Input: [[1,2],[2,3],[3,4],[1,3]] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Solution 2020-10-15 Notes: Greedy 算法解决的一类 区间问题。 这题的思路是，先把每","tags":["leetcode","greedy"],"title":"435 Non Overlapping Intervals","uri":"https://foxisawesome.github.io/posts/435-non-overlapping-intervals/","year":"2020"},{"content":"LC 613 Shortest Distance in a Line   Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.\nWrite a query to find the shortest distance between two points in these points.\n| x | |-----| | -1 | | 0 | | 2 |  The shortest distance is \u0026lsquo;1\u0026rsquo; obviously, which is from point \u0026lsquo;-1\u0026rsquo; to \u0026lsquo;0\u0026rsquo;. So the output is as below:\n| shortest| |---------| | 1 |   Solution 2020-10-14 Notes:  self join  SELECT MIN( ABS(a.x-b.x) ) AS shortest FROM point a JOIN point b ON a.x \u0026gt; b.x  ","id":66,"section":"posts","summary":"LC 613 Shortest Distance in a Line   Table point holds the x coordinate of some points on x-axis in a plane, which are all integers.\nWrite a query to find the shortest distance between two points in these points.\n| x | |-----| | -1 | | 0 | | 2 |  The shortest distance is \u0026lsquo;1\u0026rsquo; obviously, which is from point \u0026lsquo;-1\u0026rsquo; to \u0026lsquo;0\u0026rsquo;. So the output is as below:","tags":["leetcode"],"title":"613 Shortest Distance in a Line","uri":"https://foxisawesome.github.io/posts/613-shortest-distance-in-a-line/","year":"2020"},{"content":"LC 603 Consecutive Available Seats   Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?\n| seat_id | free | |---------|------| | 1 | 1 | | 2 | 0 | | 3 | 1 | | 4 | 1 | | 5 | 1 |  Your query should return the following result for the sample case above.\n| seat_id | |---------| | 3 | | 4 | | 5 |   Solution 2020-10-14 Notes: SELECT DISTINCT a.seat_id FROM cinema a JOIN cinema b ON ABS(a.seat_id - b.seat_id) = 1 AND a.free = 1 AND b.free = 1 ORDER BY 1  ","id":67,"section":"posts","summary":"LC 603 Consecutive Available Seats   Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?\n| seat_id | free | |---------|------| | 1 | 1 | | 2 | 0 | | 3 | 1 | | 4 | 1 | | 5 | 1 |  Your query should return the following result for the sample case above.","tags":["leetcode"],"title":"603 Consecutive Available Seats","uri":"https://foxisawesome.github.io/posts/603-consecutive-available-seats/","year":"2020"},{"content":"LC 602 Friend Requests Ii Who Has the Most Friends   Write a query to find the the people who has most friends and the most friends number under the following rules:\n It is guaranteed there is only 1 people having the most friends. The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value.  For the sample data above, the result is:\nResult table: +------+------+ | id | num | |------|------| | 3 | 3 | +------+------+ The person with id '3' is a friend of people '1', '2' and '4', so he has 3 friends in total, which is the most number than any others.   Solution 2020-10-14 Notes:  UNION ALL 老是忘记！  WITH combo AS ( SELECT requester_id AS id, COUNT(*) AS num FROM request_accepted GROUP BY 1 UNION ALL SELECT accepter_id AS id, COUNT(*) AS num FROM request_accepted GROUP BY 1 ) SELECT id, SUM(num) AS num FROM combo GROUP BY 1 ORDER BY 2 DESC LIMIT 1  ","id":68,"section":"posts","summary":"LC 602 Friend Requests Ii Who Has the Most Friends Write a query to find the the people who has most friends and the most friends number under the following rules: It is guaranteed there is only 1 people having the most friends. The friend request could only been accepted once, which mean there is no multiple records with the same requester_id and accepter_id value. For the sample data above,","tags":["leetcode"],"title":"602 Friend Requests Ii Who Has the Most Friends","uri":"https://foxisawesome.github.io/posts/602-friend-requests-ii-who-has-the-most-friends/","year":"2020"},{"content":"LC 974 Subarray Sums Divisible by K   Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\nInput: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]   Solution 2020-10-14 Notes:  About the problems - sum of contiguous subarray , prefix sum is a common technique. Another thing is if sum[0, i] % K == sum[0, j] % K, sum[i + 1, j] is divisible by by K. So for current index j, we need to find out how many index i (i \u0026lt; j) exit that has the same mod of K.  class Solution: def subarraysDivByK(self, A: List[int], K: int) -\u0026gt; int: n = len(A) ans = 0 count = collections.Counter() sum_ = 0 count[sum_] += 1 for a in A: sum_ = (sum_+a) % K ans += count[sum_] count[sum_] += 1 return ans # Time O(N) # Space O(N)  ","id":69,"section":"posts","summary":"LC 974 Subarray Sums Divisible by K   Given an array A of integers, return the number of (contiguous, non-empty) subarrays that have a sum divisible by K.\nInput: A = [4,5,0,-2,-3,1], K = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by K = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]   Solution 2020-10-14 Notes:  About the problems - sum of contiguous subarray , prefix sum is a common technique.","tags":["leetcode","array"],"title":"974 Subarray Sums Divisible by K","uri":"https://foxisawesome.github.io/posts/974-subarray-sums-divisible-by-k/","year":"2020"},{"content":"LC 909 Snakes and Ladders   On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows:\nInput: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation: At the beginning, you start at square 1 [at row 5, column 0]. You decide to move to square 2, and must take the ladder to square 15. You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13. You then decide to move to square 14, and must take the ladder to square 35. You then decide to move to square 36, ending the game. It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.   Solution 2020-10-14 Notes:  知道是BFS后还是code了老半天才做出来。首先因为是zig-zag的走，所以要搞对index有点复杂，最好的方法就是用board[~r][~c]来表示从右往左index。 其次，计算step要用一个dict来记录到达这个square的最早/短 steps。  class Solution: def snakesAndLadders(self, board: List[List[int]]) -\u0026gt; int: n = len(board) queue = [1] step = {1:0} while queue: l = len(queue) for i in range(l): sq = queue.pop(0) for j in range(1,7): if sq+j \u0026gt; n**2: break p, q = divmod(sq+j-1, n) r, c = ~p, q if p%2 == 0 else ~q next_sq = board[r][c] if board[r][c] \u0026gt; 0 else sq+j if next_sq==n**2: return step[sq] + 1 if next_sq not in step: queue.append(next_sq) step[next_sq] = step[sq] + 1 return -1 # Time O(N) # Space O(N)  ","id":70,"section":"posts","summary":"LC 909 Snakes and Ladders On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows: Input: [ [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,35,-1,-1,13,-1], [-1,-1,-1,-1,-1,-1], [-1,15,-1,-1,-1,-1]] Output: 4 Explanation: At the beginning, you start at square 1 [at row 5, column","tags":["leetcode","BFS","dia"],"title":"909 Snakes and Ladders","uri":"https://foxisawesome.github.io/posts/909-snakes-and-ladders/","year":"2020"},{"content":"LC 1428 Leftmost Column With at Least a One   (This problem is an interactive problem.)\nA binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order.\nGiven a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn\u0026rsquo;t exist, return -1.\nYou can\u0026rsquo;t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface:\n BinaryMatrix.get(row, col) returns the element of the matrix at index (row, col) (0-indexed). BinaryMatrix.dimensions() returns a list of 2 elements [rows, cols], which means the matrix is rows * cols.  Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.\nFor custom testing purposes you\u0026rsquo;re given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly.\n Solution 2020-10-13 Notes:  思路很好想到，主要是对API的调用。  # \u0026quot;\u0026quot;\u0026quot; # This is BinaryMatrix's API interface. # You should not implement it, or speculate about its implementation # \u0026quot;\u0026quot;\u0026quot; #class BinaryMatrix(object): # def get(self, row: int, col: int) -\u0026gt; int: # def dimensions(self) -\u0026gt; list[]: class Solution: def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -\u0026gt; int: nr, nc = binaryMatrix.dimensions() ans = nc for i in range(nr): l, r = 0, nc-1 while l \u0026lt; r: m = l + (r-l)//2 if binaryMatrix.get(i,m) == 0: l = m + 1 else: r = m if binaryMatrix.get(i,l) == 1: ans = min(ans, l) return -1 if ans == nc else ans # Time O(N) # Space O(1)  ","id":71,"section":"posts","summary":"LC 1428 Leftmost Column With at Least a One (This problem is an interactive problem.) A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn\u0026rsquo;t exist, return -1. You can\u0026rsquo;t access the Binary Matrix","tags":["leetcode","binary_search"],"title":"1428 Leftmost Column With at Least a One","uri":"https://foxisawesome.github.io/posts/1428-leftmost-column-with-at-least-a-one/","year":"2020"},{"content":"LC 1581 Customer Who Visited but Did Not Make Any Transactions   Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.\nReturn the result table sorted in any order.\nThe query result format is in the following example:\nVisits +----------+-------------+ | visit_id | customer_id | +----------+-------------+ | 1 | 23 | | 2 | 9 | | 4 | 30 | | 5 | 54 | | 6 | 96 | | 7 | 54 | | 8 | 54 | +----------+-------------+ Transactions +----------------+----------+--------+ | transaction_id | visit_id | amount | +----------------+----------+--------+ | 2 | 5 | 310 | | 3 | 5 | 300 | | 9 | 5 | 200 | | 12 | 1 | 910 | | 13 | 2 | 970 | +----------------+----------+--------+ Result table: +-------------+----------------+ | customer_id | count_no_trans | +-------------+----------------+ | 54 | 2 | | 30 | 1 | | 96 | 1 | +-------------+----------------+   Solution 2020-10-13 Notes:  秒了  SELECT customer_id, COUNT(DISTINCT visit_id) AS count_no_trans FROM visits WHERE visit_id NOT IN (SELECT visit_id FROM transactions) GROUP BY 1  ","id":72,"section":"posts","summary":"LC 1581 Customer Who Visited but Did Not Make Any Transactions Write an SQL query to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits. Return the result table sorted in any order. The query result format is in the following example: Visits +----------+-------------+ | visit_id | customer_id | +----------+-------------+ | 1 | 23 | |","tags":["leetcode"],"title":"1581 Customer Who Visited but Did Not Make Any Transactions","uri":"https://foxisawesome.github.io/posts/1581-customer-who-visited-but-did-not-make-any-transactions/","year":"2020"},{"content":"LC 1613 Find the Missing Ids   Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table.\nNotice that the maximum customer_id will not exceed 100.\nReturn the result table ordered by ids in ascending order.\nThe query result format is in the following example.\nCustomer table: +-------------+---------------+ | customer_id | customer_name | +-------------+---------------+ | 1 | Alice | | 4 | Bob | | 5 | Charlie | +-------------+---------------+ Result table: +-----+ | ids | +-----+ | 2 | | 3 | +-----+ The maximum customer_id present in the table is 5, so in the range [1,5], IDs 2 and 3 are missing from the table.   Solution 2020-10-13 Notes:  第一次遇上mysql recursive CTE。  WITH RECURSIVE id_seq AS( SELECT 1 AS n UNION SELECT n+1 FROM id_seq WHERE n \u0026lt; (SELECT MAX(customer_id) FROM customers) ) SELECT n AS ids FROM id_seq WHERE n NOT IN (SELECT customer_id FROM Customers)  ","id":73,"section":"posts","summary":"LC 1613 Find the Missing Ids Write an SQL query to find the missing customer IDs. The missing IDs are ones that are not in the Customers table but are in the range between 1 and the maximum customer_id present in the table. Notice that the maximum customer_id will not exceed 100. Return the result table ordered by ids in ascending order. The query result format is in the following","tags":["leetcode","dia"],"title":"1613 Find the Missing Ids","uri":"https://foxisawesome.github.io/posts/1613-find-the-missing-ids/","year":"2020"},{"content":"LC 1587 Bank Account Summary II   Write an SQL query to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account.\nReturn the result table in any order.\nThe query result format is in the following example.\nUsers table: +------------+--------------+ | account | name | +------------+--------------+ | 900001 | Alice | | 900002 | Bob | | 900003 | Charlie | +------------+--------------+ Transactions table: +------------+------------+------------+---------------+ | trans_id | account | amount | transacted_on | +------------+------------+------------+---------------+ | 1 | 900001 | 7000 | 2020-08-01 | | 2 | 900001 | 7000 | 2020-09-01 | | 3 | 900001 | -3000 | 2020-09-02 | | 4 | 900002 | 1000 | 2020-09-12 | | 5 | 900003 | 6000 | 2020-08-07 | | 6 | 900003 | 6000 | 2020-09-07 | | 7 | 900003 | -4000 | 2020-09-11 | +------------+------------+------------+---------------+ Result table: +------------+------------+ | name | balance | +------------+------------+ | Alice | 11000 | +------------+------------+ Alice's balance is (7000 + 7000 - 3000) = 11000. Bob's balance is 1000. Charlie's balance is (6000 + 6000 - 4000) = 8000.   Solution 2020-10-13 Notes:  秒了。  SELECT a.name, b.balance FROM users a JOIN (SELECT account, SUM(amount) AS balance FROM transactions GROUP BY 1) b ON a.account = b.account AND balance \u0026gt; 10000  ","id":74,"section":"posts","summary":"LC 1587 Bank Account Summary II Write an SQL query to report the name and balance of users with a balance higher than 10000. The balance of an account is equal to the sum of the amounts of all transactions involving that account. Return the result table in any order. The query result format is in the following example. Users table: +------------+--------------+ | account | name | +------------+--------------+ | 900001","tags":["leetcode"],"title":"1587 Bank Account Summary II","uri":"https://foxisawesome.github.io/posts/1587-bank-account-summary-ii/","year":"2020"},{"content":"LC 654 Maximum Binary Tree   Given an integer array with no duplicates. A maximum tree building on this array is defined as follow:\n The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number.  Construct the maximum tree by the given array and output the root node of this tree.\nInput: [3,2,1,6,0,5] Output: return the tree root node representing the following tree: 6 / \\ 3 5 \\ / 2 0 \\ 1   Solution 2020-10-13 Notes:  与 LC 105 一个道理，还有简单点。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def constructMaximumBinaryTree(self, nums: List[int]) -\u0026gt; TreeNode: if not nums: return max_ = max(nums) idx = nums.index(max_) root = TreeNode(max_) root.left = self.constructMaximumBinaryTree(nums[:idx]) root.right= self.constructMaximumBinaryTree(nums[idx+1:]) return root # Time O(N) # Space O(1)  ","id":75,"section":"posts","summary":"LC 654 Maximum Binary Tree Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree","tags":["leetcode","tree"],"title":"654 Maximum Binary Tree","uri":"https://foxisawesome.github.io/posts/654-maximum-binary-tree/","year":"2020"},{"content":"LC 106 Construct Binary Tree From Inorder and Postorder Traversal   Given inorder and postorder traversal of a tree, construct the binary tree.\nNote: You may assume that duplicates do not exist in the tree.\nFor example, given\ninorder = [9,3,15,20,7] postorder = [9,15,7,20,3]  Return the following binary tree:\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-10-13 Notes:  和 LC 105 一个道理。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -\u0026gt; TreeNode: if not inorder or not postorder: return None root = TreeNode(postorder[-1]) index = inorder.index(root.val) root.left = self.buildTree(inorder[:index], postorder[:index]) root.right = self.buildTree(inorder[index+1:], postorder[index:-1]) return root # Time O(N) # Space O(1)  ","id":76,"section":"posts","summary":"LC 106 Construct Binary Tree From Inorder and Postorder Traversal Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solution 2020-10-13 Notes: 和 LC 105 一个道理。 # Definition","tags":["leetcode","tree"],"title":"106 Construct Binary Tree From Inorder and Postorder Traversal","uri":"https://foxisawesome.github.io/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/","year":"2020"},{"content":"LC 105 Construct Binary Tree From Preorder and Inorder Traversal   Given preorder and inorder traversal of a tree, construct the binary tree.\nNote: You may assume that duplicates do not exist in the tree.\nFor example, given\npreorder = [3,9,20,15,7] inorder = [9,3,15,20,7]  Return the following binary tree:\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-10-13 Notes:  这题关键是 root 在 inorder里的index 映射到 preorder上是 left sub-tree.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -\u0026gt; TreeNode: if not preorder or not inorder: return None root = TreeNode(preorder[0]) idx = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:idx+1], inorder[:idx+1]) root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:]) return root # Time O(N) # Space O(1)  ","id":77,"section":"posts","summary":"LC 105 Construct Binary Tree From Preorder and Inorder Traversal Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solution 2020-10-13 Notes: 这题关键是 root 在 ino","tags":["leetcode","tree","dia"],"title":"105 Construct Binary Tree From Preorder and Inorder Traversal","uri":"https://foxisawesome.github.io/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/","year":"2020"},{"content":"LC 116 Populating Next Right Pointers in Each Node   You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\nstruct Node { int val; Node *left; Node *right; Node *next; }  Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\n Solution 2020-10-13 Notes:  BFS 的解法。  \u0026quot;\u0026quot;\u0026quot; # Definition for a Node. class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next \u0026quot;\u0026quot;\u0026quot; class Solution: def connect(self, root: 'Node') -\u0026gt; 'Node': if not root: return queue = [root] while queue: n = len(queue) for i in range(n): node = queue.pop(0) if i \u0026lt; n-1: node.next = queue[0] if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root # Time O(N) # Space O(N)   DFS  \u0026quot;\u0026quot;\u0026quot; # Definition for a Node. class Node: def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None): self.val = val self.left = left self.right = right self.next = next \u0026quot;\u0026quot;\u0026quot; class Solution: def connect(self, root: 'Node') -\u0026gt; 'Node': if not root: return return self.dfs(root) def dfs(self, root): if not root: return if root.right: root.left.next = root.right if root.next: root.right.next = root.next.left self.dfs(root.left) self.dfs(root.right) return root  ","id":78,"section":"posts","summary":"LC 116 Populating Next Right Pointers in Each Node You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer","tags":["leetcode","tree"],"title":"116 Populating Next Right Pointers in Each Node","uri":"https://foxisawesome.github.io/posts/116-populating-next-right-pointers-in-each-node/","year":"2020"},{"content":"LC 226 Invert Binary Tree   nvert a binary tree.\nInput:\n 4 / \\ 2 7 / \\ / \\ 1 3 6 9  Output:\n 4 / \\ 7 2 / \\ / \\ 9 6 3 1   Solution 2020-10-13 Notes:    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def invertTree(self, root: TreeNode) -\u0026gt; TreeNode: if not root: return None root.left, root.right = root.right, root.left self.invertTree(root.left) self.invertTree(root.right) return root # Time O(N) # Space O(1)  ","id":79,"section":"posts","summary":"LC 226 Invert Binary Tree   nvert a binary tree.\nInput:\n 4 / \\ 2 7 / \\ / \\ 1 3 6 9  Output:\n 4 / \\ 7 2 / \\ / \\ 9 6 3 1   Solution 2020-10-13 Notes:    # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.","tags":["leetcode","tree"],"title":"226 Invert Binary Tree","uri":"https://foxisawesome.github.io/posts/226-invert-binary-tree/","year":"2020"},{"content":"LC 453 Minimum Moves to Equal Array Elements   Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.\nInput: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =\u0026gt; [2,3,3] =\u0026gt; [3,4,3] =\u0026gt; [4,4,4]   Solution 2020-10-11 Notes:  很巧的一个小题。 这题顺着题意，就是每次排序小到大，给小的都+1，然后在排序知道全部相等。但TLE。 看了题解，才意识到，每次给n-1个数(除去max)+1，就是每次给一个数-1，直至全部等于最小值。  class Solution: def minMoves(self, nums: List[int]) -\u0026gt; int: return sum(nums) - min(nums)*len(nums) # Time O(N) # Space O(1)  ","id":80,"section":"posts","summary":"LC 453 Minimum Moves to Equal Array Elements Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1. Input: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =\u0026gt; [2,3,3] =\u0026gt; [3,4,3] =\u0026gt; [4,4,4] Solution 2020-10-11 Notes: 很巧的一","tags":["leetcode","array"],"title":"453 Minimum Moves to Equal Array Elements","uri":"https://foxisawesome.github.io/posts/453-minimum-moves-to-equal-array-elements/","year":"2020"},{"content":"LC 547 Friend Circles   There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.\nGiven a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.\nInput: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. The 2nd student himself is in a friend circle. So return 2.   Solution 2020-10-11 Notes:  看花花酱的分类，这题是 graph 下的 connected components。 其实很普通的bfs走island的题一样，grid上方向是4个或者8个，这种无向图，探索的方向是从0到n-1。看跟哪个朋友相连接。  class Solution: def findCircleNum(self, M: List[List[int]]) -\u0026gt; int: n = len(M) ans = 0 visited = [0]*n for i in range(n): if visited[i]==0: ans += 1 self.dfs(M,visited,n,i) return ans def dfs(self,grid,visited,n,x): if visited[x]==1: return visited[x] = 1 for i in range(n): if visited[i]==0 and grid[x][i]==1: self.dfs(grid,visited,n,i) # Time O(N^2) # Space O(N)  ","id":81,"section":"posts","summary":"LC 547 Friend Circles There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given","tags":["leetcode","graph","dfs"],"title":"547 Friend Circles","uri":"https://foxisawesome.github.io/posts/547-friend-circles/","year":"2020"},{"content":"LC 1280 Students and Examinations   Write an SQL query to find the number of times each student attended each exam.\nOrder the result table by student_id and subject_name.\nThe query result format is in the following example:\nStudents table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | | 13 | John | | 6 | Alex | +------------+--------------+ Subjects table: +--------------+ | subject_name | +--------------+ | Math | | Physics | | Programming | +--------------+ Examinations table: +------------+--------------+ | student_id | subject_name | +------------+--------------+ | 1 | Math | | 1 | Physics | | 1 | Programming | | 2 | Programming | | 1 | Physics | | 1 | Math | | 13 | Math | | 13 | Programming | | 13 | Physics | | 2 | Math | | 1 | Math | +------------+--------------+ Result table: +------------+--------------+--------------+----------------+ | student_id | student_name | subject_name | attended_exams | +------------+--------------+--------------+----------------+ | 1 | Alice | Math | 3 | | 1 | Alice | Physics | 2 | | 1 | Alice | Programming | 1 | | 2 | Bob | Math | 1 | | 2 | Bob | Physics | 0 | | 2 | Bob | Programming | 1 | | 6 | Alex | Math | 0 | | 6 | Alex | Physics | 0 | | 6 | Alex | Programming | 0 | | 13 | John | Math | 1 | | 13 | John | Physics | 1 | | 13 | John | Programming | 1 | +------------+--------------+--------------+----------------+   Solution 2020-10-11 Notes: SELECT a.student_id, student_name, a.subject_name, IFNULL(attended_exams,0) AS attended_exams FROM ( SELECT student_id, student_name, subject_name FROM Students, subjects )a LEFT JOIN ( SELECT *, COUNT(*) AS attended_exams FROM examinations GROUP BY student_id, subject_name ) b ON a.student_id=b.student_id AND a.subject_name=b.subject_name ORDER BY student_id, subject_name  ","id":82,"section":"posts","summary":"LC 1280 Students and Examinations   Write an SQL query to find the number of times each student attended each exam.\nOrder the result table by student_id and subject_name.\nThe query result format is in the following example:\nStudents table: +------------+--------------+ | student_id | student_name | +------------+--------------+ | 1 | Alice | | 2 | Bob | | 13 | John | | 6 | Alex | +------------+--------------+ Subjects table: +--------------+ | subject_name | +--------------+ | Math | | Physics | | Programming | +--------------+ Examinations table: +------------+--------------+ | student_id | subject_name | +------------+--------------+ | 1 | Math | | 1 | Physics | | 1 | Programming | | 2 | Programming | | 1 | Physics | | 1 | Math | | 13 | Math | | 13 | Programming | | 13 | Physics | | 2 | Math | | 1 | Math | +------------+--------------+ Result table: +------------+--------------+--------------+----------------+ | student_id | student_name | subject_name | attended_exams | +------------+--------------+--------------+----------------+ | 1 | Alice | Math | 3 | | 1 | Alice | Physics | 2 | | 1 | Alice | Programming | 1 | | 2 | Bob | Math | 1 | | 2 | Bob | Physics | 0 | | 2 | Bob | Programming | 1 | | 6 | Alex | Math | 0 | | 6 | Alex | Physics | 0 | | 6 | Alex | Programming | 0 | | 13 | John | Math | 1 | | 13 | John | Physics | 1 | | 13 | John | Programming | 1 | +------------+--------------+--------------+----------------+   Solution 2020-10-11 Notes: SELECT a.","tags":["leetcode"],"title":"1280 Students and Examinations","uri":"https://foxisawesome.github.io/posts/1280-students-and-examinations/","year":"2020"},{"content":"LC 1205 Monthly Transactions II   Write an SQL query to find for each month and country, the number of approved transactions and their total amount, the number of chargebacks and their total amount.\nNote: In your query, given the month and country, ignore rows with all zeros.\nThe query result format is in the following example:\nTransactions table: +------+---------+----------+--------+------------+ | id | country | state | amount | trans_date | +------+---------+----------+--------+------------+ | 101 | US | approved | 1000 | 2019-05-18 | | 102 | US | declined | 2000 | 2019-05-19 | | 103 | US | approved | 3000 | 2019-06-10 | | 104 | US | approved | 4000 | 2019-06-13 | | 105 | US | approved | 5000 | 2019-06-15 | +------+---------+----------+--------+------------+ Chargebacks table: +------------+------------+ | trans_id | trans_date | +------------+------------+ | 102 | 2019-05-29 | | 101 | 2019-06-30 | | 105 | 2019-09-18 | +------------+------------+ Result table: +----------+---------+----------------+-----------------+-------------------+--------------------+ | month | country | approved_count | approved_amount | chargeback_count | chargeback_amount | +----------+---------+----------------+-----------------+-------------------+--------------------+ | 2019-05 | US | 1 | 1000 | 1 | 2000 | | 2019-06 | US | 3 | 12000 | 1 | 1000 | | 2019-09 | US | 0 | 0 | 1 | 5000 | +----------+---------+----------------+-----------------+-------------------+--------------------+   Solution 2020-10-11 Notes: SELECT month, country, SUM(CASE WHEN state = \u0026quot;approved\u0026quot; THEN 1 ELSE 0 END) AS approved_count, SUM(CASE WHEN state = \u0026quot;approved\u0026quot; THEN amount ELSE 0 END) AS approved_amount, SUM(CASE WHEN state = \u0026quot;back\u0026quot; THEN 1 ELSE 0 END) AS chargeback_count, SUM(CASE WHEN state = \u0026quot;back\u0026quot; THEN amount ELSE 0 END) AS chargeback_amount FROM( SELECT LEFT(chargebacks.trans_date, 7) AS month, country, \u0026quot;back\u0026quot; AS state, amount FROM chargebacks JOIN transactions ON chargebacks.trans_id = transactions.id UNION ALL SELECT LEFT(trans_date, 7) AS month, country, state, amount FROM transactions WHERE state = \u0026quot;approved\u0026quot; ) a GROUP BY 1,2 ORDER BY 1,2  ","id":83,"section":"posts","summary":"LC 1205 Monthly Transactions II   Write an SQL query to find for each month and country, the number of approved transactions and their total amount, the number of chargebacks and their total amount.\nNote: In your query, given the month and country, ignore rows with all zeros.\nThe query result format is in the following example:\nTransactions table: +------+---------+----------+--------+------------+ | id | country | state | amount | trans_date | +------+---------+----------+--------+------------+ | 101 | US | approved | 1000 | 2019-05-18 | | 102 | US | declined | 2000 | 2019-05-19 | | 103 | US | approved | 3000 | 2019-06-10 | | 104 | US | approved | 4000 | 2019-06-13 | | 105 | US | approved | 5000 | 2019-06-15 | +------+---------+----------+--------+------------+ Chargebacks table: +------------+------------+ | trans_id | trans_date | +------------+------------+ | 102 | 2019-05-29 | | 101 | 2019-06-30 | | 105 | 2019-09-18 | +------------+------------+ Result table: +----------+---------+----------------+-----------------+-------------------+--------------------+ | month | country | approved_count | approved_amount | chargeback_count | chargeback_amount | +----------+---------+----------------+-----------------+-------------------+--------------------+ | 2019-05 | US | 1 | 1000 | 1 | 2000 | | 2019-06 | US | 3 | 12000 | 1 | 1000 | | 2019-09 | US | 0 | 0 | 1 | 5000 | +----------+---------+----------------+-----------------+-------------------+--------------------+   Solution 2020-10-11 Notes: SELECT month, country, SUM(CASE WHEN state = \u0026quot;approved\u0026quot; THEN 1 ELSE 0 END) AS approved_count, SUM(CASE WHEN state = \u0026quot;approved\u0026quot; THEN amount ELSE 0 END) AS approved_amount, SUM(CASE WHEN state = \u0026quot;back\u0026quot; THEN 1 ELSE 0 END) AS chargeback_count, SUM(CASE WHEN state = \u0026quot;back\u0026quot; THEN amount ELSE 0 END) AS chargeback_amount FROM( SELECT LEFT(chargebacks.","tags":["leetcode"],"title":"1205 Monthly Transactions II","uri":"https://foxisawesome.github.io/posts/1205-monthly-transactions-ii/","year":"2020"},{"content":"LC 695 Max Area of Island   Given a non-empty 2D array grid of 0\u0026rsquo;s and 1\u0026rsquo;s, an island is a group of 1\u0026rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\nFind the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)\n[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]  Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.\n Solution 2020-10-11 Notes:  及其标准的BFS题。  class Solution: def maxAreaOfIsland(self, grid: List[List[int]]) -\u0026gt; int: directions = [[1,0], [-1,0], [0,1], [0,-1]] nr, nc = len(grid), len(grid[0]) ans = 0 for i in range(nr): for j in range(nc): if grid[i][j] == 1: island = self.bfs(grid, directions,nr,nc,i,j) ans = max(ans,island) return ans def bfs(self, grid, directions, nr, nc, x, y): queue = [(x,y)] grid[x][y] = 0 island = 1 while queue: p0, p1 = queue.pop(0) for d in directions: new = (p0+d[0], p1+d[1]) if 0\u0026lt;=new[0]\u0026lt;nr and 0\u0026lt;=new[1]\u0026lt;nc and grid[new[0]][new[1]]==1: queue.append(new) island += 1 grid[new[0]][new[1]] = 0 return island # Time O(N) # Space O(1)  ","id":84,"section":"posts","summary":"LC 695 Max Area of Island Given a non-empty 2D array grid of 0\u0026rsquo;s and 1\u0026rsquo;s, an island is a group of 1\u0026rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0],","tags":["leetcode","bfs"],"title":"695 Max Area of Island","uri":"https://foxisawesome.github.io/posts/695-max-area-of-island/","year":"2020"},{"content":"LC 1197 Minimum Knight Moves   In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0].\nA knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.\n Solution 2020-10-11 Notes:  这题最优解是dp 但使用naive BFS会 TLE。做两个优化就能过。1. 利用棋盘的symmetry, 可以使用target = (abs(x), abs(y))。2. 最重要的优化是 line23 coor_new[0]\u0026gt;=-2 and coor_new[1]\u0026gt;=-2: 新的point 不能低于(-2,-2)，因为使用了对称性，下界就成了(0-2, 0-2)。  class Solution: def minKnightMoves(self, x: int, y: int) -\u0026gt; int: directions = [[2,1],[-2,1],[2,-1],[-2,-1],[1,2],[-1,2],[1,-2],[-1,-2]] target = (abs(x),abs(y)) if target == (0,0): return 0 visited = set() queue = [(0,0)] step = 0 while queue: n = len(queue) step += 1 for i in range(n): coor = queue.pop(0) (x0, y0) = coor if coor not in visited: visited.add(coor) for d in directions: coor_new = (x0+d[0], y0+d[1]) if coor_new == target: return step if coor_new not in visited and coor_new[0]\u0026gt;=-2 and coor_new[1]\u0026gt;=-2: queue.append(coor_new)  ","id":85,"section":"posts","summary":"LC 1197 Minimum Knight Moves In an infinite chess board with coordinates from -infinity to +infinity, you have a knight at square [0, 0]. A knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction. Solution 2020-10-11 Notes: 这题最优解是dp 但使用naiv","tags":["leetcode","BFS","dp"],"title":"1197 Minimum Knight Moves","uri":"https://foxisawesome.github.io/posts/1197-minimum-knight-moves/","year":"2020"},{"content":"LC 835 Image Overlap   You are given two images img1 and img2 both of size n x n, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.)\nWe translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation is the number of positions that have a 1 in both images.\n(Note also that a translation does not include any kind of rotation.)\nWhat is the largest possible overlap?\nExample 1:\nInput: img1 = [[1,1,0],[0,1,0],[0,1,0]], img2 = [[0,0,0],[0,1,1],[0,0,1]] Output: 3 Explanation: We slide img1 to right by 1 unit and down by 1 unit.\nThe number of positions that have a 1 in both images is 3. (Shown in red)\n Solution 2020-10-11 Notes:  algo的想法是利用vector的linear transformation。pa(x,y) + (3,2) = pb(x+3, y+2). 向量(3,2) 就是从A到B需要的变化。所以 img1 所有1对应img2中所有1，需要的transformation的都可以求的，即 dist。然后求一下dist中出现频率最高的次数，就是能得到的最大overlap的面积。 其次2D array的 one liner写法 最后输出时避免dictionary.values() 为空的写法。  class Solution: def largestOverlap(self, img1: List[List[int]], img2: List[List[int]]) -\u0026gt; int: N = len(img1) ones1 = [(x,y) for x in range(N) for y in range(N) if img1[x][y]] ones2 = [(x,y) for x in range(N) for y in range(N) if img2[x][y]] dist = [(x1-x2, y1-y2) for (x1,y1) in ones1 for (x2,y2) in ones2] count = collections.Counter(dist) return max(count.values() or [0]) # Time O(N) # Space O(N)  ","id":86,"section":"posts","summary":"LC 835 Image Overlap You are given two images img1 and img2 both of size n x n, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation","tags":["leetcode","martix"],"title":"835 Image Overlap","uri":"https://foxisawesome.github.io/posts/835-image-overlap/","year":"2020"},{"content":"LC 1007 Minimum Domino Rotations for Equal Row   In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.)\nWe may rotate the i-th domino, so that A[i] and B[i] swap values.\nReturn the minimum number of rotations so that all the values in A are the same, or all the values in B are the same.\nIf it cannot be done, return -1.\nInput: A = [2,1,2,4,2,2], B = [5,2,6,2,3,2] Output: 2 Explanation: The first figure represents the dominoes as given by A and B: before we do any rotations. If we rotate the second and fourth dominoes, we can make every value in the top row equal to 2, as indicated by the second figure.   Solution 2020-10-09 Notes:  这题关键就是targets只可能是 A[0] or B[0]。  class Solution: def minDominoRotations(self, A: List[int], B: List[int]) -\u0026gt; int: a = self.rotate(A,B) b = self.rotate(B,A) return -1 if a==float('inf') and b==float('inf') else min(a,b) def rotate(self, A, B): n = len(A) c = [0] * 2 targets = (A[0],B[0]) for i in range(2): target = targets[i] for j in range(n): if A[j] != target and B[j] != target: c[i] = float('inf') break elif A[j] != target and B[j] == target: c[i] += 1 return min(c) # Time O(N) # Space O(1)  ","id":87,"section":"posts","summary":"LC 1007 Minimum Domino Rotations for Equal Row In a row of dominoes, A[i] and B[i] represent the top and bottom halves of the i-th domino. (A domino is a tile with two numbers from 1 to 6 - one on each half of the tile.) We may rotate the i-th domino, so that A[i] and B[i] swap values. Return the minimum number of rotations so that all the values","tags":["leetcode","array"],"title":"1007 Minimum Domino Rotations for Equal Row","uri":"https://foxisawesome.github.io/posts/1007-minimum-domino-rotations-for-equal-row/","year":"2020"},{"content":"LC 1321 Restaurant Growth   Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) .\nThe query result format is in the following example:\nReturn result table ordered by visited_on.\naverage_amount should be rounded to 2 decimal places, all dates are in the format (\u0026lsquo;YYYY-MM-DD\u0026rsquo;).\nCustomer table: +-------------+--------------+--------------+-------------+ | customer_id | name | visited_on | amount | +-------------+--------------+--------------+-------------+ | 1 | Jhon | 2019-01-01 | 100 | | 2 | Daniel | 2019-01-02 | 110 | | 3 | Jade | 2019-01-03 | 120 | | 4 | Khaled | 2019-01-04 | 130 | | 5 | Winston | 2019-01-05 | 110 | | 6 | Elvis | 2019-01-06 | 140 | | 7 | Anna | 2019-01-07 | 150 | | 8 | Maria | 2019-01-08 | 80 | | 9 | Jaze | 2019-01-09 | 110 | | 1 | Jhon | 2019-01-10 | 130 | | 3 | Jade | 2019-01-10 | 150 | +-------------+--------------+--------------+-------------+ Result table: +--------------+--------------+----------------+ | visited_on | amount | average_amount | +--------------+--------------+----------------+ | 2019-01-07 | 860 | 122.86 | | 2019-01-08 | 840 | 120 | | 2019-01-09 | 840 | 120 | | 2019-01-10 | 1000 | 142.86 | +--------------+--------------+----------------+ 1st moving average from 2019-01-01 to 2019-01-07 has an average_amount of (100 + 110 + 120 + 130 + 110 + 140 + 150)/7 = 122.86 2nd moving average from 2019-01-02 to 2019-01-08 has an average_amount of (110 + 120 + 130 + 110 + 140 + 150 + 80)/7 = 120 3rd moving average from 2019-01-03 to 2019-01-09 has an average_amount of (120 + 130 + 110 + 140 + 150 + 80 + 110)/7 = 120 4th moving average from 2019-01-04 to 2019-01-10 has an average_amount of (130 + 110 + 140 + 150 + 80 + 110 + 130 + 150)/7 = 142.86   Solution 2020-10-09 Notes:  这题好复杂，参考了论坛。window function里得套一个aggregation function。  SELECT visited_on, SUM(SUM(amount)) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS amount, ROUND(SUM(SUM(amount)) OVER(ORDER BY visited_on ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)/7,2) AS average_amount FROM customer GROUP BY visited_on ORDER BY visited_on LIMIT 6, 1000  ","id":88,"section":"posts","summary":"LC 1321 Restaurant Growth Write an SQL query to compute moving average of how much customer paid in a 7 days window (current day + 6 days before) . The query result format is in the following example: Return result table ordered by visited_on. average_amount should be rounded to 2 decimal places, all dates are in the format (\u0026lsquo;YYYY-MM-DD\u0026rsquo;). Customer table: +-------------+--------------+--------------+-------------+ | customer_id | name | visited_on | amount","tags":["leetcode","dia_sql"],"title":"1321 Restaurant Growth","uri":"https://foxisawesome.github.io/posts/1321-restaurant-growth/","year":"2020"},{"content":"LC 1107 New Users Daily Count   Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30.\nThe query result format is in the following example:\nTraffic table: +---------+----------+---------------+ | user_id | activity | activity_date | +---------+----------+---------------+ | 1 | login | 2019-05-01 | | 1 | homepage | 2019-05-01 | | 1 | logout | 2019-05-01 | | 2 | login | 2019-06-21 | | 2 | logout | 2019-06-21 | | 3 | login | 2019-01-01 | | 3 | jobs | 2019-01-01 | | 3 | logout | 2019-01-01 | | 4 | login | 2019-06-21 | | 4 | groups | 2019-06-21 | | 4 | logout | 2019-06-21 | | 5 | login | 2019-03-01 | | 5 | logout | 2019-03-01 | | 5 | login | 2019-06-21 | | 5 | logout | 2019-06-21 | +---------+----------+---------------+ Result table: +------------+-------------+ | login_date | user_count | +------------+-------------+ | 2019-05-01 | 1 | | 2019-06-21 | 2 | +------------+-------------+   Solution 2020-10-09 Notes: SELECT activity_date AS login_date, COUNT(user_id) AS user_count FROM( SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY activity_date) AS nr FROM traffic WHERE activity = 'login' ) a WHERE nr = 1 and DATEDIFF('2019-06-30', activity_date) \u0026lt;= 90 GROUP BY 1  ","id":89,"section":"posts","summary":"LC 1107 New Users Daily Count   Write an SQL query that reports for every date within at most 90 days from today, the number of users that logged in for the first time on that date. Assume today is 2019-06-30.\nThe query result format is in the following example:\nTraffic table: +---------+----------+---------------+ | user_id | activity | activity_date | +---------+----------+---------------+ | 1 | login | 2019-05-01 | | 1 | homepage | 2019-05-01 | | 1 | logout | 2019-05-01 | | 2 | login | 2019-06-21 | | 2 | logout | 2019-06-21 | | 3 | login | 2019-01-01 | | 3 | jobs | 2019-01-01 | | 3 | logout | 2019-01-01 | | 4 | login | 2019-06-21 | | 4 | groups | 2019-06-21 | | 4 | logout | 2019-06-21 | | 5 | login | 2019-03-01 | | 5 | logout | 2019-03-01 | | 5 | login | 2019-06-21 | | 5 | logout | 2019-06-21 | +---------+----------+---------------+ Result table: +------------+-------------+ | login_date | user_count | +------------+-------------+ | 2019-05-01 | 1 | | 2019-06-21 | 2 | +------------+-------------+   Solution 2020-10-09 Notes: SELECT activity_date AS login_date, COUNT(user_id) AS user_count FROM( SELECT *, ROW_NUMBER() OVER(PARTITION BY user_id ORDER BY activity_date) AS nr FROM traffic WHERE activity = 'login' ) a WHERE nr = 1 and DATEDIFF('2019-06-30', activity_date) \u0026lt;= 90 GROUP BY 1  ","tags":["leetcode"],"title":"1107 New Users Daily Count","uri":"https://foxisawesome.github.io/posts/1107-new-users-daily-count/","year":"2020"},{"content":"LC 1484 Group Sold Products by the Date   Write an SQL query to find for each date, the number of distinct products sold and their names.\nThe sold-products names for each date should be sorted lexicographically.\nReturn the result table ordered by sell_date.\nThe query result format is in the following example.\nActivities table: +------------+-------------+ | sell_date | product | +------------+-------------+ | 2020-05-30 | Headphone | | 2020-06-01 | Pencil | | 2020-06-02 | Mask | | 2020-05-30 | Basketball | | 2020-06-01 | Bible | | 2020-06-02 | Mask | | 2020-05-30 | T-Shirt | +------------+-------------+ Result table: +------------+----------+------------------------------+ | sell_date | num_sold | products | +------------+----------+------------------------------+ | 2020-05-30 | 3 | Basketball,Headphone,T-shirt | | 2020-06-01 | 2 | Bible,Pencil | | 2020-06-02 | 1 | Mask | +------------+----------+------------------------------+   Solution 2020-10-09 Notes:  要用 GROUP_CONCAT( product ORDER BY date SEPARATOR ',')  SELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product ORDER BY product ASC SEPARATOR ',') AS products FROM activities GROUP BY sell_date ORDER BY sell_date  ","id":90,"section":"posts","summary":"LC 1484 Group Sold Products by the Date Write an SQL query to find for each date, the number of distinct products sold and their names. The sold-products names for each date should be sorted lexicographically. Return the result table ordered by sell_date. The query result format is in the following example. Activities table: +------------+-------------+ | sell_date | product | +------------+-------------+ | 2020-05-30 | Headphone | | 2020-06-01 | Pencil","tags":["leetcode","dia_sql"],"title":"1484 Group Sold Products by the Date","uri":"https://foxisawesome.github.io/posts/1484-group-sold-products-by-the-date/","year":"2020"},{"content":"LC 443 String Compression   Given an array of characters chars, compress it using the following algorithm:\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\n If the group\u0026rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group\u0026rsquo;s length.  The compressed string s should not be returned separately, but instead be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\nAfter you are done modifying the input array, return the new length of the array.\nFollow up: Could you solve it using only O(1) extra space?\n Solution 2020-10-09 Notes:  Algo 很intuitive，Space O(1) 实现起来稍微复杂一点。每个字母先count，然后写到chars的开头，要是count不到1，就不写count的str，要是超过9，就得 divmod开一位一位的写入chars。 完成for loop后，记得把stack里的没记录的记录一下。  class Solution: def compress(self, chars: List[str]) -\u0026gt; int: if not chars: return 0 c, l, stack = 0, chars[0], [] idx = 0 for char in chars: if char == l: c += 1 else: chars[idx] = l idx += 1 if c \u0026gt; 1: count_stk = [] while c \u0026gt; 0: c, r = divmod(c,10) count_stk.append(str(r)) while count_stk: chars[idx] = count_stk.pop() idx += 1 l, c = char, 1 chars[idx] = l idx += 1 if c \u0026gt; 1: count_stk = [] while c \u0026gt; 0: c, r = divmod(c,10) count_stk.append(str(r)) while count_stk: chars[idx] = count_stk.pop() idx += 1 return idx # Time O(N) # Space O(1)  ","id":91,"section":"posts","summary":"LC 443 String Compression Given an array of characters chars, compress it using the following algorithm: Begin with an empty string s. For each group of consecutive repeating characters in chars: If the group\u0026rsquo;s length is 1, append the character to s. Otherwise, append the character followed by the group\u0026rsquo;s length. The compressed string s should not be returned separately, but instead be stored in the input character array chars.","tags":["leetcode","string"],"title":"443 String Compression","uri":"https://foxisawesome.github.io/posts/443-string-compression/","year":"2020"},{"content":"LC 13 Roman to Integer   Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000  For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.  Given a roman numeral, convert it to an integer.\nInput: s = \u0026quot;MCMXCIV\u0026quot; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.   Solution 2020-10-09 Notes:  Easy 题，只要把所有的组合加到字典里。每次查找一位或者两位就好了。  class Solution: def romanToInt(self, s: str) -\u0026gt; int: d = {'I':1, 'IV':4, 'V':5, 'IX':9, 'X':10, 'XL':40, 'L':50, 'XC':90, 'C':100, 'CD':400, 'D':500, 'CM':900, 'M':1000} i, ans = 0, 0 n = len(s) while i \u0026lt; n: if i+1 \u0026lt; n and s[i]+s[i+1] in d: ans += d[s[i]+s[i+1]] i += 2 else: ans += d[s[i]] i += 1 return ans # Time O(N) # Space O(1)  ","id":92,"section":"posts","summary":"LC 13 Roman to Integer Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII,","tags":["leetcode","string"],"title":"13 Roman to Integer","uri":"https://foxisawesome.github.io/posts/13-roman-to-integer/","year":"2020"},{"content":"LC 6 Zigzag Conversion   The string \u0026quot;PAYPALISHIRING\u0026quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP A H N A P L S I I G Y I R  And then read line by line: \u0026quot;PAHNAPLSIIGYIR\u0026quot;\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);  Input: s = \u0026quot;PAYPALISHIRING\u0026quot;, numRows = 3 Output: \u0026quot;PAHNAPLSIIGYIR\u0026quot;   Solution 2020-10-09 Notes:  第一次做很痛苦，这次二刷感觉很简单。思路就是一个大while loop trace s，包含两个while loop， 第一个从上往下走，第二个从下往上走。  class Solution: def convert(self, s: str, numRows: int) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; matrix = [[] for i in range(numRows)] n = len(s) p = 0 while p \u0026lt; n: c = 0 while p \u0026lt; n and c \u0026lt; numRows: matrix[c].append(s[p]) p += 1 c += 1 c -= 2 while p \u0026lt; n and c \u0026gt; 0: matrix[c].append(s[p]) c -= 1 p += 1 ans = [''.join(i) for i in matrix] return ''.join(ans) # Time O(N) # Space O(N)  ","id":93,"section":"posts","summary":"LC 6 Zigzag Conversion The string \u0026quot;PAYPALISHIRING\u0026quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H N A P L S I I G Y I R And then read line by line: \u0026quot;PAHNAPLSIIGYIR\u0026quot; Write the code that will take a string and make this conversion given a","tags":["leetcode","string"],"title":"6 Zigzag Conversion","uri":"https://foxisawesome.github.io/posts/6-zigzag-conversion/","year":"2020"},{"content":"LC 347 Top K Frequent Elements   Given a non-empty array of integers, return the *k* most frequent elements.\nInput: nums = [1,1,1,2,2,3], k = 2 Output: [1,2]   Solution 2020-10-09 Notes:  这题要求 O(NlogN)就能过，那么把counter排下序就好了。  class Solution: def topKFrequent(self, nums: List[int], k: int) -\u0026gt; List[int]: count = collections.Counter(nums) ans = sorted(count, key = lambda x: (-count[x])) return ans[:k] # Time O(NlogN) # Space O(N)  ","id":94,"section":"posts","summary":"LC 347 Top K Frequent Elements Given a non-empty array of integers, return the *k* most frequent elements. Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Solution 2020-10-09 Notes: 这题要求 O(NlogN)就能过，那么把counter排下序就好了。 class Solution: def topKFrequent(self, nums: List[int], k:","tags":["leetcode","sort"],"title":"347 Top K Frequent Elements","uri":"https://foxisawesome.github.io/posts/347-top-k-frequent-elements/","year":"2020"},{"content":"LC 127 Word Ladder   Given two words (beginWord and endWord), and a dictionary\u0026rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\n Only one letter can be changed at a time. Each transformed word must exist in the word list.  Input: beginWord = \u0026quot;hit\u0026quot;, endWord = \u0026quot;cog\u0026quot;, wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;] Output: 5 Explanation: As one shortest transformation is \u0026quot;hit\u0026quot; -\u0026gt; \u0026quot;hot\u0026quot; -\u0026gt; \u0026quot;dot\u0026quot; -\u0026gt; \u0026quot;dog\u0026quot; -\u0026gt; \u0026quot;cog\u0026quot;, return its length 5.   Solution 2020-10-08 Notes:  用BFS做。很经典的是先建一个模糊查找的dictionary。h*t: [hot, hit, hat] 然后每一步，都在字典里查找当前word的模糊字。  class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u0026gt; int: if endWord not in wordList or not beginWord or not endWord or not wordList: return 0 d = collections.defaultdict(list) for i in range(len(beginWord)): for word in wordList: d[word[:i]+\u0026quot;*\u0026quot;+word[i+1:]].append(word) visited = set() visited.add(beginWord) queue = [(beginWord,1)] while queue: word, count = queue.pop(0) for l in range(len(word)): temp_w = word[:l]+\u0026quot;*\u0026quot;+word[l+1:] for j in d[temp_w]: if j == endWord: return count+1 elif j not in visited: visited.add(j) queue.append((j, count+1)) return 0 # Time O(len(word)^2*N) # Space O(len(word)^2*N)  ","id":95,"section":"posts","summary":"LC 127 Word Ladder Given two words (beginWord and endWord), and a dictionary\u0026rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: Only one letter can be changed at a time. Each transformed word must exist in the word list. Input: beginWord = \u0026quot;hit\u0026quot;, endWord = \u0026quot;cog\u0026quot;, wordList = [\u0026quot;hot\u0026quot;,\u0026quot;dot\u0026quot;,\u0026quot;dog\u0026quot;,\u0026quot;lot\u0026quot;,\u0026quot;log\u0026quot;,\u0026quot;cog\u0026quot;] Output: 5 Explanation: As one shortest transformation is \u0026quot;hit\u0026quot; -\u0026gt; \u0026quot;hot\u0026quot; -\u0026gt; \u0026quot;dot\u0026quot; -\u0026gt;","tags":["leetcode","BFS","hashtable","dia"],"title":"127 Word Ladder","uri":"https://foxisawesome.github.io/posts/127-word-ladder/","year":"2020"},{"content":"LC 468 Validate Ip Address   Given a string IP, return \u0026quot;IPv4\u0026quot; if IP is a valid IPv4 address, \u0026quot;IPv6\u0026quot; if IP is a valid IPv6 address or \u0026quot;Neither\u0026quot; if IP is not a correct IP of any type.\nA valid IPv4 address is an IP in the form \u0026quot;x1.x2.x3.x4\u0026quot; where 0 \u0026lt;= xi \u0026lt;= 255 and xi cannot contain leading zeros. For example, \u0026quot;192.168.1.1\u0026quot; and \u0026quot;192.168.1.0\u0026quot; are valid IPv4 addresses but \u0026quot;192.168.01.1\u0026quot;, while \u0026quot;192.168.1.00\u0026quot; and \u0026quot;192.168@1.1\u0026quot; are invalid IPv4 addresses.\nA valid IPv6 address is an IP in the form \u0026quot;x1:x2:x3:x4:x5:x6:x7:x8\u0026quot; where:\n 1 \u0026lt;= xi.length \u0026lt;= 4 xi is a hexadecimal string which may contain digits, lower-case English letter ('a' to 'f') and upper-case English letters ('A' to 'F'). Leading zeros are allowed in xi.  For example, \u0026ldquo;2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot; and \u0026ldquo;2001:db8:85a3:0:0:8A2E:0370:7334\u0026quot; are valid IPv6 addresses, while \u0026ldquo;2001:0db8:85a3::8A2E:037j:7334\u0026quot; and \u0026ldquo;02001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot; are invalid IPv6 addresses.\n Solution 2020-10-08 Notes:  纯粹把rules 打一遍。  class Solution: def validIPAddress(self, IP: str) -\u0026gt; str: if IP.count('.')==3: ip = IP.split('.') for i in ip: digit = 0 ni4 = len(i) if ni4 \u0026gt; 3 or ni4 ==0: return 'Neither' for j in i: if (j.isdigit() and i[0]!='0') or (i[0]=='0' and ni4==1): digit = digit*10 + ord(j) - ord('0') else: return 'Neither' if not 0\u0026lt;= digit \u0026lt;= 255: return 'Neither' return 'IPv4' elif IP.count(':')==7: ip = IP.split(':') for i8 in ip: ni8 = len(i8) if 1\u0026lt;=ni8\u0026lt;=4: for j in i8: if j.isdigit(): continue elif not (j.isalpha() and ('A'\u0026lt;=j\u0026lt;='F' or 'a'\u0026lt;=j\u0026lt;='f')): return 'Neither' else: return 'Neither' return 'IPv6' else: return 'Neither' # Time O(N) # Space O(1)  ","id":96,"section":"posts","summary":"LC 468 Validate Ip Address Given a string IP, return \u0026quot;IPv4\u0026quot; if IP is a valid IPv4 address, \u0026quot;IPv6\u0026quot; if IP is a valid IPv6 address or \u0026quot;Neither\u0026quot; if IP is not a correct IP of any type. A valid IPv4 address is an IP in the form \u0026quot;x1.x2.x3.x4\u0026quot; where 0 \u0026lt;= xi \u0026lt;= 255 and xi cannot contain leading zeros. For example, \u0026quot;192.168.1.1\u0026quot; and \u0026quot;192.168.1.0\u0026quot; are valid IPv4 addresses","tags":["leetcode","string"],"title":"468 Validate Ip Address","uri":"https://foxisawesome.github.io/posts/468-validate-ip-address/","year":"2020"},{"content":"LC 595 Big Countries   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\n Solution 2020-10-08 Notes:   #Union solution is actually faster than using #or.\n  Why Union is faster than OR?\nStrictly speaking, Using UNION is faster when it comes to cases like scan two different column like this\n  SELECT name, population, area FROM World WHERE area \u0026gt; 3000000 UNION SELECT name, population, area FROM World WHERE population \u0026gt; 25000000   #or solution  #OR SELECT name, population, area FROM World WHERE area \u0026gt; 3000000 OR population \u0026gt; 25000000  ","id":97,"section":"posts","summary":"LC 595 Big Countries   A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million.\nWrite a SQL solution to output big countries' name, population and area.\n Solution 2020-10-08 Notes:   #Union solution is actually faster than using #or.\n  Why Union is faster than OR?\nStrictly speaking, Using UNION is faster when it comes to cases like scan two different column like this","tags":["leetcode"],"title":"595 Big Countries","uri":"https://foxisawesome.github.io/posts/595-big-countries/","year":"2020"},{"content":"LC 596 Classes More Than 5 Students   There is a table courses with columns: student and class\nPlease list out all classes which have more than or equal to 5 students.\n Solution 2020-10-08 Notes: SELECT DISTINCT class FROM ( SELECT *, COUNT(student) OVER(PARTITION BY class) AS ct FROM (SELECT DISTINCT student, class FROM courses) b ) a WHERE ct \u0026gt;= 5  ","id":98,"section":"posts","summary":"LC 596 Classes More Than 5 Students   There is a table courses with columns: student and class\nPlease list out all classes which have more than or equal to 5 students.\n Solution 2020-10-08 Notes: SELECT DISTINCT class FROM ( SELECT *, COUNT(student) OVER(PARTITION BY class) AS ct FROM (SELECT DISTINCT student, class FROM courses) b ) a WHERE ct \u0026gt;= 5  ","tags":["leetcode"],"title":"596 Classes More Than 5 Students","uri":"https://foxisawesome.github.io/posts/596-classes-more-than-5-students/","year":"2020"},{"content":"LC 1532 the Most Recent Three Orders   Write an SQL query to find the most recent 3 orders of each user. If a user ordered less than 3 orders return all of their orders.\nReturn the result table sorted by customer_name in ascending order and in case of a tie by the customer_id in ascending order. If there still a tie, order them by the order_date in descending order.\n Solution 2020-10-08 Notes: SELECT name AS customer_name, a.customer_id, order_id, order_date FROM( SELECT *, ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date DESC) as nr FROM orders ) a JOIN customers b ON a.customer_id = b.customer_id and a.nr \u0026lt;= 3 ORDER BY 1, 2, 4 DESC  ","id":99,"section":"posts","summary":"LC 1532 the Most Recent Three Orders   Write an SQL query to find the most recent 3 orders of each user. If a user ordered less than 3 orders return all of their orders.\nReturn the result table sorted by customer_name in ascending order and in case of a tie by the customer_id in ascending order. If there still a tie, order them by the order_date in descending order.","tags":["leetcode"],"title":"1532 the Most Recent Three Orders","uri":"https://foxisawesome.github.io/posts/1532-the-most-recent-three-orders/","year":"2020"},{"content":"LC 1607 Sellers With No Sales   Write an SQL query to report the names of all sellers who did not make any sales in 2020.\nReturn the result table ordered by seller_name in ascending order.\n Solution 2020-10-08 Notes: SELECT DISTINCT seller_name FROM seller WHERE seller_id NOT IN (SELECT seller_id FROM orders WHERE LEFT(sale_date,4)=2020) ORDER BY 1  ","id":100,"section":"posts","summary":"LC 1607 Sellers With No Sales   Write an SQL query to report the names of all sellers who did not make any sales in 2020.\nReturn the result table ordered by seller_name in ascending order.\n Solution 2020-10-08 Notes: SELECT DISTINCT seller_name FROM seller WHERE seller_id NOT IN (SELECT seller_id FROM orders WHERE LEFT(sale_date,4)=2020) ORDER BY 1  ","tags":["leetcode"],"title":"1607 Sellers With No Sales","uri":"https://foxisawesome.github.io/posts/1607-sellers-with-no-sales/","year":"2020"},{"content":"LC 1152 Analyze User Website Visit Pattern   We are given some website visits: the user with name username[i] visited the website website[i] at time timestamp[i].\nA 3-sequence is a list of websites of length 3 sorted in ascending order by the time of their visits. (The websites in a 3-sequence are not necessarily distinct.)\nFind the 3-sequence visited by the largest number of users. If there is more than one solution, return the lexicographically smallest such 3-sequence.\nInput: username = [\u0026quot;joe\u0026quot;,\u0026quot;joe\u0026quot;,\u0026quot;joe\u0026quot;,\u0026quot;james\u0026quot;,\u0026quot;james\u0026quot;,\u0026quot;james\u0026quot;,\u0026quot;james\u0026quot;,\u0026quot;mary\u0026quot;,\u0026quot;mary\u0026quot;,\u0026quot;mary\u0026quot;], timestamp = [1,2,3,4,5,6,7,8,9,10], website = [\u0026quot;home\u0026quot;,\u0026quot;about\u0026quot;,\u0026quot;career\u0026quot;,\u0026quot;home\u0026quot;,\u0026quot;cart\u0026quot;,\u0026quot;maps\u0026quot;,\u0026quot;home\u0026quot;,\u0026quot;home\u0026quot;,\u0026quot;about\u0026quot;,\u0026quot;career\u0026quot;] Output: [\u0026quot;home\u0026quot;,\u0026quot;about\u0026quot;,\u0026quot;career\u0026quot;] Explanation: The tuples in this example are: [\u0026quot;joe\u0026quot;, 1, \u0026quot;home\u0026quot;] [\u0026quot;joe\u0026quot;, 2, \u0026quot;about\u0026quot;] [\u0026quot;joe\u0026quot;, 3, \u0026quot;career\u0026quot;] [\u0026quot;james\u0026quot;, 4, \u0026quot;home\u0026quot;] [\u0026quot;james\u0026quot;, 5, \u0026quot;cart\u0026quot;] [\u0026quot;james\u0026quot;, 6, \u0026quot;maps\u0026quot;] [\u0026quot;james\u0026quot;, 7, \u0026quot;home\u0026quot;] [\u0026quot;mary\u0026quot;, 8, \u0026quot;home\u0026quot;] [\u0026quot;mary\u0026quot;, 9, \u0026quot;about\u0026quot;] [\u0026quot;mary\u0026quot;, 10, \u0026quot;career\u0026quot;] The 3-sequence (\u0026quot;home\u0026quot;, \u0026quot;about\u0026quot;, \u0026quot;career\u0026quot;) was visited at least once by 2 users. The 3-sequence (\u0026quot;home\u0026quot;, \u0026quot;cart\u0026quot;, \u0026quot;maps\u0026quot;) was visited at least once by 1 user. The 3-sequence (\u0026quot;home\u0026quot;, \u0026quot;cart\u0026quot;, \u0026quot;home\u0026quot;) was visited at least once by 1 user. The 3-sequence (\u0026quot;home\u0026quot;, \u0026quot;maps\u0026quot;, \u0026quot;home\u0026quot;) was visited at least once by 1 user. The 3-sequence (\u0026quot;cart\u0026quot;, \u0026quot;maps\u0026quot;, \u0026quot;home\u0026quot;) was visited at least once by 1 user.   Solution 2020-10-08 Notes:  这题学了了好几个API：itertools, zip, min(key)。题目描述的很复杂, algo本身很intuitive。 Itertool.combination 为了防着dups，要用set输出。 List1 根据list2 排序，先zip() 然后 sorted(), 默认按照第一个argument sort 输出 dictionary val最大/小值时，可以用min(a, key = lambda x: (-d[x], x))  class Solution: def mostVisitedPattern(self, username: List[str], timestamp: List[int], website: List[str]) -\u0026gt; List[str]: # website = [x for _,x in sorted(zip(timestamp,website))] packed_tuple = zip(timestamp, username, website) sorted_packed_tuple = sorted(packed_tuple) user = collections.defaultdict(list) for t, u, w in sorted_packed_tuple: user[u].append(w) count = collections.Counter() for k, val in user.items(): if len(val) \u0026lt; 3: continue combo = set(itertools.combinations(val,3)) for com in combo: count[com] += 1 return list(min(count, key= lambda x: (-count[x],x))) # Time O(N) # Space O(N)  ","id":101,"section":"posts","summary":"LC 1152 Analyze User Website Visit Pattern We are given some website visits: the user with name username[i] visited the website website[i] at time timestamp[i]. A 3-sequence is a list of websites of length 3 sorted in ascending order by the time of their visits. (The websites in a 3-sequence are not necessarily distinct.) Find the 3-sequence visited by the largest number of users. If there is more than one","tags":["leetcode","dia"],"title":"1152 Analyze User Website Visit Pattern","uri":"https://foxisawesome.github.io/posts/1152-analyze-user-website-visit-pattern/","year":"2020"},{"content":"LC 1350 Students With Invalid Departments   Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.\nReturn the result table in any order.\nThe query result format is in the following example:\nDepartments table: +------+--------------------------+ | id | name | +------+--------------------------+ | 1 | Electrical Engineering | | 7 | Computer Engineering | | 13 | Bussiness Administration | +------+--------------------------+ Students table: +------+----------+---------------+ | id | name | department_id | +------+----------+---------------+ | 23 | Alice | 1 | | 1 | Bob | 7 | | 5 | Jennifer | 13 | | 2 | John | 14 | | 4 | Jasmine | 77 | | 3 | Steve | 74 | | 6 | Luis | 1 | | 8 | Jonathan | 7 | | 7 | Daiana | 33 | | 11 | Madelynn | 1 | +------+----------+---------------+ Result table: +------+----------+ | id | name | +------+----------+ | 2 | John | | 7 | Daiana | | 4 | Jasmine | | 3 | Steve | +------+----------+ John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively. department 14, 33, 74 and 77 doesn't exist in the Departments table.   Solution 2020-10-07 Notes: SELECT id, name FROM students WHERE department_id NOT IN (SELECT DISTINCT id FROM departments)  ","id":102,"section":"posts","summary":"LC 1350 Students With Invalid Departments   Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.\nReturn the result table in any order.\nThe query result format is in the following example:\nDepartments table: +------+--------------------------+ | id | name | +------+--------------------------+ | 1 | Electrical Engineering | | 7 | Computer Engineering | | 13 | Bussiness Administration | +------+--------------------------+ Students table: +------+----------+---------------+ | id | name | department_id | +------+----------+---------------+ | 23 | Alice | 1 | | 1 | Bob | 7 | | 5 | Jennifer | 13 | | 2 | John | 14 | | 4 | Jasmine | 77 | | 3 | Steve | 74 | | 6 | Luis | 1 | | 8 | Jonathan | 7 | | 7 | Daiana | 33 | | 11 | Madelynn | 1 | +------+----------+---------------+ Result table: +------+----------+ | id | name | +------+----------+ | 2 | John | | 7 | Daiana | | 4 | Jasmine | | 3 | Steve | +------+----------+ John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively.","tags":["leetcode"],"title":"1350 Students With Invalid Departments","uri":"https://foxisawesome.github.io/posts/1350-students-with-invalid-departments/","year":"2020"},{"content":"LC 1174 Immediate Food Delivery II   Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places.\nThe query result format is in the following example:\nDelivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 2 | 2019-08-02 | 2019-08-02 | | 3 | 1 | 2019-08-11 | 2019-08-12 | | 4 | 3 | 2019-08-24 | 2019-08-24 | | 5 | 3 | 2019-08-21 | 2019-08-22 | | 6 | 2 | 2019-08-11 | 2019-08-13 | | 7 | 4 | 2019-08-09 | 2019-08-09 | +-------------+-------------+------------+-----------------------------+ Result table: +----------------------+ | immediate_percentage | +----------------------+ | 50.00 | +----------------------+ The customer id 1 has a first order with delivery id 1 and it is scheduled. The customer id 2 has a first order with delivery id 2 and it is immediate. The customer id 3 has a first order with delivery id 5 and it is scheduled. The customer id 4 has a first order with delivery id 7 and it is immediate. Hence, half the customers have immediate first orders.   Solution 2020-10-07 Notes: SELECT ROUND( IFNULL( SUM(CASE WHEN order_date = customer_pref_delivery_date THEN 1 ELSE 0 END) / SUM(1) * 100, 0) ,2) AS immediate_percentage FROM( SELECT *, ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date) AS nr FROM delivery ) a WHERE nr = 1  这种写法是不对的，因为 group by 会使用第一条record，id = 3 就会被漏掉这种情况。\nselect customer_id, order_date, min(order_date) from Delivery a GROUP BY customer_id HAVING order_date = min(order_date)  ","id":103,"section":"posts","summary":"LC 1174 Immediate Food Delivery II Write an SQL query to find the percentage of immediate orders in the first orders of all customers, rounded to 2 decimal places. The query result format is in the following example: Delivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 2 | 2019-08-02 | 2019-08-02 | |","tags":["leetcode"],"title":"1174 Immediate Food Delivery II","uri":"https://foxisawesome.github.io/posts/1174-immediate-food-delivery-ii/","year":"2020"},{"content":"LC 1173 Immediate Food Delivery I   Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.\nThe query result format is in the following example:\nDelivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 5 | 2019-08-02 | 2019-08-02 | | 3 | 1 | 2019-08-11 | 2019-08-11 | | 4 | 3 | 2019-08-24 | 2019-08-26 | | 5 | 4 | 2019-08-21 | 2019-08-22 | | 6 | 2 | 2019-08-11 | 2019-08-13 | +-------------+-------------+------------+-----------------------------+ Result table: +----------------------+ | immediate_percentage | +----------------------+ | 33.33 | +----------------------+   Solution 2020-10-07 Notes: SELECT ROUND(IFNULL( SUM(CASE WHEN order_date=customer_pref_delivery_date THEN 1 ELSE 0 END) / COUNT(delivery_id) *100 ,0), 2) AS immediate_percentage FROM ( SELECT distinct delivery_id, customer_id, order_date, customer_pref_delivery_date FROM delivery ) a  ","id":104,"section":"posts","summary":"LC 1173 Immediate Food Delivery I   Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal places.\nThe query result format is in the following example:\nDelivery table: +-------------+-------------+------------+-----------------------------+ | delivery_id | customer_id | order_date | customer_pref_delivery_date | +-------------+-------------+------------+-----------------------------+ | 1 | 1 | 2019-08-01 | 2019-08-02 | | 2 | 5 | 2019-08-02 | 2019-08-02 | | 3 | 1 | 2019-08-11 | 2019-08-11 | | 4 | 3 | 2019-08-24 | 2019-08-26 | | 5 | 4 | 2019-08-21 | 2019-08-22 | | 6 | 2 | 2019-08-11 | 2019-08-13 | +-------------+-------------+------------+-----------------------------+ Result table: +----------------------+ | immediate_percentage | +----------------------+ | 33.","tags":["leetcode"],"title":"1173 Immediate Food Delivery I","uri":"https://foxisawesome.github.io/posts/1173-immediate-food-delivery-i/","year":"2020"},{"content":"LC 763 Partition Labels   A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\nInput: S = \u0026quot;ababcbacadefegdehijhklij\u0026quot; Output: [9,7,8] Explanation: The partition is \u0026quot;ababcbaca\u0026quot;, \u0026quot;defegde\u0026quot;, \u0026quot;hijhklij\u0026quot;. This is a partition so that each letter appears in at most one part. A partition like \u0026quot;ababcbacadefegde\u0026quot;, \u0026quot;hijhklij\u0026quot; is incorrect, because it splits S into less parts.   Solution 2020-10-07 Notes:  好妙的题。algo: 用一个字典保存所有distinct 字母的最大index。 在for loop里每次更新当前字母的远距离，然后当前index正好等于所有扫过的字母的最远距离时，那么就有了longest common string。  class Solution: def partitionLabels(self, S: str) -\u0026gt; List[int]: d = dict() for i, val in enumerate(S): d[val] = i l, r = 0, 0 ans = [] for i, val in enumerate(S): r = max(r, d[val]) if i == r: ans.append(r-l+1) l = i + 1 return ans # Time O(N) # Space O(N)  ","id":105,"section":"posts","summary":"LC 763 Partition Labels A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts. Input: S = \u0026quot;ababcbacadefegdehijhklij\u0026quot; Output: [9,7,8] Explanation: The partition is \u0026quot;ababcbaca\u0026quot;, \u0026quot;defegde\u0026quot;, \u0026quot;hijhklij\u0026quot;. This is a partition so that each letter appears in","tags":["leetcode","string"],"title":"763 Partition Labels","uri":"https://foxisawesome.github.io/posts/763-partition-labels/","year":"2020"},{"content":"LC 1285 Find the Start and End Number of Continuous Ranges   Write an SQL query to find the start and end number of continuous ranges in table Logs.\nOrder the result table by start_id.\nThe query result format is in the following example:\nLogs table: +------------+ | log_id | +------------+ | 1 | | 2 | | 3 | | 7 | | 8 | | 10 | +------------+ Result table: +------------+--------------+ | start_id | end_id | +------------+--------------+ | 1 | 3 | | 7 | 8 | | 10 | 10 | +------------+--------------+   Solution 2020-10-06 Notes:  经典题！背下来吧  SELECT MIN(log_id) AS start_id, MAX(log_id) AS end_id FROM ( SELECT log_id, ROW_NUMBER() OVER(ORDER BY log_id) AS nr FROM logs ) a GROUP BY log_id - nr  ","id":106,"section":"posts","summary":"LC 1285 Find the Start and End Number of Continuous Ranges Write an SQL query to find the start and end number of continuous ranges in table Logs. Order the result table by start_id. The query result format is in the following example: Logs table: +------------+ | log_id | +------------+ | 1 | | 2 | | 3 | | 7 | | 8 | | 10 | +------------+ Result","tags":["leetcode","dia_sql"],"title":"1285 Find the Start and End Number of Continuous Ranges","uri":"https://foxisawesome.github.io/posts/1285-find-the-start-and-end-number-of-continuous-ranges/","year":"2020"},{"content":"LC 626 Exchange Seats   Can you write a SQL query to output the result for Mary?\n+---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+  For the sample input, the output is:\n+---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+   Solution 2020-10-06 Notes: SELECT CASE WHEN MOD(id, 2) = 1 AND id != ct THEN id + 1 WHEN MOD(id, 2) = 1 AND id = ct THEN id ELSE id - 1 END AS id, student FROM seat, (SELECT COUNT(DISTINCT id) AS ct FROM seat) a ORDER BY id  ","id":107,"section":"posts","summary":"LC 626 Exchange Seats   Can you write a SQL query to output the result for Mary?\n+---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+  For the sample input, the output is:\n+---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+   Solution 2020-10-06 Notes: SELECT CASE WHEN MOD(id, 2) = 1 AND id !","tags":["leetcode","dia"],"title":"626 Exchange Seats","uri":"https://foxisawesome.github.io/posts/626-exchange-seats/","year":"2020"},{"content":"LC 55 Jump Game   Given an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.   Solution 2020-10-06 Notes:  这题好妙。 以下是greedy的方法。每一步检查当前的 index 与 reach的关系。要不满足就False。 online updating reach。  class Solution: def canJump(self, nums: List[int]) -\u0026gt; bool: reach, n = 0, len(nums) for i, val in enumerate(nums): if i \u0026gt; reach: return False reach = max(reach, i+val) return True # Time O(N) # Space O(1)  超时严重的dfs。。。\nclass Solution: def canJump(self, nums: List[int]) -\u0026gt; bool: n = len(nums) if self.dfs(nums, n, 0): return True return False def dfs(self, nums,n, path): if path+nums[path] \u0026gt;= n-1: return True for i in range(1,nums[path]+1): if path + i \u0026lt;= n-1: if self.dfs(nums, n, path+i): return True  ","id":108,"section":"posts","summary":"LC 55 Jump Game Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Solution 2020-10-06 Notes: 这","tags":["leetcode","greedy","dp","dfs"],"title":"55 Jump Game","uri":"https://foxisawesome.github.io/posts/55-jump-game/","year":"2020"},{"content":"LC 1194 Tournament Winners   The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins.\nWrite an SQL query to find the winner in each group.\nThe query result format is in the following example:\nPlayers table: +-----------+------------+ | player_id | group_id | +-----------+------------+ | 15 | 1 | | 25 | 1 | | 30 | 1 | | 45 | 1 | | 10 | 2 | | 35 | 2 | | 50 | 2 | | 20 | 3 | | 40 | 3 | +-----------+------------+ Matches table: +------------+--------------+---------------+-------------+--------------+ | match_id | first_player | second_player | first_score | second_score | +------------+--------------+---------------+-------------+--------------+ | 1 | 15 | 45 | 3 | 0 | | 2 | 30 | 25 | 1 | 2 | | 3 | 30 | 15 | 2 | 0 | | 4 | 40 | 20 | 5 | 2 | | 5 | 35 | 50 | 1 | 1 | +------------+--------------+---------------+-------------+--------------+ Result table: +-----------+------------+ | group_id | player_id | +-----------+------------+ | 1 | 15 | | 2 | 35 | | 3 | 40 | +-----------+------------+   Solution 2020-10-05 Notes:  好多subquery的hard 题，要习惯用union all  WITH all_match AS (SELECT first_player AS player, first_score AS score FROM matches UNION ALL SELECT second_player AS player, second_score AS score FROM matches ), score AS (SELECT player, SUM(score) AS score FROM all_match GROUP BY 1) SELECT group_id, player_id FROM ( SELECT b.player_id, b.group_id, DENSE_RANK() OVER(PARTITION BY b.group_id ORDER BY a.score DESC, player) AS rk FROM score a JOIN players b ON a.player = b.player_id ) c WHERE rk = 1 ORDER BY 1,2  ","id":109,"section":"posts","summary":"LC 1194 Tournament Winners The winner in each group is the player who scored the maximum total points within the group. In the case of a tie, the lowest player_id wins. Write an SQL query to find the winner in each group. The query result format is in the following example: Players table: +-----------+------------+ | player_id | group_id | +-----------+------------+ | 15 | 1 | | 25 | 1 |","tags":["leetcode","dia_sql"],"title":"1194 Tournament Winners","uri":"https://foxisawesome.github.io/posts/1194-tournament-winners/","year":"2020"},{"content":"LC 571 Find Median Given Frequency of Numbers   The Numbers table keeps the value of number and its frequency.\n+----------+-------------+ | Number | Frequency | +----------+-------------| | 0 | 7 | | 1 | 1 | | 2 | 3 | | 3 | 1 | +----------+-------------+  In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0 + 0) / 2 = 0.\n+--------+ | median | +--------| | 0.0000 | +--------+  Write a query to find the median of all numbers and name the result as median.\n Solution 2020-10-05 Notes:  WHERE cum_freq BETWEEN tot/2 AND tot/2+frequency关键是这个condition！  SELECT AVG(number) AS median FROM( SELECT number, frequency, SUM(frequency) OVER(ORDER BY number) AS cum_freq, SUM(frequency) OVER() AS tot FROM numbers ) a WHERE cum_freq BETWEEN tot/2 AND tot/2+frequency  ","id":110,"section":"posts","summary":"LC 571 Find Median Given Frequency of Numbers The Numbers table keeps the value of number and its frequency. +----------+-------------+ | Number | Frequency | +----------+-------------| | 0 | 7 | | 1 | 1 | | 2 | 3 | | 3 | 1 | +----------+-------------+ In this table, the numbers are 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 3, so the median is (0","tags":["leetcode","dia_sql"],"title":"571 Find Median Given Frequency of Numbers","uri":"https://foxisawesome.github.io/posts/571-find-median-given-frequency-of-numbers/","year":"2020"},{"content":"LC 569 Median Employee Salary   The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary.\n+-----+------------+--------+ |Id | Company | Salary | +-----+------------+--------+ |1 | A | 2341 | |2 | A | 341 | |3 | A | 15 | |4 | A | 15314 | |5 | A | 451 | |6 | A | 513 | |7 | B | 15 | |8 | B | 13 | |9 | B | 1154 | |10 | B | 1345 | |11 | B | 1221 | |12 | B | 234 | |13 | C | 2345 | |14 | C | 2645 | |15 | C | 2645 | |16 | C | 2652 | |17 | C | 65 | +-----+------------+--------+  Write a SQL query to find the median salary of each company. Bonus points if you can solve it without using any built-in SQL functions.\n+-----+------------+--------+ |Id | Company | Salary | +-----+------------+--------+ |5 | A | 451 | |6 | A | 513 | |12 | B | 234 | |9 | B | 1154 | |14 | C | 2645 | +-----+------------+--------+   Solution 2020-10-05 Notes:  求median的标准模版。 Between 一定要先小后大。  SELECT id, company, salary FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY company ORDER BY salary,id) AS n_asc, ROW_NUMBER() OVER(PARTITION BY company ORDER BY salary DESC,id DESC) AS n_desc FROM employee ) a WHERE n_asc BETWEEN n_desc-1 AND n_desc + 1 ORDER BY 2,3 ;  另一种写法。\nSELECT id, company, salary FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY company ORDER BY salary) AS asc_row, COUNT(*) OVER(PARTITION BY company) - ROW_NUMBER() OVER(PARTITION BY company ORDER BY salary) + 1 AS desc_row FROM employee ) a WHERE asc_row BETWEEN desc_row - 1 and desc_row + 1 ORDER BY company, salary  ","id":111,"section":"posts","summary":"LC 569 Median Employee Salary The Employee table holds all employees. The employee table has three columns: Employee Id, Company Name, and Salary. +-----+------------+--------+ |Id | Company | Salary | +-----+------------+--------+ |1 | A | 2341 | |2 | A | 341 | |3 | A | 15 | |4 | A | 15314 | |5 | A | 451 | |6 | A | 513 | |7 | B","tags":["leetcode","dia_sql"],"title":"569 Median Employee Salary","uri":"https://foxisawesome.github.io/posts/569-median-employee-salary/","year":"2020"},{"content":"LC 107 Binary Tree Level Order Traversal II   Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return its bottom-up level order traversal as:\n[ [15,7], [9,20], [3] ]   Solution 2020-10-05 Notes:  学习了 负雪明烛 的 recursive 答案。很高效之要一个2-d array, one pass.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return None self.ans = [] self.preOrder(root, 0) return self.ans[::-1] def preOrder(self, root, h): if not root: return None if h \u0026gt;= len(self.ans): self.ans.append([]) self.ans[h].append(root.val) self.preOrder(root.left, h+1) self.preOrder(root.right, h+1)   iterative solution, BFS  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return None queue, ans = [root], [] h = 0 while queue: n = len(queue) ans.append([]) for i in range(n): node = queue.pop(0) ans[h].append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) h += 1 return ans[::-1] # Time O(N) # Space O(N)   自己写的用字典的方法。不够高效  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return None self.d = collections.defaultdict(list) self.postOrder(root, 1) n = len(self.d) ans = [] for i in range(n,0,-1): ans.append(self.d[i]) return ans def postOrder(self, root, h): if not root: return None self.postOrder(root.left, h+1) self.postOrder(root.right, h+1) self.d[h].append(root.val) # Time O(N) # Space O(N)  ","id":112,"section":"posts","summary":"LC 107 Binary Tree Level Order Traversal II Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution 2020-10-05 Notes: 学习了 负雪明","tags":["leetcode","tree"],"title":"107 Binary Tree Level Order Traversal II","uri":"https://foxisawesome.github.io/posts/107-binary-tree-level-order-traversal-ii/","year":"2020"},{"content":"LC 1454 Active Users   Write an SQL query to find the id and the name of active users.\nActive users are those who logged in to their accounts for 5 or more consecutive days.\nReturn the result table ordered by the id.\nThe query result format is in the following example:\nAccounts table: +----+----------+ | id | name | +----+----------+ | 1 | Winston | | 7 | Jonathan | +----+----------+ Logins table: +----+------------+ | id | login_date | +----+------------+ | 7 | 2020-05-30 | | 1 | 2020-05-30 | | 7 | 2020-05-31 | | 7 | 2020-06-01 | | 7 | 2020-06-02 | | 7 | 2020-06-02 | | 7 | 2020-06-03 | | 1 | 2020-06-07 | | 7 | 2020-06-10 | +----+------------+ Result table: +----+----------+ | id | name | +----+----------+ | 7 | Jonathan | +----+----------+   Solution 2020-10-04 Notes:  consecutive 5 days: DATEDIFF(date, LEAD(date,4)) = 4  SELECT DISTINCT a.id, a.name FROM accounts a JOIN ( SELECT id, login_date, LEAD(login_date,4) OVER(PARTITION BY id ORDER BY login_date) AS date_lead FROM (SELECT DISTINCT id, login_date FROM logins) c ) b ON a.id = b.id AND DATEDIFF(date_lead, login_date) = 4 ORDER BY id  ","id":113,"section":"posts","summary":"LC 1454 Active Users   Write an SQL query to find the id and the name of active users.\nActive users are those who logged in to their accounts for 5 or more consecutive days.\nReturn the result table ordered by the id.\nThe query result format is in the following example:\nAccounts table: +----+----------+ | id | name | +----+----------+ | 1 | Winston | | 7 | Jonathan | +----+----------+ Logins table: +----+------------+ | id | login_date | +----+------------+ | 7 | 2020-05-30 | | 1 | 2020-05-30 | | 7 | 2020-05-31 | | 7 | 2020-06-01 | | 7 | 2020-06-02 | | 7 | 2020-06-02 | | 7 | 2020-06-03 | | 1 | 2020-06-07 | | 7 | 2020-06-10 | +----+------------+ Result table: +----+----------+ | id | name | +----+----------+ | 7 | Jonathan | +----+----------+   Solution 2020-10-04 Notes:  consecutive 5 days: DATEDIFF(date, LEAD(date,4)) = 4  SELECT DISTINCT a.","tags":["leetcode"],"title":"1454 Active Users","uri":"https://foxisawesome.github.io/posts/1454-active-users/","year":"2020"},{"content":"LC 579 Find Cumulative Salary of an Employee   The Employee table holds the salary information in a year.\nWrite a SQL to get the cumulative sum of an employee\u0026rsquo;s salary over a period of 3 months but exclude the most recent month.\nThe result should be displayed by \u0026lsquo;Id\u0026rsquo; ascending, and then by \u0026lsquo;Month\u0026rsquo; descending.\nExample Input\n| Id | Month | Salary | |----|-------|--------| | 1 | 1 | 20 | | 2 | 1 | 20 | | 1 | 2 | 30 | | 2 | 2 | 30 | | 3 | 2 | 40 | | 1 | 3 | 40 | | 3 | 3 | 60 | | 1 | 4 | 60 | | 3 | 4 | 70 |  Output\n| Id | Month | Salary | |----|-------|--------| | 1 | 3 | 90 | | 1 | 2 | 50 | | 1 | 1 | 20 | | 2 | 1 | 20 | | 3 | 3 | 100 | | 3 | 2 | 40 |   Solution 2020-10-04 Notes:  cumulative sum 用 SUM() OVER(PARTITION BY ORDER BY) most recent 用ROW_NUMBER() OVER() rolling window 3-month 用 SUM()OVER(ROWS 2 PRECEDING)  SELECT id, month, salary FROM( SELECT id, month, SUM(salary) OVER(PARTITION BY id ORDER BY month ROWS 2 PRECEDING) AS salary, ROW_NUMBER() OVER(PARTITION BY id ORDER BY month DESC) AS nr FROM employee ) a WHERE nr \u0026gt; 1  ","id":114,"section":"posts","summary":"LC 579 Find Cumulative Salary of an Employee The Employee table holds the salary information in a year. Write a SQL to get the cumulative sum of an employee\u0026rsquo;s salary over a period of 3 months but exclude the most recent month. The result should be displayed by \u0026lsquo;Id\u0026rsquo; ascending, and then by \u0026lsquo;Month\u0026rsquo; descending. Example Input | Id | Month | Salary | |----|-------|--------| | 1 | 1 |","tags":["leetcode","dia_sql"],"title":"579 Find Cumulative Salary of an Employee","uri":"https://foxisawesome.github.io/posts/579-find-cumulative-salary-of-an-employee/","year":"2020"},{"content":"LC 1075 Project Employees I   Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.\nThe query result format is in the following example:\nProject table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Employee table: +-------------+--------+------------------+ | employee_id | name | experience_years | +-------------+--------+------------------+ | 1 | Khaled | 3 | | 2 | Ali | 2 | | 3 | John | 1 | | 4 | Doe | 2 | +-------------+--------+------------------+ Result table: +-------------+---------------+ | project_id | average_years | +-------------+---------------+ | 1 | 2.00 | | 2 | 2.50 | +-------------+---------------+   Solution 2020-10-04 Notes: SELECT project_id, ROUND(AVG(experience_years),2) AS average_years FROM project a JOIN employee b ON a.employee_id = b.employee_id GROUP BY 1 ORDER BY 1  ","id":115,"section":"posts","summary":"LC 1075 Project Employees I   Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.\nThe query result format is in the following example:\nProject table: +-------------+-------------+ | project_id | employee_id | +-------------+-------------+ | 1 | 1 | | 1 | 2 | | 1 | 3 | | 2 | 1 | | 2 | 4 | +-------------+-------------+ Employee table: +-------------+--------+------------------+ | employee_id | name | experience_years | +-------------+--------+------------------+ | 1 | Khaled | 3 | | 2 | Ali | 2 | | 3 | John | 1 | | 4 | Doe | 2 | +-------------+--------+------------------+ Result table: +-------------+---------------+ | project_id | average_years | +-------------+---------------+ | 1 | 2.","tags":["leetcode"],"title":"1075 Project Employees I","uri":"https://foxisawesome.github.io/posts/1075-project-employees-i/","year":"2020"},{"content":"LC 620 Not Boring Movies   X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not \u0026lsquo;boring\u0026rsquo;. Order the result by rating.\n Solution 2020-10-04 Notes: SELECT * FROM cinema WHERE id % 2 = 1 AND description != 'boring' ORDER BY rating DESC  ","id":116,"section":"posts","summary":"LC 620 Not Boring Movies   X city opened a new cinema, many people would like to go to this cinema. The cinema also gives out a poster indicating the movies’ ratings and descriptions.\nPlease write a SQL query to output movies with an odd numbered ID and a description that is not \u0026lsquo;boring\u0026rsquo;. Order the result by rating.\n Solution 2020-10-04 Notes: SELECT * FROM cinema WHERE id % 2 = 1 AND description !","tags":["leetcode"],"title":"620 Not Boring Movies","uri":"https://foxisawesome.github.io/posts/620-not-boring-movies/","year":"2020"},{"content":"LC 137 Single Number II   Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.\nNote:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\nInput: [2,2,3,2] Output: 3  Input: [0,1,0,1,0,1,99] Output: 99   Solution 2020-10-04 Notes:  因为确定那个特殊值只出现一次，sum_set - (sum_all - sum_set )/2 看其余两种解，无非就是算下freq 或者 bit manipulation。  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: return int(1.5*sum(set(nums)) - 0.5*sum(nums)) # Time O(N) # Space O(1)  ","id":117,"section":"posts","summary":"LC 137 Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Input: [2,2,3,2] Output: 3 Input: [0,1,0,1,0,1,99] Output: 99 Solution 2020-10-04 Notes: 因为确定那个特殊值只出现一次，","tags":["leetcode","math"],"title":"137 Single Number II","uri":"https://foxisawesome.github.io/posts/137-single-number-ii/","year":"2020"},{"content":"LC 130 Surrounded Regions   Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.\nA region is captured by flipping all 'O's into 'X's in that surrounded region.\nExample:\nX X X X X O O X X X O X X O X X  After running your function, the board should be:\nX X X X X X X X X X X X X O X X   Solution 2020-10-04 Notes:  非高频题，感觉是围棋的意思。只要中间的所有的’O’只要不连接边界都能被翻成’X’。 写的算法效率有点低，28%，也没找到特别高效的algo。思想就是，遇到’O’想走一遍BFS，这一次只找neighbor不改状态，然后只要遇到一个连着边界，这一波都不变动。反之，再来一次while loop，改写状态成 ‘X’。  class Solution: def solve(self, board: List[List[str]]) -\u0026gt; None: if not board or len(board)==0 or len(board[0])==0: return [] directions = [[-1,0],[1,0],[0,1],[0,-1]] nr, nc = len(board), len(board[0]) queue = [] visited = set() for i in range(1,nr-1): for j in range(1,nc-1): connected = False temp = [] if board[i][j] == 'O' and (i,j) not in visited: queue.append((i,j)) temp.append((i,j)) visited.add((i,j)) while queue: (x,y) = queue.pop(0) for d in directions: r, c = x+d[0], y+d[1] if 0\u0026lt;=r\u0026lt;nr and 0\u0026lt;=c\u0026lt;nc and board[r][c] == 'O' and (r,c) not in visited: queue.append((r,c)) temp.append((r,c)) visited.add((r,c)) if r in (0,nr-1) or c in (0,nc-1): connected = True while not connected and temp: u, v = temp.pop() board[u][v] = 'X' # Time O() # Space O()  ","id":118,"section":"posts","summary":"LC 130 Surrounded Regions Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'. A region is captured by flipping all 'O's into 'X's in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X","tags":["leetcode","BFS"],"title":"130 Surrounded Regions","uri":"https://foxisawesome.github.io/posts/130-surrounded-regions/","year":"2020"},{"content":"LC 108 Convert Sorted Array to Binary Search Tree   Given an array where elements are sorted in ascending order, convert it to a height balanced BST.\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\nGiven the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \\ -3 9 / / -10 5   Solution 2020-10-04 Notes:  看着复杂，pre-order 走一下就A了！  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sortedArrayToBST(self, nums: List[int]) -\u0026gt; TreeNode: if not nums: return None n = len(nums) mid = n //2 root = TreeNode(nums[mid]) root.left = self.sortedArrayToBST(nums[:mid]) root.right = self.sortedArrayToBST(nums[mid+1:]) return root # Time O(N) # Space O(1)  ","id":119,"section":"posts","summary":"LC 108 Convert Sorted Array to Binary Search Tree Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following","tags":["leetcode","tree","dia"],"title":"108 Convert Sorted Array to Binary Search Tree","uri":"https://foxisawesome.github.io/posts/108-convert-sorted-array-to-binary-search-tree/","year":"2020"},{"content":"LC 120 Triangle   Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.\nFor example, given the following triangle\n[ [2], [3,4], [6,5,7], [4,1,8,3] ]  The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).\nNote:\nBonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.\n Solution 2020-10-04 Notes:  简单题。 不过看到更高效的 dp 解。 保留一个ans 和一个deep copy。每行更新每个ans[j] = min(t[j-1],t[j]) + triangle[i][j]   class Solution: def minimumTotal(self, triangle: List[List[int]]) -\u0026gt; int: n = len(triangle) ans = [0] * n ans[0] = triangle[0][0] t = ans[:] for i in range(1,n): for j in range(len(triangle[i])): if j == 0: ans[j] = t[j] + triangle[i][j] elif 0\u0026lt;j\u0026lt;len(triangle[i])-1: ans[j] = min(t[j-1],t[j]) + triangle[i][j] else: ans[j] = t[j-1] + triangle[i][j] t = ans[:] return min(ans) # Time O(N^2) # Space O(N)  ","id":120,"section":"posts","summary":"LC 120 Triangle Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below. For example, given the following triangle [ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11). Note: Bonus point if you are able to do this using","tags":["leetcode","matrix"],"title":"120 Triangle","uri":"https://foxisawesome.github.io/posts/120-triangle/","year":"2020"},{"content":"LC 113 Path Sum II   Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum.\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1  Return:\n[ [5,4,11,2], [5,8,4,5] ]   Solution 2020-10-04 Notes:  很明显的dfs题。但是有个细节我一开始做错了。就是不能在leaf的下一层 结束搜索，因为这样会返回duplicate的path。只能在最后一层的leaf 那判断返回。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def pathSum(self, root: TreeNode, sum: int) -\u0026gt; List[List[int]]: self.ans = [] self.dfs(root, sum, []) return self.ans def dfs(self, root, sum_, path): if not root: return None if not root.left and not root.right: if sum_ == root.val: self.ans.append(path+[root.val]) return else: return self.dfs(root.left, sum_-root.val, path+[root.val]) self.dfs(root.right,sum_-root.val, path+[root.val]) # Time O(N) # Space O(1)  ","id":121,"section":"posts","summary":"LC 113 Path Sum II Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum. Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution 2020-10-04 Notes: 很明显的dfs题。但","tags":["leetcode","tree","dia"],"title":"113 Path Sum II","uri":"https://foxisawesome.github.io/posts/113-path-sum-ii/","year":"2020"},{"content":"LC 114 Flatten Binary Tree to Linked List   Given a binary tree, flatten it to a linked list in-place.\nFor example, given the following tree:\n 1 / \\ 2 5 / \\ \\ 3 4 6  The flattened tree should look like:\n1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6   Solution 2020-10-04 Notes:  感觉这题是 tree 真正体会recursion 算法的题，有点难。之前做的都是 xx-order traverse，算不上真正意义的recursion。 pre-order solution: 比较好理解，先pre-order traverse一遍，然后把形成的array重新定向一下。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flatten(self, root: TreeNode) -\u0026gt; None: if not root: return ans = [] self.preOrder(root,ans) for i in range(len(ans)-1): ans[i].left = None ans[i].right = ans[i+1] def preOrder(self, root, ans): if not root: return None ans.append(root) self.preOrder(root.left,ans) self.preOrder(root.right,ans) return # Time O(N) # Space O(N)   真正recursion的做法：  这是官方解答：1. 新建的function returns the tail node not the root. 2. 先遍历左孩子然后把其 tail 指向右孩子的头。\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def flatten(self, root): self.nodeFlat(root) def nodeFlat(self, node): if not node: return None if not node.left and not node.right: return node leftTail = self.nodeFlat(node.left) righTail = self.nodeFlat(node.right) if leftTail: leftTail.right = node.right node.right = node.left node.left = None return rightTail if rightTail else leftTail # Time O(N) # Space O(1)  ","id":122,"section":"posts","summary":"LC 114 Flatten Binary Tree to Linked List Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Solution 2020-10-04 Notes: 感觉这题是 tree 真正体会recu","tags":["leetcode","tree","dia"],"title":"114 Flatten Binary Tree to Linked List","uri":"https://foxisawesome.github.io/posts/114-flatten-binary-tree-to-linked-list/","year":"2020"},{"content":"LC 1596 the Most Frequently Ordered Products for Each Customer   Write an SQL query to find the most frequently ordered product(s) for each customer.\nThe result table should have the product_id and product_name for each customer_id who ordered at least one order. Return the result table in any order.\nThe query result format is in the following example:\nOrders +----------+------------+-------------+------------+ | order_id | order_date | customer_id | product_id | +----------+------------+-------------+------------+ | 1 | 2020-07-31 | 1 | 1 | | 2 | 2020-07-30 | 2 | 2 | | 3 | 2020-08-29 | 3 | 3 | | 4 | 2020-07-29 | 4 | 1 | | 5 | 2020-06-10 | 1 | 2 | | 6 | 2020-08-01 | 2 | 1 | | 7 | 2020-08-01 | 3 | 3 | | 8 | 2020-08-03 | 1 | 2 | | 9 | 2020-08-07 | 2 | 3 | | 10 | 2020-07-15 | 1 | 2 | +----------+------------+-------------+------------+ Result table: +-------------+------------+--------------+ | customer_id | product_id | product_name | +-------------+------------+--------------+ | 1 | 2 | mouse | | 2 | 1 | keyboard | | 2 | 2 | mouse | | 2 | 3 | screen | | 3 | 3 | screen | | 4 | 1 | keyboard | +-------------+------------+--------------+   Solution 2020-10-03 Notes:  DENSE_RANK() 内嵌 COUNT() 的题  SELECT customer_id, a.product_id, product_name FROM ( SELECT customer_id, product_id, DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY COUNT(product_id) DESC) as rk FROM orders GROUP BY customer_id, product_id ) a JOIN products b ON a.product_id = b.product_id and a.rk = 1  ","id":123,"section":"posts","summary":"LC 1596 the Most Frequently Ordered Products for Each Customer Write an SQL query to find the most frequently ordered product(s) for each customer. The result table should have the product_id and product_name for each customer_id who ordered at least one order. Return the result table in any order. The query result format is in the following example: Orders +----------+------------+-------------+------------+ | order_id | order_date | customer_id | product_id | +----------+------------+-------------+------------+","tags":["leetcode"],"title":"1596 the Most Frequently Ordered Products for Each Customer","uri":"https://foxisawesome.github.io/posts/1596-the-most-frequently-ordered-products-for-each-customer/","year":"2020"},{"content":"LC 1571 Warehouse Manager   Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.\n warehouse_name volume  Return the result table in any order.\nWarehouse table: +------------+--------------+-------------+ | name | product_id | units | +------------+--------------+-------------+ | LCHouse1 | 1 | 1 | | LCHouse1 | 2 | 10 | | LCHouse1 | 3 | 5 | | LCHouse2 | 1 | 2 | | LCHouse2 | 2 | 2 | | LCHouse3 | 4 | 1 | +------------+--------------+-------------+ Products table: +------------+--------------+------------+----------+-----------+ | product_id | product_name | Width | Length | Height | +------------+--------------+------------+----------+-----------+ | 1 | LC-TV | 5 | 50 | 40 | | 2 | LC-KeyChain | 5 | 5 | 5 | | 3 | LC-Phone | 2 | 10 | 10 | | 4 | LC-T-Shirt | 4 | 10 | 20 | +------------+--------------+------------+----------+-----------+ Result table: +----------------+------------+ | warehouse_name | volume | +----------------+------------+ | LCHouse1 | 12250 | | LCHouse2 | 20250 | | LCHouse3 | 800 | +----------------+------------+ Volume of product_id = 1 (LC-TV), 5x50x40 = 10000 Volume of product_id = 2 (LC-KeyChain), 5x5x5 = 125 Volume of product_id = 3 (LC-Phone), 2x10x10 = 200 Volume of product_id = 4 (LC-T-Shirt), 4x10x20 = 800 LCHouse1: 1 unit of LC-TV + 10 units of LC-KeyChain + 5 units of LC-Phone. Total volume: 1*10000 + 10*125 + 5*200 = 12250 cubic feet LCHouse2: 2 units of LC-TV + 2 units of LC-KeyChain. Total volume: 2*10000 + 2*125 = 20250 cubic feet LCHouse3: 1 unit of LC-T-Shirt. Total volume: 1*800 = 800 cubic feet.   Solution 2020-10-03 Notes: SELECT name AS warehouse_name, SUM(units * vol) AS volume FROM warehouse a JOIN ( SELECT product_id, (width*Length*Height) AS vol FROM products GROUP BY 1 ) b ON a.product_id = b.product_id GROUP BY 1  ","id":124,"section":"posts","summary":"LC 1571 Warehouse Manager   Write an SQL query to report, How much cubic feet of volume does the inventory occupy in each warehouse.\n warehouse_name volume  Return the result table in any order.\nWarehouse table: +------------+--------------+-------------+ | name | product_id | units | +------------+--------------+-------------+ | LCHouse1 | 1 | 1 | | LCHouse1 | 2 | 10 | | LCHouse1 | 3 | 5 | | LCHouse2 | 1 | 2 | | LCHouse2 | 2 | 2 | | LCHouse3 | 4 | 1 | +------------+--------------+-------------+ Products table: +------------+--------------+------------+----------+-----------+ | product_id | product_name | Width | Length | Height | +------------+--------------+------------+----------+-----------+ | 1 | LC-TV | 5 | 50 | 40 | | 2 | LC-KeyChain | 5 | 5 | 5 | | 3 | LC-Phone | 2 | 10 | 10 | | 4 | LC-T-Shirt | 4 | 10 | 20 | +------------+--------------+------------+----------+-----------+ Result table: +----------------+------------+ | warehouse_name | volume | +----------------+------------+ | LCHouse1 | 12250 | | LCHouse2 | 20250 | | LCHouse3 | 800 | +----------------+------------+ Volume of product_id = 1 (LC-TV), 5x50x40 = 10000 Volume of product_id = 2 (LC-KeyChain), 5x5x5 = 125 Volume of product_id = 3 (LC-Phone), 2x10x10 = 200 Volume of product_id = 4 (LC-T-Shirt), 4x10x20 = 800 LCHouse1: 1 unit of LC-TV + 10 units of LC-KeyChain + 5 units of LC-Phone.","tags":["leetcode"],"title":"1571 Warehouse Manager","uri":"https://foxisawesome.github.io/posts/1571-warehouse-manager/","year":"2020"},{"content":"LC 1241 Number of Comments per Post   Write an SQL query to find number of comments per each post.\nResult table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order.\nSubmissions may contain duplicate comments. You should count the number of unique comments per post.\nSubmissions may contain duplicate posts. You should treat them as one post.\nThe query result format is in the following example:\nSubmissions table: +---------+------------+ | sub_id | parent_id | +---------+------------+ | 1 | Null | | 2 | Null | | 1 | Null | | 12 | Null | | 3 | 1 | | 5 | 2 | | 3 | 1 | | 4 | 1 | | 9 | 1 | | 10 | 2 | | 6 | 7 | +---------+------------+ Result table: +---------+--------------------+ | post_id | number_of_comments | +---------+--------------------+ | 1 | 3 | | 2 | 2 | | 12 | 0 | +---------+--------------------+ The post with id 1 has three comments in the table with id 3, 4 and 9. The comment with id 3 is repeated in the table, we counted it only once. The post with id 2 has two comments in the table with id 5 and 10. The post with id 12 has no comments in the table. The comment with id 6 is a comment on a deleted post with id 7 so we ignored it.   Solution 2020-10-03 Notes:  一道最优解比较复杂的简单题。self-join  SELECT a.sub_id AS post_id, COUNT(DISTINCT b.sub_id) AS number_of_comments FROM submissions a LEFT JOIN submissions b ON a.sub_id = b.parent_id WHERE a.parent_id IS NULL GROUP BY 1 ORDER BY 1  ","id":125,"section":"posts","summary":"LC 1241 Number of Comments per Post Write an SQL query to find number of comments per each post. Result table should contain post_id and its corresponding number_of_comments, and must be sorted by post_id in ascending order. Submissions may contain duplicate comments. You should count the number of unique comments per post. Submissions may contain duplicate posts. You should treat them as one post. The query result format is in","tags":["leetcode","dia"],"title":"1241 Number of Comments per Post","uri":"https://foxisawesome.github.io/posts/1241-number-of-comments-per-post/","year":"2020"},{"content":"LC 1084 Sales Analysis III   Write an SQL query that reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\nThe query result format is in the following example:\nProduct table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone | 1400 | +------------+--------------+------------+ Sales table: +-----------+------------+----------+------------+----------+-------+ | seller_id | product_id | buyer_id | sale_date | quantity | price | +-----------+------------+----------+------------+----------+-------+ | 1 | 1 | 1 | 2019-01-21 | 2 | 2000 | | 1 | 2 | 2 | 2019-02-17 | 1 | 800 | | 2 | 2 | 3 | 2019-06-02 | 1 | 800 | | 3 | 3 | 4 | 2019-05-13 | 2 | 2800 | +-----------+------------+----------+------------+----------+-------+ Result table: +-------------+--------------+ | product_id | product_name | +-------------+--------------+ | 1 | S8 | +-------------+--------------+ The product with id 1 was only sold in spring 2019 while the other two were sold after.   Solution 2020-10-03 Notes:  本想用row_number()去做，想复杂了。  SELECT product_id, product_name FROM product WHERE product_id NOT IN (SELECT product_id FROM sales WHERE sale_date \u0026gt; \u0026quot;2019-03-31\u0026quot; OR sale_date \u0026lt; \u0026quot;2019-01-01\u0026quot;)  ","id":126,"section":"posts","summary":"LC 1084 Sales Analysis III Write an SQL query that reports the products that were only sold in spring 2019. That is, between 2019-01-01 and 2019-03-31 inclusive. The query result format is in the following example: Product table: +------------+--------------+------------+ | product_id | product_name | unit_price | +------------+--------------+------------+ | 1 | S8 | 1000 | | 2 | G4 | 800 | | 3 | iPhone | 1400 | +------------+--------------+------------+ Sales","tags":["leetcode","dia"],"title":"1084 Sales Analysis III","uri":"https://foxisawesome.github.io/posts/1084-sales-analysis-iii/","year":"2020"},{"content":"LC 1142 User Activity for the Past 30 Days II   Write an SQL query to find the average number of sessions per user for a period of 30 days ending 2019-07-27 inclusively, rounded to 2 decimal places. The sessions we want to count for a user are those with at least one activity in that time period.\nThe query result format is in the following example:\nActivity table: +---------+------------+---------------+---------------+ | user_id | session_id | activity_date | activity_type | +---------+------------+---------------+---------------+ | 1 | 1 | 2019-07-20 | open_session | | 1 | 1 | 2019-07-20 | scroll_down | | 1 | 1 | 2019-07-20 | end_session | | 2 | 4 | 2019-07-20 | open_session | | 2 | 4 | 2019-07-21 | send_message | | 2 | 4 | 2019-07-21 | end_session | | 3 | 2 | 2019-07-21 | open_session | | 3 | 2 | 2019-07-21 | send_message | | 3 | 2 | 2019-07-21 | end_session | | 3 | 5 | 2019-07-21 | open_session | | 3 | 5 | 2019-07-21 | scroll_down | | 3 | 5 | 2019-07-21 | end_session | | 4 | 3 | 2019-06-25 | open_session | | 4 | 3 | 2019-06-25 | end_session | +---------+------------+---------------+---------------+ Result table: +---------------------------+ | average_sessions_per_user | +---------------------------+ | 1.33 | +---------------------------+ User 1 and 2 each had 1 session in the past 30 days while user 3 had 2 sessions so the average is (1 + 1 + 2) / 3 = 1.33.   Solution 2020-10-02 Notes:  DATEDIFF(\u0026lsquo;2019-07-27\u0026rsquo;, activity_date) \u0026lt; 30 没有等于。 其次 COUNT distinct 的session_id 作为 numerator。  SELECT ROUND( IFNULL(nu/tot,0) ,2) AS average_sessions_per_user FROM( SELECT COUNT(DISTINCT user_id) as tot, COUNT(DISTINCT session_id) as nu FROM activity WHERE DATEDIFF('2019-07-27', activity_date) \u0026lt; 30 ) a  ","id":127,"section":"posts","summary":"LC 1142 User Activity for the Past 30 Days II Write an SQL query to find the average number of sessions per user for a period of 30 days ending 2019-07-27 inclusively, rounded to 2 decimal places. The sessions we want to count for a user are those with at least one activity in that time period. The query result format is in the following example: Activity table: +---------+------------+---------------+---------------+ |","tags":["leetcode"],"title":"1142 User Activity for the Past 30 Days II","uri":"https://foxisawesome.github.io/posts/1142-user-activity-for-the-past-30-days-ii/","year":"2020"},{"content":"LC 1204 Last Person to Fit in the Elevator   The maximum weight the elevator can hold is 1000.\nWrite an SQL query to find the person_name of the last person who will fit in the elevator without exceeding the weight limit. It is guaranteed that the person who is first in the queue can fit in the elevator.\nThe query result format is in the following example:\nQueue table +-----------+-------------------+--------+------+ | person_id | person_name | weight | turn | +-----------+-------------------+--------+------+ | 5 | George Washington | 250 | 1 | | 3 | John Adams | 350 | 2 | | 6 | Thomas Jefferson | 400 | 3 | | 2 | Will Johnliams | 200 | 4 | | 4 | Thomas Jefferson | 175 | 5 | | 1 | James Elephant | 500 | 6 | +-----------+-------------------+--------+------+ Result table +-------------------+ | person_name | +-------------------+ | Thomas Jefferson | +-------------------+   Solution 2020-10-02 Notes:  Window function: sum(), count() 之类的在有order by 时会给出cumulative的值。  SELECT person_name FROM ( SELECT person_name, SUM(weight) over(ORDER BY turn) AS tot_wt, turn FROM queue ) a WHERE tot_wt \u0026lt;= 1000 ORDER BY turn DESC LIMIT 1  ","id":128,"section":"posts","summary":"LC 1204 Last Person to Fit in the Elevator The maximum weight the elevator can hold is 1000. Write an SQL query to find the person_name of the last person who will fit in the elevator without exceeding the weight limit. It is guaranteed that the person who is first in the queue can fit in the elevator. The query result format is in the following example: Queue table +-----------+-------------------+--------+------+","tags":["leetcode"],"title":"1204 Last Person to Fit in the Elevator","uri":"https://foxisawesome.github.io/posts/1204-last-person-to-fit-in-the-elevator/","year":"2020"},{"content":"LC 1164 Product Price at a Given Date   Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.\nThe query result format is in the following example:\nProducts table: +------------+-----------+-------------+ | product_id | new_price | change_date | +------------+-----------+-------------+ | 1 | 20 | 2019-08-14 | | 2 | 50 | 2019-08-14 | | 1 | 30 | 2019-08-15 | | 1 | 35 | 2019-08-16 | | 2 | 65 | 2019-08-17 | | 3 | 20 | 2019-08-18 | +------------+-----------+-------------+ Result table: +------------+-------+ | product_id | price | +------------+-------+ | 2 | 50 | | 1 | 35 | | 3 | 10 | +------------+-------+   Solution 2020-10-02 Notes:  这道题用了 ROW_NUMBER() 做了retain 的功能。很妙啊！  WITH a AS (SELECT DISTINCT product_id FROM products), b AS ( SELECT *, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY change_date DESC) AS nr FROM products WHERE change_date \u0026lt;= '2019-08-16' ) Select a.product_id, IFNULL(new_price,10) AS price FROM a LEFT JOIN b ON a.product_id = b.product_id and b.nr = 1 ORDER BY 1  还有个思路就是用max(‘2019-08-16’, change_date)做。这么做太慢了。\n# Write your MySQL query statement below select a.product_id, ifnull(b.new_price,10) as price from ( select distinct product_id from products ) a left join ( select product_id, new_price from products c where change_date = (select max(change_date) as m_d from products where change_date \u0026lt;= '2019-08-16' and c.product_id = product_id ) ) b on a.product_id = b.product_id order by 2 desc  ","id":129,"section":"posts","summary":"LC 1164 Product Price at a Given Date Write an SQL query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10. The query result format is in the following example: Products table: +------------+-----------+-------------+ | product_id | new_price | change_date | +------------+-----------+-------------+ | 1 | 20 | 2019-08-14 | | 2 | 50 | 2019-08-14 | | 1 | 30","tags":["leetcode","dia_sql"],"title":"1164 Product Price at a Given Date","uri":"https://foxisawesome.github.io/posts/1164-product-price-at-a-given-date/","year":"2020"},{"content":"LC 161 One Edit Distance   Given two strings s and t, return true if they are both one edit distance apart, otherwise return false.\nA string s is said to be one distance apart from a string t if you can:\n Insert exactly one character into s to get t. Delete exactly one character from s to get t. Replace exactly one character of s with a different character to get t.  Input: s = \u0026quot;ab\u0026quot;, t = \u0026quot;acb\u0026quot; Output: true Explanation: We can insert 'c' into s to get t.   Solution 2020-10-02 Notes:  题目很简单，但要写的简洁有点难。  class Solution: def isOneEditDistance(self, s: str, t: str) -\u0026gt; bool: ns, nt = len(s), len(t) if ns \u0026gt; nt: return self.isOneEditDistance(t,s) if nt - ns \u0026gt; 1: return False for i in range(ns): if s[i] != t[i]: if ns == nt: return s[i+1:] == t[i+1:] else: return s[i:] == t[i+1:] return ns+1 == nt # Time O(N) # Space O(1)  ","id":130,"section":"posts","summary":"LC 161 One Edit Distance Given two strings s and t, return true if they are both one edit distance apart, otherwise return false. A string s is said to be one distance apart from a string t if you can: Insert exactly one character into s to get t. Delete exactly one character from s to get t. Replace exactly one character of s with a different character to","tags":["leetcode","two_pointers"],"title":"161 One Edit Distance","uri":"https://foxisawesome.github.io/posts/161-one-edit-distance/","year":"2020"},{"content":"LC 168 Excel Sheet Column Title   Given a positive integer, return its corresponding column title as appear in an Excel sheet.\nFor example:\n 1 -\u0026gt; A 2 -\u0026gt; B 3 -\u0026gt; C ... 26 -\u0026gt; Z 27 -\u0026gt; AA 28 -\u0026gt; AB ...  Input: 28 Output: \u0026quot;AB\u0026quot;   Solution 2020-10-02 Notes:  dict应该 0-indexed，然后divmod里 应该是n-1。  class Solution: def convertToTitle(self, n: int) -\u0026gt; str: d = {0:'A', 1:'B', 2:'C', 3:'D', 4:'E', 5:'F', 6:'G', 7:'H', 8:'I', 9:'J', 10:'K', 11:'L', 12:'M', 13:'N', 14:'O', 15:'P', 16:'Q', 17:'R', 18:'S', 19:'T', 20:'U', 21:'V', 22:'W', 23:'X', 24:'Y', 25:'Z'} ans = '' while n \u0026gt; 0: n, r = divmod((n-1),26) ans += d[r] return ans[::-1] # Time O(log_26 N) # Space O(1og_26 N)  ","id":131,"section":"posts","summary":"LC 168 Excel Sheet Column Title Given a positive integer, return its corresponding column title as appear in an Excel sheet. For example: 1 -\u0026gt; A 2 -\u0026gt; B 3 -\u0026gt; C ... 26 -\u0026gt; Z 27 -\u0026gt; AA 28 -\u0026gt; AB ... Input: 28 Output: \u0026quot;AB\u0026quot; Solution 2020-10-02 Notes: dict应该 0-indexed，然后di","tags":["leetcode","hashtable"],"title":"168 Excel Sheet Column Title","uri":"https://foxisawesome.github.io/posts/168-excel-sheet-column-title/","year":"2020"},{"content":"LC 724 Find Pivot Index   Given an array of integers nums, write a method that returns the \u0026ldquo;pivot\u0026rdquo; index of this array.\nWe define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\nInput: nums = [1,7,3,6,5,6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs.   Solution 2020-10-02 Notes:  题目很容易理解，但对速度要求很高。开始我想的是用pre_sum, 但依然还是太慢了。 用 online update left_sum, 然后 right_sum = total_sum-left_sum-num的方法可以one-pass。好巧的题  class Solution: def pivotIndex(self, nums: List[int]) -\u0026gt; int: if not nums: return -1 left_sum, tot_sum = 0, sum(nums) for i, val in enumerate(nums): if left_sum == tot_sum - left_sum-val: return i else: left_sum += val return -1 # Time O(N) # Space O(1)  ","id":132,"section":"posts","summary":"LC 724 Find Pivot Index Given an array of integers nums, write a method that returns the \u0026ldquo;pivot\u0026rdquo; index of this array. We define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If no such index exists, we should return -1. If there are","tags":["leetcode","dia"],"title":"724 Find Pivot Index","uri":"https://foxisawesome.github.io/posts/724-find-pivot-index/","year":"2020"},{"content":"LC 240 Search a 2d Matrix II   Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom.  Consider the following matrix:\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ]  Given target = 5, return true.\nGiven target = 20, return false.\n Solution 2020-10-02 Notes:  最重要的想法是从右上下左下走，小于目标 r++, 大于目标 c\u0026ndash;。 同方法能A掉 LC 74  class Solution: def searchMatrix(self, matrix, target): if not matrix: return False nr, nc = len(matrix), len(matrix[0]) if nr==0 or nc==0: return False # from topright towards bottom left r, c = 0, nc-1 while r \u0026lt; nr and c \u0026gt;=0: if matrix[r][c] == target: return True elif matrix[r][c] \u0026lt; target: r += 1 elif matrix[r][c] \u0026gt; target: c -= 1 return False # Time O(N) # Space O(1)  ","id":133,"section":"posts","summary":"LC 240 Search a 2d Matrix II Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9,","tags":["leetcode","two_pointers","dia"],"title":"240 Search a 2d Matrix II","uri":"https://foxisawesome.github.io/posts/240-search-a-2d-matrix-ii/","year":"2020"},{"content":"LC 905 Sort Array by Parity   Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.\nYou may return any answer array that satisfies this condition.\nInput: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.   Solution 2020-10-02 Notes:  这题和 remove duplicate from array 一回事。slow and fast two pointers就能搞定了。 return sorted() 虽然 one liner 但是 time complexity高。  class Solution: def sortArrayByParity(self, A: List[int]) -\u0026gt; List[int]: slow, fast = 0, 0 n = len(A) while fast \u0026lt; n: if A[fast]%2==0: A[slow], A[fast] = A[fast], A[slow] slow += 1 fast += 1 return A # Time O(N) # Space O(1)  ","id":134,"section":"posts","summary":"LC 905 Sort Array by Parity Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Solution 2020-10-02 Notes: 这题和 remove duplicate from array 一回事。","tags":["leetcode","two_pointers"],"title":"905 Sort Array by Parity","uri":"https://foxisawesome.github.io/posts/905-sort-array-by-parity/","year":"2020"},{"content":"LC 1213 Intersection of Three Sorted Arrays   Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays.\nInput: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8] Output: [1,5] Explanation: Only 1 and 5 appeared in the three arrays.   Solution 2020-10-02 Notes:  建一个 helper function 找两个arr的交集，然后再找和第三个arr的交集。  class Solution: def arraysIntersection(self, arr1: List[int], arr2: List[int], arr3: List[int]) -\u0026gt; List[int]: arr = self.sortTwo(arr1, arr2) return self.sortTwo(arr, arr3) def sortTwo(self, a, b): p1, p2 = 0, 0 n1, n2 = len(a), len(b) ans = [] while p1 \u0026lt; n1 and p2 \u0026lt; n2: if a[p1] == b[p2]: ans.append(a[p1]) p1 += 1 p2 += 1 elif a[p1] \u0026gt; b[p2]: p2 += 1 else: p1 += 1 return ans # Time O() # Space O()  ","id":135,"section":"posts","summary":"LC 1213 Intersection of Three Sorted Arrays Given three integer arrays arr1, arr2 and arr3 sorted in strictly increasing order, return a sorted array of only the integers that appeared in all three arrays. Input: arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8] Output: [1,5] Explanation: Only 1 and 5 appeared in the three arrays. Solution 2020-10-02 Notes: 建一个 helper function 找两个arr","tags":["leetcode","two_pointers"],"title":"1213 Intersection of Three Sorted Arrays","uri":"https://foxisawesome.github.io/posts/1213-intersection-of-three-sorted-arrays/","year":"2020"},{"content":"LC 118 Pascals Triangle   Given a non-negative integer numRows, generate the first numRows of Pascal\u0026rsquo;s triangle.\n Solution 2020-10-02 Notes:  没有特别的。  class Solution: def generate(self, numRows: int) -\u0026gt; List[List[int]]: ans = [[1]*i for i in range(1,numRows+1)] if numRows \u0026gt;= 3: for i in range(2,numRows): for j in range(1,i): ans[i][j] = sum(ans[i-1][j-1:j+1]) return ans # Time O(N) # Space O(N)  ","id":136,"section":"posts","summary":"LC 118 Pascals Triangle Given a non-negative integer numRows, generate the first numRows of Pascal\u0026rsquo;s triangle. Solution 2020-10-02 Notes: 没有特别的。 class Solution: def generate(self, numRows: int) -\u0026gt; List[List[int]]: ans = [[1]*i for i in range(1,numRows+1)] if numRows \u0026gt;= 3: for i in range(2,numRows): for j in range(1,i): ans[i][j] = sum(ans[i-1][j-1:j+1]) return ans # Time O(N) # Space O(N)","tags":["leetcode","matrix"],"title":"118 Pascals Triangle","uri":"https://foxisawesome.github.io/posts/118-pascals-triangle/","year":"2020"},{"content":"LC 8 String to Integer Atoi   Implement atoi which converts a string to an integer.\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\n‘’+1’’: 1\n“-0.314”: 0\n Solution 2020-10-02 Notes:  题目很简单就是又很多corner cases在题目里没讲清楚，得test了才知道 note: 上界是: 2**31-1  class Solution: def myAtoi(self, str: str) -\u0026gt; int: str = str.split() if not str: return 0 s = str[0] if not (s[0].isdigit() or s[0] in ('-','+')): return 0 sign = 1 if s[0] in ('-','+'): sign = -1 if s[0]=='-' else 1 s = s[1:] digit = 0 for i in s: if i.isdigit(): digit = digit*10 + ord(i) - ord('0') else: break return max(-2**31, min(digit*sign, 2**31-1)) # Time O(N) # Space O(N)  ","id":137,"section":"posts","summary":"LC 8 String to Integer Atoi Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form","tags":["leetcode","string"],"title":"8 String to Integer Atoi","uri":"https://foxisawesome.github.io/posts/8-string-to-integer-atoi/","year":"2020"},{"content":"LC 67 Add Binary   Given two binary strings, return their sum (also a binary string).\nThe input strings are both non-empty and contains only characters 1 or 0.\nInput: a = \u0026quot;11\u0026quot;, b = \u0026quot;1\u0026quot; Output: \u0026quot;100\u0026quot;   Solution 2020-10-01 Notes:   这题不像linked list的加法，得分两个loop，一个loop完成所有加法，再加一个carry处理。\n  看了下其他更efficient的解，发现speed up的方法是把sum的情况列出来 instead of using divmod()。\n if sum == 3: output += \u0026quot;1\u0026quot; carry = 1 elif sum == 2: output += \u0026quot;0\u0026quot; carry = 1 elif sum == 1: output += \u0026quot;1\u0026quot; carry = 0 elif sum == 0: output += \u0026quot;0\u0026quot; carry = 0    class Solution: def addBinary(self, a: str, b: str) -\u0026gt; str: na, nb = len(a), len(b) pa, pb = na-1, nb-1 ans, carry = '', 0 while pa \u0026gt;= 0 or pb \u0026gt;= 0: val = carry if pa \u0026gt;= 0: val += int(a[pa]) if pb \u0026gt;= 0: val += int(b[pb]) carry, r = divmod(val, 2) ans += str(r) pa -= 1 pb -= 1 if carry: ans += str(carry) return ans[::-1] # Time O(N) # Space O(N)  ","id":138,"section":"posts","summary":"LC 67 Add Binary Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Input: a = \u0026quot;11\u0026quot;, b = \u0026quot;1\u0026quot; Output: \u0026quot;100\u0026quot; Solution 2020-10-01 Notes: 这题不像linked list的加法，得分两个loop，一个l","tags":["leetcode"],"title":"67 Add Binary","uri":"https://foxisawesome.github.io/posts/67-add-binary/","year":"2020"},{"content":"LC 66 Plus One   Given a non-empty array of digits representing a non-negative integer, increment one to the integer.\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit.\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\n Solution 2020-10-01 Notes:  简单题，走一遍就好了。  class Solution: def plusOne(self, digits: List[int]) -\u0026gt; List[int]: d, carry = digits.pop()+1, 0 ans = [] while digits: carry, r = divmod(d+carry, 10) ans.append(r) d = digits.pop() while carry or d: carry, r = divmod(d+carry, 10) ans.append(r) d = 0 return ans[::-1] # Time O(N) # Space O(N)  ","id":139,"section":"posts","summary":"LC 66 Plus One Given a non-empty array of digits representing a non-negative integer, increment one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contains a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Solution 2020-10-01 Notes: 简单题，走","tags":["leetcode",""],"title":"66 Plus One","uri":"https://foxisawesome.github.io/posts/66-plus-one/","year":"2020"},{"content":"LC 463 Island Perimeter   You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.\nGrid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\nThe island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don\u0026rsquo;t exceed 100. Determine the perimeter of the island.\n Solution 2020-10-01 Notes:  走一遍matrix，再记录下有几个connections。  class Solution: def islandPerimeter(self, grid: List[List[int]]) -\u0026gt; int: nr, nc = len(grid), len(grid[0]) directions = [[1,0],[-1,0],[0,1],[0,-1]] islands, share = 0, 0 for i in range(nr): for j in range(nc): if grid[i][j]==1: islands += 1 for d in directions: x, y = i+d[0], j+d[1] if 0\u0026lt;=x\u0026lt;nr and 0\u0026lt;=y\u0026lt;nc and grid[x][y]==1: share += 1 return islands*4 - share # Time O(MN) # Space O(1)   一个稍微efficient点的算法：  class Solution: def islandPerimeter(self, grid: List[List[int]]) -\u0026gt; int: if len(grid) == 0 or len(grid[0]) ==0: return 0 island = 0 double_ct = 0 nrow = len(grid) ncol = len(grid[0]) for i in range(nrow): for j in range(ncol): if grid[i][j] == 1: island += 1 if i+1 \u0026lt; nrow and grid[i][j] == grid[i+1][j]: double_ct += 1 if j+1 \u0026lt; ncol and grid[i][j] == grid[i][j+1]: double_ct += 1 return island*4 - double_ct*2  ","id":140,"section":"posts","summary":"LC 463 Island Perimeter You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn\u0026rsquo;t have \u0026ldquo;lakes\u0026rdquo;, meaning the water inside isn\u0026rsquo;t connected to the water around the island.","tags":["leetcode","matrix"],"title":"463 Island Perimeter","uri":"https://foxisawesome.github.io/posts/463-island-perimeter/","year":"2020"},{"content":"LC 339 Nested List Weight Sum   Given a nested list of integers, return the sum of all integers in the list weighted by their depth.\nEach element is either an integer, or a list \u0026ndash; whose elements may also be integers or other lists.\nExample 1:\nInput: [[1,1],2,[1,1]] Output: 10 Explanation: Four 1's at depth 2, one 2 at depth 1.  Example 2:\nInput: [1,[4,[6]]] Output: 27 Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4*2 + 6*3 = 27.   Solution 2020-10-01 Notes:  很简单的题，只是这道题要求调用特定的API  # \u0026quot;\u0026quot;\u0026quot; # This is the interface that allows for creating nested lists. # You should not implement it, or speculate about its implementation # \u0026quot;\u0026quot;\u0026quot; #class NestedInteger: # def __init__(self, value=None): # \u0026quot;\u0026quot;\u0026quot; # If value is not specified, initializes an empty list. # Otherwise initializes a single integer equal to value. # \u0026quot;\u0026quot;\u0026quot; # # def isInteger(self): # \u0026quot;\u0026quot;\u0026quot; # @return True if this NestedInteger holds a single integer, rather than a nested list. # :rtype bool # \u0026quot;\u0026quot;\u0026quot; # # def add(self, elem): # \u0026quot;\u0026quot;\u0026quot; # Set this NestedInteger to hold a nested list and adds a nested integer elem to it. # :rtype void # \u0026quot;\u0026quot;\u0026quot; # # def setInteger(self, value): # \u0026quot;\u0026quot;\u0026quot; # Set this NestedInteger to hold a single integer equal to value. # :rtype void # \u0026quot;\u0026quot;\u0026quot; # # def getInteger(self): # \u0026quot;\u0026quot;\u0026quot; # @return the single integer that this NestedInteger holds, if it holds a single integer # Return None if this NestedInteger holds a nested list # :rtype int # \u0026quot;\u0026quot;\u0026quot; # # def getList(self): # \u0026quot;\u0026quot;\u0026quot; # @return the nested list that this NestedInteger holds, if it holds a nested list # Return None if this NestedInteger holds a single integer # :rtype List[NestedInteger] # \u0026quot;\u0026quot;\u0026quot; class Solution: def depthSum(self, nestedList: List[NestedInteger]) -\u0026gt; int: if not nestedList: return 0 return self.helper(1,nestedList) def helper(self,d,l): ans = 0 for i in l: if i.isInteger(): ans += i.getInteger()*d else: ans += self.helper(d+1,i.getList()) return ans # Time O() # Space O()  ","id":141,"section":"posts","summary":"LC 339 Nested List Weight Sum Given a nested list of integers, return the sum of all integers in the list weighted by their depth. Each element is either an integer, or a list \u0026ndash; whose elements may also be integers or other lists. Example 1: Input: [[1,1],2,[1,1]] Output: 10 Explanation: Four 1's at depth 2, one 2 at depth 1. Example 2: Input: [1,[4,[6]]] Output: 27 Explanation: One 1","tags":["leetcode","recursion","dfs"],"title":"339 Nested List Weight Sum","uri":"https://foxisawesome.github.io/posts/339-nested-list-weight-sum/","year":"2020"},{"content":"LC 224 Basic Calculator   mplement a basic calculator to evaluate a simple expression string.\nThe expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces ``.\nInput: \u0026quot;(1+(4+5+2)-3)+(6+8)\u0026quot; Output: 23   Solution 2020-10-01 Notes:  Calculator 3 题：LC 224, LC 227, LC 772 都好难。三题的解法大同小异，但是很多细节很容易出错。 这题就是典型的把recursion写成 stack来解。  class Solution: def calculate(self, s: str) -\u0026gt; int: n = len(s) stack, digit, prev_op, ans = [], 0, '+', 0 for i, val in enumerate(s): if val.isdigit(): digit = digit*10 + int(val) if val == '(': stack.append(ans) stack.append(prev_op) ans, prev_op = 0, '+' if i==n-1 or val in ('+','-',')'): if prev_op == '+': ans += digit elif prev_op == '-': ans -= digit prev_op, digit = val, 0 if val == ')': prev_op = stack.pop() ans = ans + stack.pop() if prev_op == '+' else stack.pop() - ans digit, prev_op = 0, '+' return ans # Time O(N) # Space O(1)  ","id":142,"section":"posts","summary":"LC 224 Basic Calculator mplement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces ``. Input: \u0026quot;(1+(4+5+2)-3)+(6+8)\u0026quot; Output: 23 Solution 2020-10-01 Notes: Calculator 3 题：LC 224, LC 227, LC 772 都好难。三题的解法大同小异，","tags":["leetcode","stack","dia"],"title":"224 Basic Calculator","uri":"https://foxisawesome.github.io/posts/224-basic-calculator/","year":"2020"},{"content":"LC 356 Line Reflection   Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points symmetrically, in other words, answer whether or not if there exists a line that after reflecting all points over the given line the set of the original points is the same that the reflected ones.\nNote that there can be repeated points.\n Solution 2020-10-01 Notes:  很简单的数学题。 一开始有个问题是虽然 time是$\\mathcal{O}(N)$，但是提交的结果看慢的离谱(5%)。不知道哪里有问题。后来看了论坛才发现，一定要把points先转成hash set，然后再处理才会快。  class Solution: class Solution: def isReflected(self, points: List[List[int]]) -\u0026gt; bool: max_, min_ = -float('inf'), float('inf') points = set([ tuple(p) for p in points]) for p in points: max_ = max(max_, p[0]) min_ = min(min_, p[0]) line = (max_ + min_) / 2 for p in points: if (2*line - p[0], p[1]) not in points: return False return True # Time O(N) # Space O(1)  ","id":143,"section":"posts","summary":"LC 356 Line Reflection Given n points on a 2D plane, find if there is such a line parallel to y-axis that reflect the given points symmetrically, in other words, answer whether or not if there exists a line that after reflecting all points over the given line the set of the original points is the same that the reflected ones. Note that there can be repeated points. Solution 2020-10-01","tags":["leetcode","math"],"title":"356 Line Reflection","uri":"https://foxisawesome.github.io/posts/356-line-reflection/","year":"2020"},{"content":"LC 772 Basic Calculator III   Implement a basic calculator to evaluate a simple expression string.\nThe expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces ``. The integer division should truncate toward zero.\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647].\nFollow up: Could you solve the problem without using built-in library functions.\n Solution 2020-10-01 Notes:  Calculator 3 题：LC 224, LC 227, LC 772 都好难。三题的解法大同小异，但是很多细节很容易出错。 括号的处理就是扔进recursion里再计算一遍。  class Solution: def calculate(self, s: str) -\u0026gt; int: s = list(s) return self.helper(s) def helper(self, s): prev_op, digit = '+', 0 stack = [] while s: val = s.pop(0) if val.isnumeric(): digit = digit*10 + int(val) if val == '(': digit = self.helper(s) if not s or val in ('+','-','*','/',')'): if prev_op == '+': stack.append(digit) if prev_op == '-': stack.append(-digit) if prev_op == '*': temp = stack.pop() stack.append(temp * digit) if prev_op == '/': temp = stack.pop() stack.append(int(temp/digit)) prev_op, digit = val, 0 if val == ')': break return sum(stack) # Time O(N) # Space O(N)  ","id":144,"section":"posts","summary":"LC 772 Basic Calculator III Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators , open ( and closing parentheses ) and empty spaces ``. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2147483648, 2147483647]. Follow up: Could you","tags":["leetcode","stack","recursion","dia"],"title":"772 Basic Calculator III","uri":"https://foxisawesome.github.io/posts/772-basic-calculator-iii/","year":"2020"},{"content":"LC 1369 Get the Second Most Recent Activity   Write an SQL query to show the second most recent activity of each user.\nIf the user only has one activity, return that one.\nA user can\u0026rsquo;t perform more than one activity at the same time. Return the result table in any order.\n Solution 2020-09-30 Notes:  straightforward by problem description.  SELECT username, activity, startDate, endDate FROM ( SELECT username, activity, startDate, endDate, ROW_NUMBER() OVER(PARTITION BY username ORDER BY startdate DESC) AS nr, COUNT(*) OVER(PARTITION BY username) AS ct FROM userActivity ) a WHERE nr=2 OR ct=1  ","id":145,"section":"posts","summary":"LC 1369 Get the Second Most Recent Activity   Write an SQL query to show the second most recent activity of each user.\nIf the user only has one activity, return that one.\nA user can\u0026rsquo;t perform more than one activity at the same time. Return the result table in any order.\n Solution 2020-09-30 Notes:  straightforward by problem description.  SELECT username, activity, startDate, endDate FROM ( SELECT username, activity, startDate, endDate, ROW_NUMBER() OVER(PARTITION BY username ORDER BY startdate DESC) AS nr, COUNT(*) OVER(PARTITION BY username) AS ct FROM userActivity ) a WHERE nr=2 OR ct=1  ","tags":["leetcode","dia_sql"],"title":"1369 Get the Second Most Recent Activity","uri":"https://foxisawesome.github.io/posts/1369-get-the-second-most-recent-activity/","year":"2020"},{"content":"LC 585 Investments in 2016   Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria:\n  Have the same TIV_2015 value as one or more other policyholders.\n  Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).\nSample Input\n| PID | TIV_2015 | TIV_2016 | LAT | LON | |-----|----------|----------|-----|-----| | 1 | 10 | 5 | 10 | 10 | | 2 | 20 | 20 | 20 | 20 | | 3 | 10 | 30 | 20 | 20 | | 4 | 10 | 40 | 40 | 40 |  Sample Output\n| TIV_2016 | |----------| | 45.00 |     Solution 2020-09-30 Notes:  设计的很好的一题。 COUNT() OVER(PARTITION BY) CONCAT(x, y)  SELECT ROUND( SUM(TIV_2016), 2) AS TIV_2016 FROM ( SELECT pid, tiv_2016, COUNT(PID) OVER(PARTITION BY TIV_2015) AS ct_15, COUNT(PID) OVER(PARTITION BY CONCAT(lat,lon)) AS ct_loc FROM insurance ) a WHERE ct_15 != 1 and ct_loc = 1  2020-06-23 Notes: 第一刷的两个解。self-join 这个解还可以，下面一个就幼稚了。\nselect sum(TIV_2016) as TIV_2016 from ( select a.pid, a.TIV_2016, a.TIV from insurance a inner join insurance b on a.pid \u0026gt; b.pid and a.TIV_2015 = b.TIV_2015 and a.lat || a.lon != b.lat || b.lon ) c  select sum(a.TIV_2016) as TIV_2016 from insurance a where a.TIV_2015 in (select TIV_2015 from insurance group by TIV_2015 having sum(1) \u0026gt;1 ) and pid in (select pid from insurance group by CONCAT(lat, lon) having sum(1) \u0026lt; 2)  ","id":146,"section":"posts","summary":"LC 585 Investments in 2016 Write a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria: Have the same TIV_2015 value as one or more other policyholders. Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique). Sample Input |","tags":["leetcode","dia_sql"],"title":"585 Investments in 2016","uri":"https://foxisawesome.github.io/posts/585-investments-in-2016/","year":"2020"},{"content":"LC 1355 Activity Participants   Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants.\nReturn the result table in any order. Each activity in table Activities is performed by any person in the table Friends.\nThe query result format is in the following example:\nFriends table: +------+--------------+---------------+ | id | name | activity | +------+--------------+---------------+ | 1 | Jonathan D. | Eating | | 2 | Jade W. | Singing | | 3 | Victor J. | Singing | | 4 | Elvis Q. | Eating | | 5 | Daniel A. | Eating | | 6 | Bob B. | Horse Riding | +------+--------------+---------------+ singing   Solution 2020-09-30 Notes:   设计的很好的一个题。这题告诉我们一个道理：\n window function 可以内嵌 aggregation function    OVER(ORDER BY activity) 会return by alphabetical 的order DENSE_RANK() returns contiguous ranking.  SELECT activity FROM ( SELECT activity, DENSE_RANK() OVER(ORDER BY COUNT(*)) as rk_asc, DENSE_RANK() OVER(ORDER BY COUNT(*) DESC) as rk_desc FROM Friends GROUP BY activity ) a WHERE rk_asc != 1 and rk_desc != 1  ","id":147,"section":"posts","summary":"LC 1355 Activity Participants Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants. Return the result table in any order. Each activity in table Activities is performed by any person in the table Friends. The query result format is in the following example: Friends table: +------+--------------+---------------+ | id | name | activity | +------+--------------+---------------+ | 1 | Jonathan D.","tags":["leetcode","dia_sql"],"title":"1355 Activity Participants","uri":"https://foxisawesome.github.io/posts/1355-activity-participants/","year":"2020"},{"content":"LC 227 Basic Calculator II   Implement a basic calculator to evaluate a simple expression string.\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero.\nInput: \u0026quot;3+2*2\u0026quot; Output: 7   Solution 2020-09-30 Notes:   Calculator 3 题：LC 224, LC 227, LC 772 都好难。三题的解法大同小异，但是很多细节很容易出错。\n  要使用运算符号得知道operator 左右两边的数。所以这里得用prev_op来进行计算。\nalgo里的 variable example： stack.pop() prev_op digit\n  只要 val 是 operator时操作完需要更新。这里有好多细节：for loop下是两个if; digit 的更新不要写成 +=; prev_op为 +\\- 时 只能append，不能写成 *, /的形式。\n  class Solution: def calculate(self, s: str) -\u0026gt; int: stack, digit, prev_op = [], 0, '+' n = len(s) for i, val in enumerate(s): if val.isdigit(): digit = digit*10 + int(val) if i==n-1 or val in ('+','-','*','/'): if prev_op == \u0026quot;+\u0026quot;: stack.append(digit) elif prev_op == '-': stack.append(-digit) elif prev_op == '*': temp = stack.pop() * digit stack.append(temp) elif prev_op == '/': temp = int(stack.pop() / digit) stack.append(temp) digit = 0 prev_op = val return sum(stack) # Time O(N) # Space O(N)  ","id":148,"section":"posts","summary":"LC 227 Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero. Input: \u0026quot;3+2*2\u0026quot; Output: 7 Solution 2020-09-30 Notes: Calculator 3 题：LC 224, LC 227, LC 772 都好难。三题的解法大同小异，","tags":["leetcode","stack","dia"],"title":"227 Basic Calculator II","uri":"https://foxisawesome.github.io/posts/227-basic-calculator-ii/","year":"2020"},{"content":"LC 76 Minimum Window Substring   Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nInput: S = \u0026quot;ADOBECODEBANC\u0026quot;, T = \u0026quot;ABC\u0026quot; Output: \u0026quot;BANC\u0026quot;   Solution 2020-09-30 Notes:  sliding window 的同时，需要online update minimum length，并用一个dict 记录下来。 这次二刷，简短了一些，但是运行时间上看没有improve。  class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n = len(s) window, target = collections.Counter(), collections.Counter() for i in t: target[i] += 1 l, valid = 0, 0 ans, mini = \u0026quot;\u0026quot;, float('inf') for r in range(n): window[s[r]] += 1 if window[s[r]] == target[s[r]]: valid += 1 while valid == len(target): if r-l+1 \u0026lt; mini: mini, ans = r-l+1, s[l:r+1] window[s[l]] -= 1 if window[s[l]] \u0026lt; target[s[l]]: valid -= 1 l += 1 return ans # Time O(N) # Space O(N)  2020-08-10 Notes: labuladong 提供的一个不错的模版版本。\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: tcount, window = {}, {} for i in t: tcount[i] = tcount.get(i,0) + 1 left, right = 0, 0 valid = 0 # ini para for minimium str start, len_sub = 0, float('inf') while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] right += 1 if c in tcount: window[c] = window.get(c,0) + 1 if window[c] == tcount[c]: valid += 1 # shrinking window left point while (valid == len(tcount)): if right - left \u0026lt; len_sub: start = left len_sub = right - left d = s[left] left += 1 if d in tcount: if window[d] == tcount[d]: valid -= 1 window[d] = window.get(d,0) - 1 return \u0026quot;\u0026quot; if len_sub==float('inf') else s[start:start+len_sub] # Time O(N) # Space O(N)  ","id":149,"section":"posts","summary":"LC 76 Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Input: S = \u0026quot;ADOBECODEBANC\u0026quot;, T = \u0026quot;ABC\u0026quot; Output: \u0026quot;BANC\u0026quot; Solution 2020-09-30 Notes: sliding window 的同时，需要online update minimum length，并用一个d","tags":["leetcode","sliding_window"],"title":"76 Minimum Window Substring","uri":"https://foxisawesome.github.io/posts/76-minimum-window-substring/","year":"2020"},{"content":"LC 728 Self Dividing Numbers   A self-dividing number is a number that is divisible by every digit it contains.\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\nAlso, a self-dividing number is not allowed to contain the digit zero.\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\nInput: left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Solution 2020-09-29 Notes:  按照定义 打一遍就好了。  class Solution: def selfDividingNumbers(self, left: int, right: int) -\u0026gt; List[int]: ans = [] for i in range(left, right + 1): if self.helper(i): ans.append(i) return ans def helper(self, n): for i in str(n): if i == '0' or n % int(i) != 0: return False return True # Time O(N) # Space O(N)  ","id":150,"section":"posts","summary":"LC 728 Self Dividing Numbers A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing","tags":["leetcode"],"title":"728 Self Dividing Numbers","uri":"https://foxisawesome.github.io/posts/728-self-dividing-numbers/","year":"2020"},{"content":"LC 793 Preimage Size of Factorial Zeroes Function   Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\n Solution 2020-09-29 Notes:  首先这题是 LC 172 衍生。下面的helper func fives() 就是172. 其次这题解其实就两种情况，0 或者 5。 因为要么 K 个零正好符合摸个数 m!，那么 (m+4)!, (m+3)!, (m+2)!, (m+1)!, m! 正好有同样多的trailing 0. 所以return 5. 要么就是给定的 K 个零无法满足任何 n!, return 0. 所以可以用 binary search 锁定这个m。up bound is 5K，就在 self.fives() 里，能保值 fives(5K) \u0026gt; K。 返回 l 时多个判断就好了。  class Solution: def preimageSizeFZF(self, K: int) -\u0026gt; int: l, r = 1, K*5 while l \u0026lt;= r: m = l + (r-l)//2 if self.fives(m) \u0026lt; K: l = m + 1 elif self.fives(m) \u0026gt;= K: r = m - 1 if self.fives(l) != K: return 0 return 5 def fives(self, n): c = 0 while n \u0026gt; 0: n //= 5 c += n return c # Time O(log(5K)*log(5K)) # Space O(1)  ","id":151,"section":"posts","summary":"LC 793 Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K,","tags":["leetcode","binary_search","dia"],"title":"793 Preimage Size of Factorial Zeroes Function","uri":"https://foxisawesome.github.io/posts/793-preimage-size-of-factorial-zeroes-function/","year":"2020"},{"content":"LC 172 Factorial Trailing Zeroes   Given an integer n, return the number of trailing zeroes in n!.\nFollow up: Could you write a solution that works in logarithmic time complexity?\n Solution 2020-09-29 Notes:  count N 中有几个5, 就一定有几个0. 这个写法很高级。相当于 5 分法，所以time complexity是 $\\mathcal{O}(\\log_5 N)$.  class Solution: def trailingZeroes(self, n: int) -\u0026gt; int: zero_count = 0 while n \u0026gt; 0: n //= 5 zero_count += n return zero_count # Time O(logN) # Space O(1)  ","id":152,"section":"posts","summary":"LC 172 Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Follow up: Could you write a solution that works in logarithmic time complexity? Solution 2020-09-29 Notes: count N 中有几个5, 就一定有几个0. 这个写法很高级。相当于 5 分法，所以time","tags":["leetcode","dia"],"title":"172 Factorial Trailing Zeroes","uri":"https://foxisawesome.github.io/posts/172-factorial-trailing-zeroes/","year":"2020"},{"content":"LC 1288 Remove Covered Intervals   Given a list of intervals, remove all intervals that are covered by another interval in the list. Interval [a,b) is covered by interval [c,d) if and only if c \u0026lt;= a and b \u0026lt;= d.\nAfter doing so, return the number of remaining intervals.\nInput: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.   Solution 2020-09-29 Notes:  排序后有两种可能，列出来就好了。第二种情况删的是 i-th interval，所以下次比较时 i+1 要与 i-1 比较，所以 swap 了一下。  class Solution: def removeCoveredIntervals(self, intervals: List[List[int]]) -\u0026gt; int: n = len(intervals) c = 0 intervals.sort(key = lambda x: (x[0],x[1])) for i in range(1,n): if intervals[i-1][0] == intervals[i][0]: c += 1 elif intervals[i-1][1] \u0026gt;= intervals[i][1]: intervals[i-1], intervals[i] = intervals[i], intervals[i-1] c += 1 return n-c # Time O(NlogN) # Space O(1)  ","id":153,"section":"posts","summary":"LC 1288 Remove Covered Intervals Given a list of intervals, remove all intervals that are covered by another interval in the list. Interval [a,b) is covered by interval [c,d) if and only if c \u0026lt;= a and b \u0026lt;= d. After doing so, return the number of remaining intervals. Input: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed. Solution 2020-09-29 Notes: 排","tags":["leetcode","array"],"title":"1288 Remove Covered Intervals","uri":"https://foxisawesome.github.io/posts/1288-remove-covered-intervals/","year":"2020"},{"content":"LC 1113 Reported Posts   Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05.\n Solution 2020-09-29 Notes: SELECT report_reason, report_count FROM ( SELECT extra as report_reason, COUNT(*) as report_count FROM ( SELECT DISTINCT post_id, extra FROM actions WHERE DATEDIFF('2019-07-05',action_date)=1 AND action = 'report' ) a GROUP BY 1 ) b WHERE report_reason IS NOT NULL ;  ","id":154,"section":"posts","summary":"LC 1113 Reported Posts   Write an SQL query that reports the number of posts reported yesterday for each report reason. Assume today is 2019-07-05.\n Solution 2020-09-29 Notes: SELECT report_reason, report_count FROM ( SELECT extra as report_reason, COUNT(*) as report_count FROM ( SELECT DISTINCT post_id, extra FROM actions WHERE DATEDIFF('2019-07-05',action_date)=1 AND action = 'report' ) a GROUP BY 1 ) b WHERE report_reason IS NOT NULL ;  ","tags":["leetcode"],"title":"1113 Reported Posts","uri":"https://foxisawesome.github.io/posts/1113-reported-posts/","year":"2020"},{"content":"LC 1045 Customers Who Bought All Products   Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table.\n Solution 2020-09-29 Notes: SELECT customer_id FROM ( SELECT customer_id, COUNT(DISTINCT product_key) AS ct FROM customer GROUP BY customer_id ORDER BY 1 ) a WHERE ct = (SELECT COUNT(*) from product) ORDER BY 1 ;  ","id":155,"section":"posts","summary":"LC 1045 Customers Who Bought All Products   Write an SQL query for a report that provides the customer ids from the Customer table that bought all the products in the Product table.\n Solution 2020-09-29 Notes: SELECT customer_id FROM ( SELECT customer_id, COUNT(DISTINCT product_key) AS ct FROM customer GROUP BY customer_id ORDER BY 1 ) a WHERE ct = (SELECT COUNT(*) from product) ORDER BY 1 ;  ","tags":["leetcode"],"title":"1045 Customers Who Bought All Products","uri":"https://foxisawesome.github.io/posts/1045-customers-who-bought-all-products/","year":"2020"},{"content":"LC 627 Swap Salary   SQL Schema\nGiven a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\n Solution 2020-09-29 Notes:  UPDATE statement. Memorize it.  UPDATE salary SET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END;  ","id":156,"section":"posts","summary":"LC 627 Swap Salary   SQL Schema\nGiven a table salary, such as the one below, that has m=male and f=female values. Swap all f and m values (i.e., change all f values to m and vice versa) with a single update statement and no intermediate temp table.\nNote that you must write a single update statement, DO NOT write any select statement for this problem.\n Solution 2020-09-29 Notes:  UPDATE statement.","tags":["leetcode","dia"],"title":"627 Swap Salary","uri":"https://foxisawesome.github.io/posts/627-swap-salary/","year":"2020"},{"content":"LC 577 Employee Bonus   Select all employee\u0026rsquo;s name and bonus whose bonus is \u0026lt; 1000.\nTable:Employee\n+-------+--------+-----------+--------+ | empId | name | supervisor| salary | +-------+--------+-----------+--------+ | 1 | John | 3 | 1000 | | 2 | Dan | 3 | 2000 | | 3 | Brad | null | 4000 | | 4 | Thomas | 3 | 4000 | +-------+--------+-----------+--------+ empId is the primary key column for this table.  Table: Bonus\n+-------+-------+ | empId | bonus | +-------+-------+ | 2 | 500 | | 4 | 2000 | +-------+-------+ empId is the primary key column for this table.  Example ouput:\n+-------+-------+ | name | bonus | +-------+-------+ | John | null | | Dan | 500 | | Brad | null | +-------+-------+   Solution 2020-09-29 Notes:  its output format is specific, which leads to the where clause below.  SELECT name, bonus FROM employee a LEFT JOIN bonus b ON a.empid = b.empid WHERE bonus \u0026lt; 1000 OR bonus IS NULL  ","id":157,"section":"posts","summary":"LC 577 Employee Bonus   Select all employee\u0026rsquo;s name and bonus whose bonus is \u0026lt; 1000.\nTable:Employee\n+-------+--------+-----------+--------+ | empId | name | supervisor| salary | +-------+--------+-----------+--------+ | 1 | John | 3 | 1000 | | 2 | Dan | 3 | 2000 | | 3 | Brad | null | 4000 | | 4 | Thomas | 3 | 4000 | +-------+--------+-----------+--------+ empId is the primary key column for this table.","tags":["leetcode"],"title":"577 Employee Bonus","uri":"https://foxisawesome.github.io/posts/577-employee-bonus/","year":"2020"},{"content":"LC 574 Winning Candidate   Write a sql to find the name of the winning candidate, the above example will return the winner B.\n Solution 2020-09-29 Notes:  先 group by, 在 order by 里放 aggregation function  SELECT name FROM candidate WHERE id = ( SELECT candidateid FROM vote GROUP BY candidateid ORDER BY COUNT(*) DESC LIMIT 1 )  2020-10-14 Notes:  Window function + aggregation function  SELECT name FROM candidate a JOIN ( SELECT *, RANK() OVER(ORDER BY COUNT(id) DESC) AS rk FROM vote GROUP BY candidateID ) b ON a.id = b.candidateID AND b.rk = 1  ","id":158,"section":"posts","summary":"LC 574 Winning Candidate Write a sql to find the name of the winning candidate, the above example will return the winner B. Solution 2020-09-29 Notes: 先 group by, 在 order by 里放 aggregation function SELECT name FROM candidate WHERE id = ( SELECT candidateid FROM vote GROUP BY candidateid ORDER BY COUNT(*) DESC LIMIT 1 ) 2020-10-14 Notes: Window function + aggregation function SELECT name FROM candidate a","tags":["leetcode"],"title":"574 Winning Candidate","uri":"https://foxisawesome.github.io/posts/574-winning-candidate/","year":"2020"},{"content":"LC 534 Game Play Analysis III   Write an SQL query that reports for each player and date, how many games played so far by the player. That is, the total number of games played by the player until that date. Check the example for clarity.\nThe query result format is in the following example:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 1 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+------------+---------------------+ | player_id | event_date | games_played_so_far | +-----------+------------+---------------------+ | 1 | 2016-03-01 | 5 | | 1 | 2016-05-02 | 11 | | 1 | 2017-06-25 | 12 | | 3 | 2016-03-02 | 0 | | 3 | 2018-07-03 | 5 | +-----------+------------+---------------------+   Solution 2020-09-29 Notes:  SUM() OVER(ORDER BY) gives cumulative results.  SELECT player_id, event_date, SUM(games_played) OVER(PARTITION BY player_id ORDER BY event_date) AS games_played_so_far FROM activity ORDER BY 1, 2  ","id":159,"section":"posts","summary":"LC 534 Game Play Analysis III   Write an SQL query that reports for each player and date, how many games played so far by the player. That is, the total number of games played by the player until that date. Check the example for clarity.\nThe query result format is in the following example:\nActivity table: +-----------+-----------+------------+--------------+ | player_id | device_id | event_date | games_played | +-----------+-----------+------------+--------------+ | 1 | 2 | 2016-03-01 | 5 | | 1 | 2 | 2016-05-02 | 6 | | 1 | 3 | 2017-06-25 | 1 | | 3 | 1 | 2016-03-02 | 0 | | 3 | 4 | 2018-07-03 | 5 | +-----------+-----------+------------+--------------+ Result table: +-----------+------------+---------------------+ | player_id | event_date | games_played_so_far | +-----------+------------+---------------------+ | 1 | 2016-03-01 | 5 | | 1 | 2016-05-02 | 11 | | 1 | 2017-06-25 | 12 | | 3 | 2016-03-02 | 0 | | 3 | 2018-07-03 | 5 | +-----------+------------+---------------------+   Solution 2020-09-29 Notes:  SUM() OVER(ORDER BY) gives cumulative results.","tags":["leetcode"],"title":"534 Game Play Analysis III","uri":"https://foxisawesome.github.io/posts/534-game-play-analysis-iii/","year":"2020"},{"content":"LC 567 Permutation in String   Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\u0026rsquo;s permutations is the substring of the second string.\nInput: s1 = \u0026quot;ab\u0026quot; s2 = \u0026quot;eidbaooo\u0026quot; Output: True Explanation: s2 contains one permutation of s1 (\u0026quot;ba\u0026quot;).   Solution 2020-09-29 Notes:  这题用了sliding window的思想，就是s2中的subarray的length 和 s1一致，然后字母的count一致。那么s1的permutation一定在s2中。 剩下的就是很简单的sliding window的标准模版了。  class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: d, target = collections.Counter(), collections.Counter() l, valid = 0, 0 n1, n2 = len(s1), len(s2) for i in s1: target[i] += 1 for r in range(n2): d[s2[r]] += 1 if d[s2[r]] == target[s2[r]]: valid += 1 while valid == len(target): if r-l+1 == n1: return True d[s2[l]] -= 1 if d[s2[l]] \u0026lt; target[s2[l]]: valid -= 1 l += 1 return False # Time O(N) # Space O(N)  2020-08-10 Notes: 看了labuladong的解：\nclass Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: left, right = 0, 0 ns1, ns2 = len(s1), len(s2) target, window = {}, {} for i in s1: target[i] = target.get(i,0) + 1 valid, len_sub = 0, float('inf') while right \u0026lt; ns2: c = s2[right] right += 1 if c in target: window[c] = window.get(c,0) + 1 if window[c] == target[c]: valid += 1 while (right - left \u0026gt;= ns1): if (valid == len(target)): return True d = s2[left] left += 1 if d in target: if window[d] == target[d]: valid -= 1 window[d] = window.get(d,0) - 1 return False  ","id":160,"section":"posts","summary":"LC 567 Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\u0026rsquo;s permutations is the substring of the second string. Input: s1 = \u0026quot;ab\u0026quot; s2 = \u0026quot;eidbaooo\u0026quot; Output: True Explanation: s2 contains one permutation of s1 (\u0026quot;ba\u0026quot;). Solution 2020-09-29 Notes: 这题用了slidin","tags":["leetcode","sliding_window"],"title":"567 Permutation in String","uri":"https://foxisawesome.github.io/posts/567-permutation-in-string/","year":"2020"},{"content":"LC 930 Binary Subarrays With Sum   In an array A of 0s and 1s, how many non-empty subarrays have sum S?\nInput: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]   Solution 2020-09-29 Notes:  第一刷时按topic来刷的，这一些列题都几乎一摸一样。 别忘了 if S \u0026lt; 0: return 0 这个条件。  class Solution: def numSubarraysWithSum(self, A: List[int], S: int) -\u0026gt; int: if not A: return 0 return self.atMost(A,S) - self.atMost(A, S-1) def atMost(self, A, S): if S \u0026lt; 0: return 0 n = len(A) l, c = 0, 0 ans = 0 for r in range(n): c += A[r] while l \u0026lt; n and c \u0026gt; S: c -= A[l] l += 1 ans += r-l+1 return ans # Time O(N) # Space O(1)  ","id":161,"section":"posts","summary":"LC 930 Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S? Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Solution 2020-09-29 Notes: 第一刷时按topic来刷的，这一些列题都几乎一摸一样","tags":["leetcode","sliding_window"],"title":"930 Binary Subarrays With Sum","uri":"https://foxisawesome.github.io/posts/930-binary-subarrays-with-sum/","year":"2020"},{"content":"LC 1004 Max Consecutive Ones III   Given an array A of 0s and 1s, we may change up to K values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s.\nInput: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.   Solution 2020-09-28 Notes:   这其实是倒挺简单的sliding window题，但是corner case太恶心了。\ne.g. [1,1,1,0,0,0,1,1,1,1] 0， 可能这种极端情况。\n[0,0,0,1] 4 可能flips 不需要用满\n  最后的solution就是把 sliding window的while 改成 if。 每次只shrink一步。就能统一各种情况解。\n  class Solution: def longestOnes(self, A: List[int], K: int) -\u0026gt; int: l, c = 0, 0 n = len(A) for r in range(n): if A[r] == 0: c += 1 if c \u0026gt; K: if A[l] == 0: c -= 1 l += 1 return r-l+1 # Time O(N) # Space O(1)  ","id":162,"section":"posts","summary":"LC 1004 Max Consecutive Ones III Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Solution 2020-09-28 Notes: 这其实是倒挺","tags":["leetcode","sliding_window"],"title":"1004 Max Consecutive Ones III","uri":"https://foxisawesome.github.io/posts/1004-max-consecutive-ones-iii/","year":"2020"},{"content":"LC 1248 Count Number of Nice Subarrays   Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nInput: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].   Solution 2020-09-28 Notes:  这是与LC 992 一摸一样的题。其实临界点应该是 K+1. 其次 sliding window解决 at most 或者 minimum 的问题。 Again ans += r-l+1 returns the total number of contiguous subarray under nums[l:r+1]  class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: return self.atMost(nums, k) - self.atMost(nums, k-1) def atMost(self, nums, k): n = len(nums) l, c = 0, 0 ans = 0 for r in range(n): if nums[r]%2==1: c+=1 while c \u0026gt; k: if nums[l] % 2 == 1: c -= 1 l += 1 ans += r-l+1 return ans # Time O(N) # Space O(1)  ","id":163,"section":"posts","summary":"LC 1248 Count Number of Nice Subarrays Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Input: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. Solution 2020-09-28 Notes: 这是与LC 992 一摸一","tags":["leetcode","sliding_window"],"title":"1248 Count Number of Nice Subarrays","uri":"https://foxisawesome.github.io/posts/1248-count-number-of-nice-subarrays/","year":"2020"},{"content":"LC 1358 Number of Substrings Containing All Three Characters   Given a string s consisting only of characters a, b and c.\nReturn the number of substrings containing at least one occurrence of all these characters a, b and c.\nInput: s = \u0026quot;abcabc\u0026quot; Output: 10 Explanation: The substrings containing at least one occurrence of the characters a, b and c are \u0026quot;abc\u0026quot;, \u0026quot;abca\u0026quot;, \u0026quot;abcab\u0026quot;, \u0026quot;abcabc\u0026quot;, \u0026quot;bca\u0026quot;, \u0026quot;bcab\u0026quot;, \u0026quot;bcabc\u0026quot;, \u0026quot;cab\u0026quot;, \u0026quot;cabc\u0026quot; and \u0026quot;abc\u0026quot; (again).   Solution 2020-09-28 Notes:  Sliding window 只能处理at most的问题，那怎么转换到 at least 呢。很简单，但只要找到满足条件的子序列后，后面的所有字母加上都legit。所以ans += n-r这样就转成了 at least的解了  class Solution: def numberOfSubstrings(self, s: str) -\u0026gt; int: n = len(s) d = collections.Counter() l = 0 valid = 0 ans = 0 for r in range(n): if d[s[r]] == 0: valid += 1 d[s[r]] += 1 while valid == 3: ans += n - r d[s[l]] -= 1 if d[s[l]] == 0: valid -= 1 l += 1 return ans # Time O(N) # Space O(1)  ","id":164,"section":"posts","summary":"LC 1358 Number of Substrings Containing All Three Characters Given a string s consisting only of characters a, b and c. Return the number of substrings containing at least one occurrence of all these characters a, b and c. Input: s = \u0026quot;abcabc\u0026quot; Output: 10 Explanation: The substrings containing at least one occurrence of the characters a, b and c are \u0026quot;abc\u0026quot;, \u0026quot;abca\u0026quot;, \u0026quot;abcab\u0026quot;, \u0026quot;abcabc\u0026quot;, \u0026quot;bca\u0026quot;, \u0026quot;bcab\u0026quot;, \u0026quot;bcabc\u0026quot;, \u0026quot;cab\u0026quot;, \u0026quot;cabc\u0026quot;","tags":["leetcode","sliding_window"],"title":"1358 Number of Substrings Containing All Three Characters","uri":"https://foxisawesome.github.io/posts/1358-number-of-substrings-containing-all-three-characters/","year":"2020"},{"content":"LC 992 Subarrays With K Different Integers   Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\nInput: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].   Solution 2020-09-28 Notes:   看了论坛里的最高分解答。对我来说最难理解的两点：\n  sliding window只能解最多/最短的sub-array的问题，如何转换。这里他建了一个helper function，做at most K distinct number\n  c += r-l+1 why? 这其实是个summation: $\\sum_{l=0}^{r} (r-l+1)$ 意思是长度为(r-l+1)的array下所有contiguous subarray 的个数\ne.g.: [1,2,1,2] will produce a total of 10 different contiguous subarrays:\n [1,2,1,2] (1 different contiguous subarrays with length 4) [1,2,1], [2,1,2] (2 different contiguous subarrays with length 3) [1, 2], [1,2], [2,1](3 different contiguous subarrays with length 2) [1], [2], [1], [2] (4 different contiguous subarrays with length 1)    当 shriking 的 while loop启动时，计算的是 新的subarray的个数，不计入之前出现过的subarray。\n     class Solution: def subarraysWithKDistinct(self, A: List[int], K: int) -\u0026gt; int: return self.atMost(A,K) - self.atMost(A,K-1) def atMost(self, A, K): n = len(A) c, l = 0, 0 d = collections.Counter() for r in range(n): if d[A[r]] == 0: K -= 1 d[A[r]] += 1 while K \u0026lt; 0: d[A[l]] -= 1 if d[A[l]] == 0: K += 1 l += 1 c += r - l + 1 return c # Time O(N) # Space O(1)  ","id":165,"section":"posts","summary":"LC 992 Subarrays With K Different Integers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Solution 2020-09-28 Notes: 看了论坛里的最","tags":["leetcode","sliding_window","dia"],"title":"992 Subarrays With K Different Integers","uri":"https://foxisawesome.github.io/posts/992-subarrays-with-k-different-integers/","year":"2020"},{"content":"LC 977 Squares of a Sorted Array   Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.\nInput: [-4,-1,0,3,10] Output: [0,1,9,16,100]   Solution 2020-09-28 Notes:  先找到零的位置再向两边走。  class Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: p, n = 0, len(A) while p \u0026lt; n and A[p] \u0026lt; 0: p += 1 ans = [] l, r = p-1, p while l\u0026gt;=0 and r\u0026lt;n: if abs(A[l]) \u0026gt;= abs(A[r]): ans.append(A[r]**2) r += 1 else: ans.append(A[l]**2) l -= 1 r = A[r:] if l\u0026lt;0 else A[:l+1][::-1] [ans.append(i**2) for i in r] return ans # Time O(N) # Space O(N)  one liner\nclass Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: return sorted(x**2 for x in A)  ","id":166,"section":"posts","summary":"LC 977 Squares of a Sorted Array Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Solution 2020-09-28 Notes: 先找到零的位置再向两边走。 class Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: p, n = 0, len(A) while p \u0026lt; n and A[p]","tags":["leetcode","two_pointers"],"title":"977 Squares of a Sorted Array","uri":"https://foxisawesome.github.io/posts/977-squares-of-a-sorted-array/","year":"2020"},{"content":"LC 16 3sum Closest   Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n Solution 2020-09-28 Notes:  这题其实只能穷举，用了sort之后可以prun 一些枝。  class Solution: def threeSumClosest(self, nums: List[int], target: int) -\u0026gt; int: d = dict() mini = float('inf') n = len(nums) nums.sort() for i, val in enumerate(nums): l, r = i+1, n-1 while l \u0026lt; r: sum_ = nums[i] + nums[l] + nums[r] diff = abs(sum_ - target) if diff == 0: return target if diff \u0026lt; mini: mini = min(mini, diff) d[diff]=sum_ if sum_ \u0026lt; target: l += 1 else: r -= 1 return d[mini] # Time O(N^2 + NlogN) # Space O(N)  ","id":167,"section":"posts","summary":"LC 16 3sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Solution 2020-09-28 Notes: 这题其实只能穷举，用了sort之后可以pr","tags":["leetcode","two_pointers","dia"],"title":"16 3sum Closest","uri":"https://foxisawesome.github.io/posts/16-3sum-closest/","year":"2020"},{"content":"LC 15 3sum   Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n Solution 2020-09-28 Notes:  这题最困难的地方时不能有dups。用这个条件很多次了 if i==0 or nums[i]!=nums[i-1]: 还得多刷几遍。  class Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: self.ans = [] n = len(nums) if n \u0026lt; 3: return self.ans nums.sort() for i, val in enumerate(nums): if val \u0026gt; 0: break if i==0 or nums[i]!=nums[i-1]: self.twoSum(nums, -val, i) return self.ans def twoSum(self, nums, target, i): l, r = i+1, len(nums)-1 while l \u0026lt; r: if target == 1: print(l,r) sum_ = nums[l] + nums[r] if sum_ \u0026lt; target: l += 1 elif sum_ \u0026gt; target: r -= 1 else: self.ans.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l \u0026lt; r and nums[l] == nums[l-1]: l += 1 # Time O(N) # Space O(N)  ","id":168,"section":"posts","summary":"LC 15 3sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Solution 2020-09-28 Notes: 这题最困难的地方时不能有dups。用这个条件很多次了 if","tags":["leetcode","two_pointers","dia"],"title":"15 3sum","uri":"https://foxisawesome.github.io/posts/15-3sum/","year":"2020"},{"content":"LC 881 Boats to Save People   The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\nInput: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Solution 2020-09-28 Notes:  这题只允许最多carry two poeple 就使得整个问题简化了，可以有two pointers做。  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people.sort(reverse=True) l, r = 0, len(people)-1 while l \u0026lt;= r: if people[l] + people[r] \u0026gt; limit: l += 1 elif people[l] + people[r] \u0026lt;= limit: l += 1 r -= 1 return l # Time O(NlogN) # Space O(1)  ","id":169,"section":"posts","summary":"LC 881 Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Input: people","tags":["leetcode","two_pointers","DIA"],"title":"881 Boats to Save People","uri":"https://foxisawesome.github.io/posts/881-boats-to-save-people/","year":"2020"},{"content":"LC 986 Interval List Intersections   Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\n(Formally, a closed interval [a, b] (with a \u0026lt;= b) denotes the set of real numbers x with a \u0026lt;= x \u0026lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)\n\nInput: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]   Solution 2020-09-27 Notes:  很简单的题，按照所有可能的情况一一列举就好了。  class Solution: def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -\u0026gt; List[List[int]]: ans = [] na, nb = len(A), len(B) pa, pb = 0, 0 while pa \u0026lt; na and pb \u0026lt; nb: if B[pb][0] \u0026lt; A[pa][0]: if B[pb][1] \u0026lt; A[pa][0]: pb += 1 elif A[pa][0] \u0026lt;= B[pb][1] \u0026lt;= A[pa][1]: ans.append([A[pa][0],B[pb][1]]) pb += 1 elif B[pb][1] \u0026gt; A[pa][1]: ans.append(A[pa]) pa += 1 elif A[pa][0] \u0026lt;= B[pb][0] \u0026lt;= A[pa][1]: if B[pb][1] \u0026lt;= A[pa][1]: ans.append(B[pb]) pb += 1 elif B[pb][1] \u0026gt; A[pa][1]: ans.append([B[pb][0], A[pa][1]]) pa += 1 elif B[pb][0] \u0026gt; A[pa][1]: pa += 1 return ans # Time O(M+N) # Space O(N)  ","id":170,"section":"posts","summary":"LC 986 Interval List Intersections Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a \u0026lt;= b) denotes the set of real numbers x with a \u0026lt;= x \u0026lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or","tags":["leetcode","two_pointers"],"title":"986 Interval List Intersections","uri":"https://foxisawesome.github.io/posts/986-interval-list-intersections/","year":"2020"},{"content":"LC 925 Long Pressed Name   Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n Solution 2020-09-27 Notes:  这题好多坑，我第一次做很官方的two-pointers solution几乎一样， 但是打了很多次布丁才过。得多练练。  class Solution: def isLongPressedName(self, name: str, typed: str) -\u0026gt; bool: t = len(typed) n = len(name) if name[0] != typed[0]: return False pT, pN = 1, 1 while pT \u0026lt; t and pN \u0026lt; n: if typed[pT] == name[pN]: pT += 1 pN += 1 elif typed[pT] == typed[pT-1]: pT += 1 else: return False while pT \u0026lt; t: if typed[pT] != name[-1]: return False pT += 1 return pN == n # Time O(N+T) # Space O(1)  这个别人的答案很简洁。\nclass Solution: def isLongPressedName(self, name: str, typed: str) -\u0026gt; bool: i = 0 for j in range(len(typed)): if i \u0026lt; len(name) and name[i] == typed[j]: i += 1 elif j == 0 or typed[j] != typed[j-1]: return False return i == len(name)  ","id":171,"section":"posts","summary":"LC 925 Long Pressed Name Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Solution 2020-09-27 Notes: 这题好","tags":["leetcode","two_pointers","dia"],"title":"925 Long Pressed Name","uri":"https://foxisawesome.github.io/posts/925-long-pressed-name/","year":"2020"},{"content":"LC 455 Assign Cookies   Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj \u0026gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n Solution 2020-09-27 Notes:  分配cookies时尽可能物尽其用，所以将s, g先排序再比较。  class Solution: def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: if not s or not g: return 0 g.sort(reverse=True) s.sort(reverse=True) c, p = 0, 0 for i in s: while p \u0026lt; len(g): if i \u0026gt;= g[p]: c += 1 p += 1 break p += 1 return c # Time O(MlogM + NlogN) # Space O(1)  ","id":172,"section":"posts","summary":"LC 455 Assign Cookies Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj \u0026gt;= gi, we can assign the cookie j to","tags":["leetcode","two_pointers"],"title":"455 Assign Cookies","uri":"https://foxisawesome.github.io/posts/455-assign-cookies/","year":"2020"},{"content":"LC 152 Valid Palindrome   Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nNote: For the purpose of this problem, we define empty string as valid palindrome.\ne.g. “0P”, “.,”\n Solution 2020-09-27 Notes:  题目本身很简单，但是two notes：1. while套while时，得把上层的while condition写进下层。其次这题得用 isalnum() 而不是 alpha(). 不然 “0P”的case 不能过。  class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: if not s: return True l, r = 0, len(s)-1 while l \u0026lt; r: while l\u0026lt;r and not s[l].isalnum(): l += 1 while l\u0026lt;r and not s[r].isalnum(): r -= 1 if l\u0026lt;r and s[l].lower() != s[r].lower(): return False l += 1 r -= 1 return True # Time O(N) # Space O(1)  ","id":173,"section":"posts","summary":"LC 152 Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. e.g. “0P”, “.,” Solution 2020-09-27 Notes: 题目本身很简单，但是two notes：1. wh","tags":["leetcode","two_pointers"],"title":"152 Valid Palindrome","uri":"https://foxisawesome.github.io/posts/152-valid-palindrome/","year":"2020"},{"content":"LC 11 Container With Most Water   Given n non-negative integers a1, a2, \u0026hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n Solution 2020-09-27 Notes:  左右pointers同时相向，较小的移动，online update 水容量。  class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: l, r = 0, len(height)-1 ans = 0 while l \u0026lt; r: l_bar, r_bar = height[l], height[r] ans = max(ans, min(l_bar, r_bar)*(r-l)) if l_bar \u0026gt; r_bar: r -= 1 else: l += 1 return ans # Time O(N) # Space O(1)  ","id":174,"section":"posts","summary":"LC 11 Container With Most Water Given n non-negative integers a1, a2, \u0026hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Solution 2020-09-27 Notes: 左右poi","tags":["leetcode","two_pointers"],"title":"11 Container With Most Water","uri":"https://foxisawesome.github.io/posts/11-container-with-most-water/","year":"2020"},{"content":"LC 74 Search a 2d Matrix   Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.   Solution 2020-09-25 Notes:  Right bound binary search returns the closest left bound, e.g. binarySearch([1,3,5,7], 4). 两次binary search 搞定。 其他做法还有从 左下，右上遍历。 reshape了用 in。 兄妹题 LC 240 得用右上到左下 two_pointers 遍历一遍。  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: if not matrix or len(matrix)== 0 or len(matrix[0]) == 0: return 0 nr, nc = len(matrix), len(matrix[0]) nums = [] for i in range(nr): nums.append(matrix[i][0]) row = self.binarySearch(nums, target) col = self.binarySearch(matrix[row], target) print(row, col) return matrix[row][col] == target def binarySearch(self, nums, target): l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r-l)//2 if nums[m] \u0026lt;= target: l = m + 1 elif nums[m] \u0026gt; target: r = m - 1 return r # Time O(NR + logNC) # Space O(NR)  ","id":175,"section":"posts","summary":"LC 74 Search a 2d Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Solution 2020-09-25 Notes: Right bound binary search returns the closest left bound, e.g. binarySearch([1,3,5,7], 4). 两次","tags":["leetcode","binary_search"],"title":"74 Search a 2d Matrix","uri":"https://foxisawesome.github.io/posts/74-search-a-2d-matrix/","year":"2020"},{"content":" [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip(['a','b'],['c','d'])]: [[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;c\u0026rsquo;], [\u0026lsquo;b\u0026rsquo;, \u0026rsquo;d']] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]   sort a by b: [x for _,x in sorted(zip(b,a))]  ","id":176,"section":"posts","summary":" [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip(['a','b'],['c','d'])]: [[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;c\u0026rsquo;], [\u0026lsquo;b\u0026rsquo;, \u0026rsquo;d']] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]   sort a by b: [x for _,x in sorted(zip(b,a))]  ","tags":null,"title":"Cheatsheet","uri":"https://foxisawesome.github.io/posts/cheatsheet/","year":"2020"},{"content":"LC 36 Valid Sudoku   Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.  A partially filled sudoku which is valid.\n Solution 2020-09-25 Notes:  按着题目要求实现就好了。 [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]].  class Solution: def isValidSudoku(self, board: List[List[str]]) -\u0026gt; bool: return self.boxValid(board) and self.colValid(board) and self.rowValid(board) def rowValid(self, board): for i in range(9): t = [str(x) for x in range(1,10)] for j in range(9): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True def colValid(self, board): for j in range(9): t = [str(x) for x in range(1,10)] for i in range(9): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True def boxValid(self, board): points = [[x,y] for x in [0,3,6] for y in [0,3,6]] for p in points: t = [str(x) for x in range(1,10)] for i in range(p[0], p[0]+3): for j in range(p[1],p[1]+3): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True # Time O(N^2) # Space O(1)  ","id":177,"section":"posts","summary":"LC 36 Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. Solution 2020-09-25 Notes: 按","tags":["leetcode","matrix"],"title":"36 Valid Sudoku","uri":"https://foxisawesome.github.io/posts/36-valid-sudoku/","year":"2020"},{"content":"LC 771 Jewels and Stones   You\u0026rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \u0026quot;a\u0026quot; is considered a different type of stone from \u0026quot;A\u0026quot;.\nInput: J = \u0026quot;aA\u0026quot;, S = \u0026quot;aAAbbbb\u0026quot; Output: 3   Solution 2020-09-25 Notes:  这应该放第一道题啊。  class Solution: def numJewelsInStones(self, J: str, S: str) -\u0026gt; int: if not J or not S: return 0 j = set(J) c = 0 for s in S: if s in j: c += 1 return c # Time O(N) # Space O(1)  ","id":178,"section":"posts","summary":"LC 771 Jewels and Stones You\u0026rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so","tags":["leetcode","hashtable"],"title":"771 Jewels and Stones","uri":"https://foxisawesome.github.io/posts/771-jewels-and-stones/","year":"2020"},{"content":"LC 62 Unique Paths   A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nHow many possible unique paths are there?\n Solution 2020-09-25 Notes:  像climb stair的dp，robot只可能向右或者向下运动。所以路径只可能来自于dp[i][j-1] + dp[i-1][j]。在topmost 和 leftmost处恒为1.  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[0]*n for _ in range(m)] dp[0][0] = 1 if m==1 and n==1: return dp[-1][-1] for i in range(0,m): for j in range(0,n): if i == 0 and j != 0: dp[i][j] = 1 elif i != 0 and j == 0: dp[i][j] = 1 else: dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[-1][-1] # Time O(MN) # Space O(MN)  ","id":179,"section":"posts","summary":"LC 62 Unique Paths A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below). How many possible unique paths are there? Solution 2020-09-25 Notes: 像cli","tags":["leetcode","dp"],"title":"62 Unique Paths","uri":"https://foxisawesome.github.io/posts/62-unique-paths/","year":"2020"},{"content":"LC 819 Most Common Word   Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn\u0026rsquo;t banned, and that the answer is unique.\nWords in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.\nInput: paragraph = \u0026quot;Bob hit a ball, the hit BALL flew far after it was hit.\u0026quot; banned = [\u0026quot;hit\u0026quot;] Output: \u0026quot;ball\u0026quot;   Solution 2020-09-25 Notes:  API: lower(), split() default反而好用，要是specified split(‘ ’)就会出现连着两个空格分割有问题的情况。 replace() 那些特殊符号。 max() 还有key 这个argument，很好用啊。  class Solution: def mostCommonWord(self, paragraph: str, banned: List[str]) -\u0026gt; str: d = dict() b = set(banned) for c in \u0026quot;!?',;.\u0026quot;: paragraph = paragraph.replace(c, ' ') words = paragraph.lower().split() for w in words: if w not in b: d[w] = d.get(w,0) + 1 return max(d, key=d.get) # Time O(N) # Space O(N)  ","id":180,"section":"posts","summary":"LC 819 Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn\u0026rsquo;t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The","tags":["leetcode","string"],"title":"819 Most Common Word","uri":"https://foxisawesome.github.io/posts/819-most-common-word/","year":"2020"},{"content":"LC 1137 N Th Tribonacci Number   The Tribonacci sequence Tn is defined as follows:\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u0026gt;= 0.\nGiven n, return the value of Tn.\n Solution 2020-09-25 Notes:  加个memo在 def __init__(self): 能把整个recursion写在一个函数签名里。  class Solution: def __init__(self): self.memo = dict() self.memo[0] = 0 self.memo[1] = 1 self.memo[2] = 1 def tribonacci(self, n: int) -\u0026gt; int: if n in self.memo: return self.memo[n] self.memo[n] = self.tribonacci(n-1) + self.tribonacci(n-2) + self.tribonacci(n-3) return self.memo[n] # Time O(N) # Space O(N)  ","id":181,"section":"posts","summary":"LC 1137 N Th Tribonacci Number The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u0026gt;= 0. Given n, return the value of Tn. Solution 2020-09-25 Notes: 加个memo在 def __init__(self): 能把整个recursion写在一","tags":["leetcode","recursion"],"title":"1137 N Th Tribonacci Number","uri":"https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/","year":"2020"},{"content":"LC 303 Range Sum Query Immutable   Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nGiven nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3   Solution 2020-09-25 Notes:  这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求和的故事。 还有就是对 python class写法的考察，记得把 cum_sum 写在__init_里。  class NumArray: def __init__(self, nums: List[int]): if not nums: return n = len(nums) self.cum_sum = [0] * n self.cum_sum[0] = nums[0] for k in range(1,n): self.cum_sum[k] = self.cum_sum[k-1] + nums[k] def sumRange(self, i: int, j: int) -\u0026gt; int: return self.cum_sum[j] - self.cum_sum[i-1] if i!=0 else self.cum_sum[j] # Your NumArray object will be instantiated and called as such: # obj = NumArray(nums) # param_1 = obj.sumRange(i,j) # Time O(N) # Space O(N)  ","id":182,"section":"posts","summary":"LC 303 Range Sum Query Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3 Solution 2020-09-25 Notes: 这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求","tags":["leetcode","array"],"title":"303 Range Sum Query Immutable","uri":"https://foxisawesome.github.io/posts/303-range-sum-query-immutable/","year":"2020"},{"content":"LC 209 Minimum Size Subarray Sum   Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn\u0026rsquo;t one, return 0 instead.\nInput: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint   Solution 2020-09-25 Notes:  这题 O(N)的解法，很快就想到了sliding window。第一次盲code sliding window，发现好多implementation的细节。最后提交了好几次才完成。 比如在sum_ \u0026lt; s 时，不需要 额外的while loop。其次， 在shrinking left pointer，且不满足while condition时 不需要重制 sum_ 以及 l。 多做几遍需要！  class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -\u0026gt; int: if not nums: return 0 l, r = 0, 0 sum_ = 0 ans = float('inf') while r \u0026lt; n: sum_ += nums[r] r += 1 while sum_ \u0026gt;= s: sum_ -= nums[l] l += 1 ans = min(ans, r-l+1) return ans if ans != float('inf') else 0 # Time O(N) # Space O(1)  题目还提到了 O(NlogN)的做法，那就自然想到了 binary search。昨天刚好做了很多binary search的难题。 想要不超时的话，就必须pre-process cum_sum。爽！\n binary search的是一个length，所以范围在[1, len(nums)] 我们需要比较的是 len== mid 时的max sum vs s. 而且我们寻找的是 minimum len，所以在search时要保存一个ans=min(ans,m)  class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) l, r = 1, n ans = float('inf') cum_sum = [0] * n cum_sum[0] = nums[0] for i in range(1,n): cum_sum[i] = cum_sum[i-1] + nums[i] while l \u0026lt;= r: m = l + (r-l)//2 sum_ = cum_sum[m-1] for i in range(m,n): sum_ = max(sum_, cum_sum[i]-cum_sum[i-m]) if sum_ \u0026lt; s: l = m + 1 elif sum_ \u0026gt;= s: ans = min(ans,m) r = m - 1 return ans if ans != float('inf') else 0 # Time O(NlogN) # Space O(N)  ","id":183,"section":"posts","summary":"LC 209 Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn\u0026rsquo;t one, return 0 instead. Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint Solution 2020-09-25 Notes: 这题 O(N)的","tags":["leetcode","sliding_window","binary_search","dia"],"title":"209 Minimum Size Subarray Sum","uri":"https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/","year":"2020"},{"content":"LC 167 Two Sum II Input Array Is Sorted   Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\nInput: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.   Solution 2020-09-25 Notes:  最简单的一类 two pointers。左右相向，每次走一步。看起来很像，但不是binary search。  class Solution: def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]: if not numbers: return [-1,-1] left = 0 right = len(numbers)-1 while left \u0026lt;= right: if numbers[left] + numbers[right] == target: return [left+1, right+1] elif numbers[left] + numbers[right] \u0026lt; target: left += 1 elif numbers[left] + numbers[right] \u0026gt; target: right -= 1 return [-1,-1] # Time O(N) # Space O(1)  ","id":184,"section":"posts","summary":"LC 167 Two Sum II Input Array Is Sorted Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The","tags":["leetcode","two_pointers"],"title":"167 Two Sum II Input Array Is Sorted","uri":"https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/","year":"2020"},{"content":"LC 75 Sort Colors   Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nFollow up:\n Could you solve this problem without using the library\u0026rsquo;s sort function? Could you come up with a one-pass algorithm using only O(1) constant space?  Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2]   Solution 2020-09-25 Notes:  最简单 two-pass，space O(N)的算法。就是先count一遍，然后写入nums 高级的做法如下，两块隔板(l, r)的做法，l 隔开 0，1； r 隔开 1，2。然后一根指针游走于nums间。  class Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: n = len(nums) l, r = 0, n-1 i = 0 while i \u0026lt;= r: if nums[i] == 0: nums[i], nums[l] = nums[l], nums[i] i += 1 l += 1 elif nums[i] == 1: i += 1 elif nums[i] == 2: nums[i], nums[r] = nums[r], nums[i] r -= 1 return nums # Time O(N) # Space O(1)  ","id":185,"section":"posts","summary":"LC 75 Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Follow up: Could you solve this problem without using the library\u0026rsquo;s sort function?","tags":["leetcode","two_pointers","sort"],"title":"75 Sort Colors","uri":"https://foxisawesome.github.io/posts/75-sort-colors/","year":"2020"},{"content":"LC 181 Employees Earning More Than Their Managers   Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n Solution 2020-09-24 Notes: SELECT name AS employee FROM ( SELECT a.name, a.salary, a.managerId, b.salary AS mg_sal FROM employee a JOIN employee b ON a.managerID = b.ID ) c WHERE salary \u0026gt; mg_sal  ","id":186,"section":"posts","summary":"LC 181 Employees Earning More Than Their Managers   Given the Employee table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.\n Solution 2020-09-24 Notes: SELECT name AS employee FROM ( SELECT a.name, a.salary, a.managerId, b.salary AS mg_sal FROM employee a JOIN employee b ON a.managerID = b.ID ) c WHERE salary \u0026gt; mg_sal  ","tags":["leetcode"],"title":"181 Employees Earning More Than Their Managers","uri":"https://foxisawesome.github.io/posts/181-employees-earning-more-than-their-managers/","year":"2020"},{"content":"LC 180 Consecutive Numbers   Write a SQL query to find all numbers that appear at least three times consecutively.\n Solution 2020-09-24 Notes: self join 的写法\nSELECT DISTINCT a.num AS ConsecutiveNums FROM logs a JOIN logs b ON a.id+1 = b.id AND a.num=b.num JOIN logs c ON a.id+2 = c.id AND a.num=c.num  LEAD() function 的写法：\nSELECT DISTINCT num AS consecutiveNums FROM ( SELECT id, num, LEAD(num,1) over(ORDER BY id) AS l1, LEAD(num,2) over(ORDER BY id) AS l2 FROM logs ) a WHERE num = l1 AND num = l2  ","id":187,"section":"posts","summary":"LC 180 Consecutive Numbers Write a SQL query to find all numbers that appear at least three times consecutively. Solution 2020-09-24 Notes: self join 的写法 SELECT DISTINCT a.num AS ConsecutiveNums FROM logs a JOIN logs b ON a.id+1 = b.id AND a.num=b.num JOIN logs c ON a.id+2 = c.id AND a.num=c.num LEAD() function 的写法： SELECT DISTINCT num AS consecutiveNums FROM ( SELECT id, num, LEAD(num,1)","tags":["leetcode"],"title":"180 Consecutive Numbers","uri":"https://foxisawesome.github.io/posts/180-consecutive-numbers/","year":"2020"},{"content":"LC 177 Nth Highest Salary   Write a SQL query to get the nth highest salary from the Employee table.\n Solution 2020-09-24 Notes:\n 这个sql function 的写法得背下来。不过也没什么难的。  CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE m int; SET m = n-1; RETURN ( SELECT salary FROM employee GROUP BY 1 ORDER by 1 LIMIT m, 1 ); END  ","id":188,"section":"posts","summary":"LC 177 Nth Highest Salary Write a SQL query to get the nth highest salary from the Employee table. Solution 2020-09-24 Notes: 这个sql function 的写法得背下来。不过也没什么难的。 CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN DECLARE m int; SET m = n-1; RETURN ( SELECT salary FROM employee GROUP BY 1 ORDER by","tags":["leetcode"],"title":"177 Nth Highest Salary","uri":"https://foxisawesome.github.io/posts/177-nth-highest-salary/","year":"2020"},{"content":"LC 875 Koko Eating Bananas   Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won\u0026rsquo;t eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\nInput: piles = [3,6,7,11], H = 8 Output: 4   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283. 这类复杂的二分法其实与二分法查找sorted array是一样的， 这类题目中，helper(mid) function is monotnoic wrt mid.  class Solution: def minEatingSpeed(self, piles: List[int], H: int) -\u0026gt; int: l, r = 1, max(piles) while l \u0026lt;= r: m = l + (r-l)//2 if self.speedBalancer(piles, m) \u0026gt; H: l = m + 1 elif self.speedBalancer(piles, m) \u0026lt;= H: r = m - 1 return l def speedBalancer(self, piles, target): h = 0 for i in piles: h += i // target if i % target != 0: h += 1 return h # Time O(Nlog max_pile) # Space O(1)  ","id":189,"section":"posts","summary":"LC 875 Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them","tags":["leetcode","binary_search"],"title":"875 Koko Eating Bananas","uri":"https://foxisawesome.github.io/posts/875-koko-eating-bananas/","year":"2020"},{"content":"LC 774 Minimize Max Distance to Gas Station   On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length.\nNow, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D.\nInput: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283. 这题binary search 写法有点怪的原因是，因为要寻找一个continuous number。l+1e06 \u0026lt; r是为了快速收敛。寻找的是max D，所以是 right bound。  class Solution: def minmaxGasDist(self, stations: List[int], K: int) -\u0026gt; float: n = len(stations) dis = [0]*(n-1) for i in range(1,n): dis[i-1] = stations[i]-stations[i-1] l, r = 1e-6, max(dis) while l+1e-6 \u0026lt; r: m = l + (r-l)/2 c = 0 for i in range(n-1): c += (dis[i])//m if c \u0026gt; K: l = m elif c \u0026lt;= K: r = m return r # Time O(Nlog(max_dis)) # Space O(1)  ","id":190,"section":"posts","summary":"LC 774 Minimize Max Distance to Gas Station On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D. Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000","tags":["leetcode","binary_search"],"title":"774 Minimize Max Distance to Gas Station","uri":"https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/","year":"2020"},{"content":"LC 410 Split Array Largest Sum   Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\nWrite an algorithm to minimize the largest sum among these m subarrays.\nInput: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def splitArray(self, nums: List[int], m: int) -\u0026gt; int: l, r = max(nums), sum(nums) ans = r while l \u0026lt;= r: mid = l + (r-l)//2 if self.divide(nums, mid) \u0026lt;= m: ans = min(ans, mid) r = mid - 1 elif self.divide(nums, mid) \u0026gt; m: l = mid + 1 return ans def divide(self, nums, target): count, sum_ = 1, 0 for i in nums: if sum_+i \u0026gt; target: count += 1 sum_ = 0 sum_ += i return count # Time O(Nlog(sum of array)) # Space O(N)  ","id":191,"section":"posts","summary":"LC 410 Split Array Largest Sum Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5]","tags":["leetcode","binary_search"],"title":"410 Split Array Largest Sum","uri":"https://foxisawesome.github.io/posts/410-split-array-largest-sum/","year":"2020"},{"content":"LC 1011 Capacity to Ship Packages Within D Days   conveyor belt has packages that must be shipped from one port to another within D days.\nThe i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def shipWithinDays(self, weights: List[int], D: int) -\u0026gt; int: l, r = max(weights), sum(weights) while l \u0026lt;= r: m = l + (r-l)//2 if self.loadBalancer(weights, m) \u0026gt; D: l = m + 1 elif self.loadBalancer(weights, m) \u0026lt;= D: r = m - 1 return l def loadBalancer(self, weights, target): c, sum_ = 1, 0 for i in weights: if sum_+i \u0026gt; target: c += 1 sum_ = 0 sum_ += i return c # Time O() # Space O()  ","id":192,"section":"posts","summary":"LC 1011 Capacity to Ship Packages Within D Days conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return","tags":["leetcode","binary_search"],"title":"1011 Capacity to Ship Packages Within D Days","uri":"https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/","year":"2020"},{"content":"LC 21 Merge Two Sorted Lists   Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.\nInput: 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4   Solution 2020-09-24 Notes:  不要create 新的 ListNode along the way, making algo much faster.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: if not l1: return l2 if not l2: return l1 head = p = ListNode(0) while l1 and l2: if l1.val \u0026lt;= l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next l = l1 if l1 else l2 p.next = l return head.next # Time O(M+N) # Space O(1)  ","id":193,"section":"posts","summary":"LC 21 Merge Two Sorted Lists Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Input: 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 Solution 2020-09-24 Notes: 不要create 新的 ListNode along the way, making algo much faster. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"21 Merge Two Sorted Lists","uri":"https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/","year":"2020"},{"content":"LC 14 Longest Common Prefix   Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026quot;\u0026quot;.\nInput: [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot;   Solution 2020-09-24 Notes:  第三刷了，当年做的很痛苦的一道题。其实很简单。  class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026quot;\u0026quot; strs.sort() for i in range(len(strs[0])): for j in strs[1:]: if strs[0][i] != j[i]: return strs[0][:i] return strs[0] # Time O(S*N), S: len of min word # Space O(1)  ","id":194,"section":"posts","summary":"LC 14 Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \u0026quot;\u0026quot;. Input: [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot; Solution 2020-09-24 Notes: 第三刷了，当年做的很痛苦的一道题。其实很简单。 class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if","tags":["leetcode","string"],"title":"14 Longest Common Prefix","uri":"https://foxisawesome.github.io/posts/14-longest-common-prefix/","year":"2020"},{"content":"LC 38 Count and Say   The count-and-say sequence is the sequence of integers with the first five terms as following:\n1. 1 2. 11 3. 21 4. 1211 5. 111221   Solution 2020-09-24 Notes:  algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有点复杂。。。  class Solution: def countAndSay(self, n: int) -\u0026gt; str: ans = '1' if n == 1: return ans for _ in range(2,n+1): c, indata = 1, ans n = len(indata) stack, p = [indata[0]], 0 ans = '' while p \u0026lt; n-1: if indata[p] == indata[p+1]: c += 1 else: ans += str(c) + stack.pop() c= 1 stack.append(indata[p+1]) p += 1 ans += str(c) + stack.pop() return ans # Time O() # Space O(1)  ","id":195,"section":"posts","summary":"LC 38 Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 Solution 2020-09-24 Notes: algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有","tags":["leetcode","string"],"title":"38 Count and Say","uri":"https://foxisawesome.github.io/posts/38-count-and-say/","year":"2020"},{"content":"LC 1070 Product Sales Analysis III   Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold.\n Solution 2020-09-23 Notes:\n 这题的test case 1有问题，论坛里有类似讨论。  SELECT product_id, year AS first_year, quantity, price FROM ( SELECT product_id, year, quantity, price, ROW_NUMBER() OVER(PARTITION BY product_id ORDER BY year) AS nr FROM sales ) a WHERE nr = 1 ORDER BY 1  this works fine\nSELECT product_id, year AS first_year, quantity, price FROM sales WHERE (product_id, year) IN (SELECT product_id, MIN(year) AS year FROM sales GROUP BY product_id)  ","id":196,"section":"posts","summary":"LC 1070 Product Sales Analysis III Write an SQL query that selects the product id, year, quantity, and price for the first year of every product sold. Solution 2020-09-23 Notes: 这题的test case 1有问题，论坛里有类似讨论。 SELECT product_id, year AS first_year, quantity, price FROM ( SELECT product_id, year, quantity, price, ROW_NUMBER() OVER(PARTITION BY product_id","tags":["leetcode"],"title":"1070 Product Sales Analysis III","uri":"https://foxisawesome.github.io/posts/1070-product-sales-analysis-iii/","year":"2020"},{"content":"LC 1231 Divide Chocolate   You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.\nYou want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks.\nBeing generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.\nFind the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5 Output: 6 Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]   Solution 2020-09-23 Notes:  题意就是 find max of minium sub-array sum。那么binary search的就是right bound of min sum. 在code中就是那个target variable。 cut时，要是给定target 只要sub-array的sum LE target就会来一刀。最后返回与given的K+1比较。 同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def maximizeSweetness(self, sweetness: List[int], K: int) -\u0026gt; int: l, r = min(sweetness), sum(sweetness)//(K+1) while l \u0026lt;= r: target = l + (r-l)//2 if self.cutChocolate(target, sweetness) \u0026lt; K+1: r = target - 1 elif self.cutChocolate(target, sweetness) \u0026gt;= K+1: l = target + 1 return r def cutChocolate(self, target, sweetness): cut, sum_ = 0, 0 for i in sweetness: sum_ += i if sum_ \u0026gt;= target: cut += 1 sum_ = 0 return cut # Time O(logN) # Space O(1)  ","id":197,"section":"posts","summary":"LC 1231 Divide Chocolate You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness. You want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks. Being generous, you will eat the piece with the minimum total sweetness and give the","tags":["leetcode","binary_search"],"title":"1231 Divide Chocolate","uri":"https://foxisawesome.github.io/posts/1231-divide-chocolate/","year":"2020"},{"content":"LC 27 Remove Element   Given an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\n Solution 2020-10-08 Notes:  三刷，用 slow, fast pointers 来做代码短一点。  class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: if not nums: return 0 n = len(nums) fast, slow = n-1, n-1 for i in range(n-1,-1,-1): if nums[fast] == val: nums[slow], nums[fast] = nums[fast], nums[slow] slow -= 1 fast -= 1 return slow+1 # Time O(N) # Space O(1)  2020-09-23 Notes:  开始做时，想着一部先让r找到非value的数(while)，但是这样有些corner cases不能过。还是用这个比较好。  class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: if not nums: return 0 l, r = 0, len(nums)-1 while l \u0026lt;= r: if nums[l] == val and nums[r] == val: r -= 1 elif nums[l] == val and nums[r] != val: nums[l], nums[r] = nums[r], nums[l] l += 1 r -= 1 elif nums[l] != val and nums[r] == val: l += 1 r -= 1 else: l += 1 return l # Time O(N) # Space O(1)  ","id":198,"section":"posts","summary":"LC 27 Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length. Solution 2020-10-08 Notes: 三刷，用","tags":["leetcode","two_pointers"],"title":"27 Remove Element","uri":"https://foxisawesome.github.io/posts/27-remove-element/","year":"2020"},{"content":"LC 28 Implement Strstr   Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nInput: haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot; Output: 2   Solution 2020-09-23 Notes:  官方解答里有中 $\\mathcal{O}(N)$ 的解哦！  class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen] == needle: return i return -1 # Time O((N-L)*L), where N is a length of haystack and L is a length of needle. We compute a substring of length L in a loop, which is executed (N - L) times. # Space O(1)  ","id":199,"section":"posts","summary":"LC 28 Implement Strstr Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Input: haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot; Output: 2 Solution 2020-09-23 Notes: 官方解答里有中 $\\mathcal{O}(N)$ 的解哦！ class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen]","tags":["leetcode","string"],"title":"28 Implement Strstr","uri":"https://foxisawesome.github.io/posts/28-implement-strstr/","year":"2020"},{"content":"LC 349 Intersection of Two Arrays   Given two arrays, write a function to compute their intersection.\n Each element in the result must be unique. The result can be in any order.   Solution 2020-09-23 Notes:  很多做法，set本身有intersection()的method。  class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] s1 = set(nums1) s2 = set(nums2) return s1.intersection(s2) # Time O(n1 + n2) # Space O(n1 + n2)  ","id":200,"section":"posts","summary":"LC 349 Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Each element in the result must be unique. The result can be in any order. Solution 2020-09-23 Notes: 很多做法，set本身有intersection()的method。 class Solution: def","tags":["leetcode","hashtable"],"title":"349 Intersection of Two Arrays","uri":"https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/","year":"2020"},{"content":"LC 350 Intersection of Two Arrays II   Given two arrays, write a function to compute their intersection.\nInput: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Solution 2020-09-23 Notes:  简单题两种高效做法。   hashtable  class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1) ans = [] c1 = collections.Counter(nums1) c2 = collections.Counter(nums2) for k, val in c1.items(): if k in c2: ans += [k] * min(val, c2[k]) return ans # Time O(N) # Space O(N)  Sorted + two pointers  class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1) ans = [] nums1.sort() nums2.sort() p1, p2 = 0, 0 while p1 \u0026lt; n1 and p2 \u0026lt; n2: if nums1[p1] == nums2[p2]: ans.append(nums1[p1]) p1 += 1 p2 += 1 elif nums1[p1] \u0026gt; nums2[p2]: p2 += 1 elif nums1[p1] \u0026lt; nums2[p2]: p1 += 1 return ans # Time O(NlogN) # Space O(NlogN)  ","id":201,"section":"posts","summary":"LC 350 Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Solution 2020-09-23 Notes: 简单题两种高效做法。 hashtable class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1)","tags":["leetcode","hashtable","two_pointers"],"title":"350 Intersection of Two Arrays II","uri":"https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/","year":"2020"},{"content":"LC 202 Happy Number   Write an algorithm to determine if a number n is \u0026ldquo;happy\u0026rdquo;.\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\nReturn True if n is a happy number, and False if not.\nInput: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1   Solution 2020-09-23 Notes:  第二刷了，一次就过了。 不过time/space complexity 有点复杂。。。  class Solution: def isHappy(self, n: int) -\u0026gt; bool: d = set() ans = n while True: n = ans ans = 0 while n \u0026gt; 0: n, r = divmod(n,10) ans += r**2 if ans not in d: d.add(ans) else: break return ans == 1 # Time O() # Space O()  ","id":202,"section":"posts","summary":"LC 202 Happy Number Write an algorithm to determine if a number n is \u0026ldquo;happy\u0026rdquo;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers","tags":["leetcode",""],"title":"202 Happy Number","uri":"https://foxisawesome.github.io/posts/202-happy-number/","year":"2020"},{"content":"LC 278 First Bad Version   You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n Solution 2020-09-23 Notes:  要找的是lower bound of those True cases.  class Solution: def firstBadVersion(self, n): l, r = 1, n while l \u0026lt;= r: m = l + (r-l)//2 if isBadVersion(m) == False: l = m+1 elif isBadVersion(m) == True: r = m-1 return l # Time O(logN) # Space O(1)  ","id":203,"section":"posts","summary":"LC 278 First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,","tags":["leetcode","binary_search"],"title":"278 First Bad Version","uri":"https://foxisawesome.github.io/posts/278-first-bad-version/","year":"2020"},{"content":"LC 35 Search Insert Position   Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n Solution 2020-09-23 Notes:  标准的left bound 的binary search 写法。 初秋的夜晚很舒服。  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r-l)//2 if nums[m] \u0026lt; target: l = m+1 elif nums[m] \u0026gt;= target: r = m-1 return l # Time O(logN) # Space O(1)  ","id":204,"section":"posts","summary":"LC 35 Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Solution 2020-09-23 Notes: 标准的left bound 的binary search 写法。 初秋的夜晚很舒服。 class Solution: def","tags":["leetcode","binary_search"],"title":"35 Search Insert Position","uri":"https://foxisawesome.github.io/posts/35-search-insert-position/","year":"2020"},{"content":"LC 134 Gas Station   There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station\u0026rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n Solution 2020-09-23 Notes:  一道有趣的巧题。 暴力的想法就是在每个gas station都按照题目描述的check一遍，这样需要$\\mathcal{O}(N^2)$的time 但是答案巧就巧在check了这些condition后能one pass。存两个变量：total_tank 和 curr_tank。然后每站check curr_tank ? 0。  class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u0026gt; int: n = len(gas) total_tank, curr_tank = 0, 0 ans = 0 for i in range(n): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] if curr_tank \u0026lt; 0: ans = i + 1 curr_tank = 0 ans = -1 if total_tank \u0026lt; 0 else ans return ans # Time O(N) # Space O(1)  ","id":205,"section":"posts","summary":"LC 134 Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station\u0026rsquo;s index if you","tags":["leetcode"],"title":"134 Gas Station","uri":"https://foxisawesome.github.io/posts/134-gas-station/","year":"2020"},{"content":"LC 103 Binary Tree Zigzag Level Order Traversal   Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return its zigzag level order traversal as:\n[ [3], [20,9], [15,7] ]   Solution 2020-09-23 Notes:  一个简单的post_order print，store在dict里 感觉对dictionary的API还有loop，sort的操作还得多练练。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def zigzagLevelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] d = collections.defaultdict(list) h = 0 self.post_order(root, h, d) ans = [] H = max([i for i,val in d.items()]) for i in range(H): if i%2 == 0: ans.append(d[i+1]) else: ans.append(d[i+1][::-1]) return ans def post_order(self, root, h, d): if not root: return h += 1 l = self.post_order(root.left, h, d) r = self.post_order(root.right, h, d) d[h].append(root.val) return # Time O(N) # Space O(H)  ","id":206,"section":"posts","summary":"LC 103 Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution 2020-09-23 Notes: 一个","tags":["leetcode","tree"],"title":"103 Binary Tree Zigzag Level Order Traversal","uri":"https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/","year":"2020"},{"content":"LC 1283 Find the Smallest Divisor Given a Threshold   a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nInput: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).   Solution 2020-09-23 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283. 题目有点难懂，题意是找最小的divisor，使得sum( ceiling(division) ) LE threshold。 用binary search，因为求min 所以是left bound。 取ceiling的方式：(i-1)//m +1  class Solution: def smallestDivisor(self, nums: List[int], threshold: int) -\u0026gt; int: l, r = 1, max(nums) while l \u0026lt;= r: m = l + (r-l)//2 sum_ = sum([(i+m-1)//m for i in nums ]) if sum_ \u0026gt; threshold: l = m + 1 else: r = m - 1 return l # Time O(NlogM): M=max(nums) # Space O(1)  ","id":207,"section":"posts","summary":"LC 1283 Find the Smallest Divisor Given a Threshold a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor","tags":["leetcode","binary_search"],"title":"1283 Find the Smallest Divisor Given a Threshold","uri":"https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/","year":"2020"},{"content":"LC 179 Largest Number   Given a list of non negative integers, arrange them such that they form the largest number.\nInput: [3,30,34,5,9] Output: \u0026quot;9534330\u0026quot;   Solution 2020-09-23 Notes:  开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 \u0026amp; 54, 下一位要与较短书的前一位比较。 看了答案就太简单啦。但是有几个API不知道。看了python doc: The sort routines are guaranteed to use __lt__() (lt: less than) when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an __lt__() method: refrence 其次是map(), 不知道efficiency和 loop through怎么样。 Python 3 中，sort() removed, cmp argument.  class LargerNumKey(str): def __lt__(x, y): return x+y \u0026gt; y+x class Solution: def largestNumber(self, nums): largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey)) return '0' if largest_num[0] == '0' else largest_num # Time O(N) # Space O(1)  ","id":208,"section":"posts","summary":"LC 179 Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Input: [3,30,34,5,9] Output: \u0026quot;9534330\u0026quot; Solution 2020-09-23 Notes: 开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 \u0026amp; 54, 下一","tags":["leetcode","string"],"title":"179 Largest Number","uri":"https://foxisawesome.github.io/posts/179-largest-number/","year":"2020"},{"content":"LC 518 Coin Change 2   You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nInput: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1   Solution 2020-09-23 Notes:  这题给我的第一感觉和爬楼梯是一个意思。dp[i] = \\sum dp[i-coin] 有个细节就是每个path一定要仅使用coins[0:j]，否则就会出现重复的combo。这和给定一组数求所有的subsets类似。 比如 i=3, [1,2] 和 [2,1]就是一种方法。为了避免重复，算法就必须第一次仅使用 coin =1，第二次使用 coin =1 and coin=2。 秋意浓了，2020还剩99天。加油刷！  class Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for i in range(1, amount+1): if coin \u0026lt;= i: dp[i] += dp[i-coin] return dp[amount] # Time O(NC) # Space O(N)  ","id":209,"section":"posts","summary":"LC 518 Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1","tags":["leetcode","dp"],"title":"518 Coin Change 2","uri":"https://foxisawesome.github.io/posts/518-coin-change-2/","year":"2020"},{"content":"LC 64 Minimum Path Sum   Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nInput:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Solution 2020-09-23 Notes:   做这题时发现了好几个python 2d-array和我原先以为不一样的点：\n 不能用 a[:] 或者 a[:][:] 来deep copy 2d array。目前发现只能用copy module a[:][0] 不是选中 0th column。而是a[:]选中all sub list，然后其中的第一个。所以和 np.array 很不一样。    dp[i][j] := the minimun distance from grid[i][j] to grid[-1][-1]\n  dp 从 bottom rightmost开始，向上向左走，last column 和 last row要单独处理下。transition equation：dp[i][j] = grid[i][j] + min(dp[i][j+1], dp[i+1][j])。\n  可以继续压缩空间。\n  class Solution: def minPathSum(self, grid: List[List[int]]) -\u0026gt; int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 nr, nc = len(grid), len(grid[0]) dp = copy.deepcopy(grid) for i in range(nr-1,-1,-1): for j in range(nc-1, -1, -1): if j == nc-1 and i != nr-1: # deal with last col dp[i][j] = grid[i][j] + dp[i+1][j] elif i == nr-1 and j != nc-1: # deal with last row dp[i][j] = grid[i][j] + dp[i][j+1] elif i != nr -1 and j != nc -1: dp[i][j] = grid[i][j] + min(dp[i][j+1], dp[i+1][j]) return dp[0][0] # Time O(NM) # Space O(NM)  ","id":210,"section":"posts","summary":"LC 64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Input:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution 2020-09-23 Notes: 做这题时发现了好几个pyth","tags":["leetcode","dp"],"title":"64 Minimum Path Sum","uri":"https://foxisawesome.github.io/posts/64-minimum-path-sum/","year":"2020"},{"content":"LC 802 Find Eventual Safe States   In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\nNow, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\nWhich nodes are eventually safe? Return them as an array in sorted order.\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.   Solution 2020-09-22 Notes:  意思就是在有向图里找出不在cycle里的节点。写法和LC 207，LC 210完全一致。  class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -\u0026gt; List[int]: n = len(graph) ans = [] visited = [0]*n for i in range(n): if self.dfs(graph, ans, visited, i): ans.append(i) return ans def dfs(self, graph, ans, visited, i): # visited: 0: unvisited, 1: visiting, 2: visited if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, ans, visited, j): return False visited[i] = 2 return True # Time O(N^2) # Space O(N)  ","id":211,"section":"posts","summary":"LC 802 Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural","tags":["leetcode","GRAPH","DFS"],"title":"802 Find Eventual Safe States","uri":"https://foxisawesome.github.io/posts/802-find-eventual-safe-states/","year":"2020"},{"content":"LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.\n Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -\u0026gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  ","id":212,"section":"posts","summary":"LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.\n Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -\u0026gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"1118 Number of Days in a Month","uri":"https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/","year":"2020"},{"content":"LC 210 Course Schedule II   There are a total of n courses you have to take labelled from 0 to n - 1.\nSome courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai.\nGiven the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to finish all courses.\n Solution 2020-09-22 Notes:  首先build graph时，是有指向性的，所以一定是graph[pre].append(cur)这么写的。 其实最先出栈的节点是最深的，所以应该输出ans[::-1]。 最后 time/space complexity应该是$\\mathcal{O}(V+E) \\sim \\mathcal{O}(N^2)$. V: vertex, E:edge. topoligical sorting algo. same questions as LC 207.  class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; List[int]: n = numCourses graph = collections.defaultdict(list) visited = [0] * n ans = [] for cur, pre in prerequisites: graph[pre].append(cur) for i in range(n): if not self.dfs(graph, i, visited,ans): return [] return ans[::-1] def dfs(self, graph, i, visited, ans): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, j, visited, ans): return False visited[i] = 2 ans.append(i) return True # Time O(N^2) # Space O(N)  BFS 的做法：\n top sort 一般都用DFS，BFS just for completeness. 把入度为0的节点放入queue中， 每次访问他的邻节点，将邻节点的入度\u0026ndash;, 直至全部走完。  class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; List[int]: n = numCourses graph = collections.defaultdict(list) indegrees = [0] * n queue = [] ans = [] for cur, pre in prerequisites: indegrees[cur] += 1 graph[pre].append(cur) for i in range(n): if indegrees[i] == 0: queue.append(i) ans.append(i) while queue: pre = queue.pop(0) # n -= 1 for j in graph[pre]: indegrees[j] -= 1 if indegrees[j] == 0: queue.append(j) ans.append(j) return ans if len(ans) == n else [] # Time O(N^2) # Space O(N)  ","id":213,"section":"posts","summary":"LC 210 Course Schedule II There are a total of n courses you have to take labelled from 0 to n - 1. Some courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai. Given the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to","tags":["leetcode","Graph","DFS","BFS"],"title":"210 Course Schedule II","uri":"https://foxisawesome.github.io/posts/210-course-schedule-ii/","year":"2020"},{"content":"LC 207 Course Schedule   There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nInput: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.    Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. ```\nSolution 2020-09-21 Notes:   第一天刷Graph的题。看了 花花酱 和 负雪明烛 的答案和解释。准备这一周好好看看 Tim Roughgarden 的lecture。\n  和 LC210 是完全一样的题。\n  这题只有有向图里有cycle就return False。可以用topological sorting, using DFS.\n  拓扑排序，DFS\n同样是拓扑排序，但是换了个做法，使用DFS。这个方法是，我们每次找到一个新的点，判断从这个点出发是否有环。具体做法是使用一个visited数组，当visited[i]值为0，说明还没判断这个点；当visited[i]值为1，说明当前的循环正在判断这个点；当visited[i]值为2，说明已经判断过这个点，含义是从这个点往后的所有路径都没有环，认为这个点是安全的。\n那么，我们对每个点出发都做这个判断，检查这个点出发的所有路径上是否有环，如果判断过程中找到了当前的正在判断的路径，说明有环；找到了已经判断正常的点，说明往后都不可能存在环，所以认为当前的节点也是安全的。如果当前点是未知状态，那么先把当前点标记成正在访问状态，然后找后续的节点，直到找到安全的节点为止。最后如果到达了无路可走的状态，说明当前节点是安全的。\ndfs函数中的for循环是怎么回事呢？这个和BFS循环次数不是同一个概念，这里的循环就是看从第i个节点开始能否到达合理结果。这个节点可能没有出度了，那就把它直接放到path里；也可能有出度，那么就把它后面的节点都进行一次遍历，如果满足条件的节点都放到path里，同时把这次遍历的所有节点都标记成了已经遍历；如果一个节点已经被安全的访问过，那么就放过它，继续遍历下个节点。\n最后 time/space complexity应该是$\\mathcal{O}(V+E) \\sim \\mathcal{O}(N^2)$. V: vertex, E:edge.\n  class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; bool: n = numCourses graph = collections.defaultdict(list) for cur, pre in prerequisites: graph[pre].append(cur) # 0: unknown, 1: visiting, 2: visited visited = [0]*n for i in range(n): if not self.dfs(graph, visited, i): return False return True def dfs(self, graph, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, visited, j): return False visited[i] = 2 return True # Time O(N^2) # Space O(N^2)  ","id":214,"section":"posts","summary":"LC 207 Course Schedule There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Input: numCourses = 2,","tags":["leetcode","Graph","DFS"],"title":"207 Course Schedule","uri":"https://foxisawesome.github.io/posts/207-course-schedule/","year":"2020"},{"content":"LC 542 01 Matrix   Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\nInput: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]]   Solution 2020-09-21 Notes:  很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水立马跳出BFS。没找到水就继续下一层BFS。 第二遍刷出来的解更快。  class Solution: def updateMatrix(self, matrix: List[List[int]]) -\u0026gt; List[List[int]]: nrow, ncol = len(matrix), len(matrix[0]) out = [ [0]*ncol for _ in range(nrow) ] directions = [[-1,0], [1,0], [0,1], [0,-1]] for i in range(nrow): for j in range(ncol): if matrix[i][j] == 1: self.bfs(matrix, nrow, ncol, directions, (i,j), out) return out def bfs(self, matrix, nrow, ncol, directions, point, out): visited = set() queue = [] queue.append(point) visited.add(point) count = 0 while queue: l = len(queue) count += 1 for x in range(l): p = queue.pop(0) for d in directions: r, c = p[0]+d[0], p[1]+d[1] new_p = (r,c) if 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and matrix[r][c]==0: out[point[0]][point[1]] = count return elif 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and matrix[r][c]==1 and new_p not in visited: queue.append(new_p) visited.add(new_p) return # Time O(r*c) # Space O(r*c)  2020-8-13 Notes:  默写了一遍模版基本做出来了。  class Solution: def updateMatrix(self, matrix: List[List[int]]) -\u0026gt; List[List[int]]: nrow, ncol = len(matrix), len(matrix[0]) out = [ [0]*ncol for _ in range(nrow) ] direction = [[-1,0], [1,0], [0,1], [0,-1]] for i in range(nrow): for j in range(ncol): if matrix[i][j] == 1: out[i][j] = self.BFS(i,j,matrix,direction,nrow, ncol, out) return out def BFS(self, r, c, matrix, direction, nrow, ncol, out): queue = [] queue.append([r,c,0]) visited = set() while queue: x0, y0, step = queue.pop(0) if matrix[x0][y0]==0: return step step += 1 visited.add((x0,y0)) for d in direction: x1, y1 = x0 + d[0], y0 + d[1] if 0\u0026lt;= x1 \u0026lt;nrow and 0\u0026lt;= y1 \u0026lt;ncol and (x1,y1) not in visited: queue.append([x1,y1,step]) visited.add((x1,y1)) return step # Time O(r*c) # Space O(r*c)  ","id":215,"section":"posts","summary":"LC 542 01 Matrix Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. Input: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]] Solution 2020-09-21 Notes: 很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水","tags":["leetcode","BFS"],"title":"542 01 Matrix","uri":"https://foxisawesome.github.io/posts/542-01-matrix/","year":"2020"},{"content":"LC 200 Number of Islands   Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nInput: grid = [ [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;] ] Output: 3   Solution 2020-09-21 Notes:  很经典的BFS 或者 DFS的题。这次已经是第三刷了，终于很完整的刷出来了。 刷到今天感觉 BFS一定是用queue的写法，能保证最短路径但此题无关最短。所以用DFS也可以做。 DFS可以用stack 类似BFS的写法，但貌似大家默认更常规的写法是用backtracking的写法。  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid)==0 or len(grid[0])==0: return 0 nrow, ncol = len(grid), len(grid[0]) directions = [[-1,0], [1,0], [0,1], [0,-1]] count = 0 for i in range(nrow): for j in range(ncol): if grid[i][j] == '1': point = (i,j) grid[i][j] = '0' self.bfs(grid, nrow, ncol, directions, point) count += 1 return count def bfs(self, grid, nrow, ncol, directions, point): queue = [] queue.append(point) while queue: p = queue.pop(0) x, y = p[0], p[1] for d in directions: r, c = x+d[0], y+d[1] if 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and grid[r][c]=='1': queue.append((r,c)) grid[r][c] = '0' return # Time O(N) # Space O(N)  ","id":216,"section":"posts","summary":"LC 200 Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Input: grid = [ [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;] ] Output: 3 Solution 2020-09-21 Notes: 很经典的B","tags":["leetcode","BFS","DFS"],"title":"200 Number of Islands","uri":"https://foxisawesome.github.io/posts/200-number-of-islands/","year":"2020"},{"content":"LC 133 Clone Graph   Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\n Solution 2020-09-21 Notes:  刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只需要保存是否遍历过这个节点即可，但是由于这个题需要把neighboors对应复制过来。那么需要进行改进，改进的方式是把set改成dict，保存每个老节点对应的新节点是多少。在Python中，字典直接保存对象（指针）之间的映射。所以，我们直接把遍历过的对象和复制出来的对象一一对应即可。当我们遍历到一个新的节点的时候，需要判断这个节点是否在字典中出现过，如果出现过就把它对应的复制出来的对象放到其neighboors里，若没有出现过，那么就重新构造该节点，并把原节点和该节点放到字典中保存。  \u0026quot;\u0026quot;\u0026quot; # Definition for a Node. class Node: def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] \u0026quot;\u0026quot;\u0026quot; class Solution: def cloneGraph(self, node: 'Node') -\u0026gt; 'Node': if not node: return node_copy = self.bfs(node, dict()) return node_copy def dfs(self, node, visited): if not node: return None if node in visited: return visited[node] node_copy = Node(node.val,[]) visited[node] = node_copy for n in node.neighbors: ngb = self.dfs(n,visited) if ngb: node_copy.neighbors.append(ngb) return node_copy # Time O(N) # Space O(N)  BFS solution:\nclass Solution: def cloneGraph(self, node: 'Node') -\u0026gt; 'Node': if not node: return visited = dict() queue = [node] visited[node] = Node(node.val, []) while queue: n = queue.pop(0) for neighbor in n.neighbors: if neighbor not in visited: visited[neighbor] = Node(neighbor.val, []) queue.append(neighbor) visited[n].neighbors.append(visited[neighbor]) return visited[node] # Time O(N) # Space O(N)  ","id":217,"section":"posts","summary":"LC 133 Clone Graph Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Solution 2020-09-21 Notes: 刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只","tags":["leetcode","GRAPH","DFS"],"title":"133 Clone Graph","uri":"https://foxisawesome.github.io/posts/133-clone-graph/","year":"2020"},{"content":"LC 1323 Maximum 69 Number   Given a positive integer num consisting only of digits 6 and 9.\nReturn the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n Solution 2020-09-21 Notes:  开始时我想着转成str()后，用binary search出最左边的6，这样不对，因为not sorted。 String.replace(old, new, counts): replace once from left to right.  class Solution: def maximum69Number (self, num: int) -\u0026gt; int: return int(str(num).replace('6','9',1)) # Time O(N) # Space O(1)  ","id":218,"section":"posts","summary":"LC 1323 Maximum 69 Number Given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). Solution 2020-09-21 Notes: 开始时我想着转成str()后，用binary search出最","tags":["leetcode","string"],"title":"1323 Maximum 69 Number","uri":"https://foxisawesome.github.io/posts/1323-maximum-69-number/","year":"2020"},{"content":"LC 47 Permutations II   Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n Solution 2020-09-21 Notes:  LC 46 的升级版。这题添加了nums里有duplicates的case。 为了保证输出时 distinct out 的条件，可以用 sort() + if i == n-1 or nums[i]!=nums[i+1]: Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums[i+1:]以避免dups。  class Solution: def permuteUnique(self, nums: List[int]) -\u0026gt; List[List[int]]: out = [] if nums: nums.sort() n = len(nums) self.dfs(nums,n,[],out) return out def dfs(self, nums, n, path, out): if len(path) == n: out.append(path[:]) return l = len(nums) for i in range(l): if i == l-1 or nums[i]!=nums[i+1]: path.append(nums[i]) self.dfs(nums[:i]+nums[i+1:], n, path, out) path.pop() # Time O() # Space O()  ","id":219,"section":"posts","summary":"LC 47 Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Solution 2020-09-21 Notes: LC 46 的升级版。这题添加了nums里有duplicates的case。 为了保证输出时 distinct out 的条件，可以","tags":["leetcode","dfs"],"title":"47 Permutations II","uri":"https://foxisawesome.github.io/posts/47-permutations-ii/","year":"2020"},{"content":"LC 78 Subsets   Given a set of distinct integers, nums, return all possible subsets (the power set).\nInput: nums = [1,2,3] Output:[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]   Solution 2020-09-21 Notes:  简单的dfs题，有个新奇的点就是在dfs外面有个控制length的loop。刚开始我以为要放入dfs()，试了两层loop，或者又两个变量控制长度和nums输入，都没成. 这说明 DFS的模版应该是不变的。以后遇到，不用怀疑模版，往DFS以外想想就好了。  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: out = [] if nums: n = len(nums) for i in range(n+1): self.dfs(nums,out,[],i) return out def dfs(self, nums, out, path, n): if len(path) == n: out.append(path[:]) return for i in range(len(nums)): path.append(nums[i]) self.dfs(nums[i+1:],out,path,n) path.pop() # Time O() # Space O()  ","id":220,"section":"posts","summary":"LC 78 Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Input: nums = [1,2,3] Output:[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]] Solution 2020-09-21 Notes: 简单的dfs题，有个新奇的点就是在dfs外面有个控制length的loop。刚开始我以为要","tags":["leetcode","DFS"],"title":"78 Subsets","uri":"https://foxisawesome.github.io/posts/78-subsets/","year":"2020"},{"content":"LC 77 Combinations   Given two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n.\n Solution 2020-09-21 Notes:  Dfs 模版搞一下。没啥特别的。  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: out = [] nums = [i for i in range(1,n+1)] self.dfs(n,k,nums,[],out) return out def dfs(self, n, k, nums, path, out): if len(path)==k: out.append(path[:]) return for i in range(len(nums)): path.append(nums[i]) self.dfs(n,k,nums[i+1:],path,out) path.pop() # Time O() # Space O()  ","id":221,"section":"posts","summary":"LC 77 Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n. Solution 2020-09-21 Notes: Dfs 模版搞一下。没啥特别的。 class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: out = [] nums = [i for i in range(1,n+1)] self.dfs(n,k,nums,[],out) return out def dfs(self, n, k, nums, path, out): if len(path)==k: out.append(path[:])","tags":["leetcode","dfs"],"title":"77 Combinations","uri":"https://foxisawesome.github.io/posts/77-combinations/","year":"2020"},{"content":"LC 40 Combination Sum Ii   Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nEach number in candidates may only be used once in the combination.\nInput: candidates = [10,1,2,7,6,1,5], target = 8,\nA solution set is:[[1, 7], [1, 2, 5], [2, 6],[1, 1, 6]]\n Solution 2020-09-21 Notes:  这题与39题的唯一区别是candidates里会有dups，这样如果直接使用LC39的code会出现results里有duplicates。解决这个问题的经典方法就是，先sort，然后用i \u0026gt; index and candidates[i] == candidates[i-1]跳过可能的重复candidates complexity analysis 参见官方解答，比较复杂。  class Solution: def combinationSum2(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: out = [] candidates.sort() self.dfs(candidates, target, [], out, 0) return out def dfs(self, candidates, target, path, out, index): n = len(candidates) if sum(path) \u0026gt; target: return if sum(path) == target: out.append(path[:]) return for i in range(index,n): if i \u0026gt; index and candidates[i] == candidates[i-1]: continue path.append(candidates[i]) self.dfs(candidates, target, path, out, i+1) path.pop() # Time O() # Space O()  ","id":222,"section":"posts","summary":"LC 40 Combination Sum Ii Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is:[[1, 7], [1, 2, 5], [2, 6],[1, 1, 6]] Solution 2020-09-21 Notes: 这题与39题","tags":["leetcode","dfs"],"title":"40 Combination Sum Ii","uri":"https://foxisawesome.github.io/posts/40-combination-sum-ii/","year":"2020"},{"content":"LC 39 Combination Sum   Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nInput: candidates = [2,3,6,7], target = 7, A solution set is: [[7],[2,2,3]]   Solution 2020-09-21 Notes:  简单的DFS题，注意：path要是list(), 就只能 append then pop 这么操作，放到dfs里时会出错。 但是计算time/Space complexity有点难。参见官方解答  class Solution: def combinationSum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: out = [] if candidates: self.dfs(out, [], 0, candidates, target) return out def dfs(self, out, path, index, candidates, target): if sum(path) \u0026gt; target: return if sum(path) == target: out.append(path[:]) return for i in range(index,len(candidates)): path.append(candidates[i]) self.dfs(out, path, i , candidates, target) path.pop() # Time O() # Space O()  ","id":223,"section":"posts","summary":"LC 39 Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Input: candidates = [2,3,6,7], target = 7, A solution set is: [[7],[2,2,3]] Solution 2020-09-21 Notes: 简单的DFS题，注意：path要是list(),","tags":["leetcode","DFS"],"title":"39 Combination Sum","uri":"https://foxisawesome.github.io/posts/39-combination-sum/","year":"2020"},{"content":"LC 17 Letter Combinations of a Phone Number   Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n Solution 2020-09-21 Notes:  很简单的一道backtracking题套模版就可以了。为了避免dups，每次传入recursion的digits要递减。 Time complexity : $\\mathcal{O}(3^N \\times 4^M)O(3^N×4^M)$ where N is the number of digits in the input that maps to 3 letters (e.g. 2, 3, 4, 5, 6, 8) and M is the number of digits in the input that maps to 4 letters (e.g. 7, 9), and N+M is the total number digits in the input. Space complexity same as time complexity.  class Solution: def letterCombinations(self, digits: str): dict = { '2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z'] } out = [] if digits: l = len(digits) self.dfs(dict, digits, out, '',l) return out def dfs(self, dict, digits, out, path,l): n = len(digits) if n == 0 and len(path)==l: out.append(path[:]) return for i in range(n): for j in dict[digits[i]]: self.dfs(dict, digits[i+1:], out, path+j,l)  ","id":224,"section":"posts","summary":"LC 17 Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Solution 2020-09-21 Notes: 很简单的一道backtracking题套模版就可以了。为了避免dups，每次传入r","tags":["leetcode","DFS"],"title":"17 Letter Combinations of a Phone Number","uri":"https://foxisawesome.github.io/posts/17-letter-combinations-of-a-phone-number/","year":"2020"},{"content":"LC 921 Minimum Add to Make Parentheses Valid   Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid.\n Solution 2020-09-20 Notes:  一遍就过的题没啥好说的。  class Solution: def minAddToMakeValid(self, S: str) -\u0026gt; int: if not S: return 0 stack = [] ans = 0 for i, val in enumerate(S): if val == '(': stack.append(i) elif val == ')' and stack: stack.pop() else: ans += 1 return ans + len(stack) # Time O() # Space O()  ","id":225,"section":"posts","summary":"LC 921 Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Solution 2020-09-20 Notes: 一遍就过的题没啥好说的。 class Solution: def minAddToMakeValid(self, S: str) -\u0026gt; int: if not S: return 0 stack","tags":["leetcode","stack"],"title":"921 Minimum Add to Make Parentheses Valid","uri":"https://foxisawesome.github.io/posts/921-minimum-add-to-make-parentheses-valid/","year":"2020"},{"content":"LC 22 Generate Parentheses   Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[ \u0026quot;((()))\u0026quot;, \u0026quot;(()())\u0026quot;, \u0026quot;(())()\u0026quot;, \u0026quot;()(())\u0026quot;, \u0026quot;()()()\u0026quot; ]   Solution 2020-09-20 Notes:  可以直接套用backtracking的模版，主要是l\u0026lt;n 以及r\u0026lt;l这两个条件并列使用。  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: ans = [] self.dfs(0,0,'',ans,n) return ans def dfs(self, l, r, path, ans, n): if len(path) == n*2: ans.append(path[:]) return if l \u0026lt; n: self.dfs(l+1,r,path+'(',ans,n) if r \u0026lt; l: self.dfs(l,r+1,path+')',ans,n) # Time O(N) # Space O(N)  ","id":226,"section":"posts","summary":"LC 22 Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \u0026quot;((()))\u0026quot;, \u0026quot;(()())\u0026quot;, \u0026quot;(())()\u0026quot;, \u0026quot;()(())\u0026quot;, \u0026quot;()()()\u0026quot; ] Solution 2020-09-20 Notes: 可以直接套用backtracking的模版，主要是l\u0026lt;n","tags":["leetcode","backtracking"],"title":"22 Generate Parentheses","uri":"https://foxisawesome.github.io/posts/22-generate-parentheses/","year":"2020"},{"content":"LC 618 Students Report by Geography   input\n| name | continent | |--------|-----------| | Jack | America | | Pascal | Europe | | Xi | Asia | | Jane | America |  output\n| America | Asia | Europe | |---------|------|--------| | Jack | Xi | Pascal | | Jane | | |   Solution 2020-09-20 Notes:\n 很经典的hard SQL，pivot table  SELECT MAX(CASE WHEN continent = 'America' THEN name ELSE NULL END) AS America, MAX(CASE WHEN continent = 'Asia' THEN name ELSE NULL END) AS Asia, MAX(CASE WHEN continent = 'Europe' THEN name ELSE NULL END) AS Europe FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY NAME) AS row_id FROM student ) a GROUP BY row_id ORDER BY row_id  ","id":227,"section":"posts","summary":"LC 618 Students Report by Geography input | name | continent | |--------|-----------| | Jack | America | | Pascal | Europe | | Xi | Asia | | Jane | America | output | America | Asia | Europe | |---------|------|--------| | Jack | Xi | Pascal | | Jane | | | Solution 2020-09-20 Notes: 很经典的hard SQL，p","tags":["leetcode","dia_sql"],"title":"618 Students Report by Geography","uri":"https://foxisawesome.github.io/posts/618-students-report-by-geography/","year":"2020"},{"content":"LC 1179 Reformat Department Table   Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month.\n Solution 2020-09-20 Notes:  这题和LC 618类似。  SELECT id, SUM(CASE WHEN month = 'Jan' THEN revenue ELSE NULL END) AS jan_revenue, SUM(CASE WHEN month = 'Feb' THEN revenue ELSE NULL END) AS feb_revenue, SUM(CASE WHEN month = 'Mar' THEN revenue ELSE NULL END) AS mar_revenue, SUM(CASE WHEN month = 'Apr' THEN revenue ELSE NULL END) AS apr_revenue, SUM(CASE WHEN month = 'May' THEN revenue ELSE NULL END) AS may_revenue, SUM(CASE WHEN month = 'Jun' THEN revenue ELSE NULL END) AS jun_revenue, SUM(CASE WHEN month = 'Jul' THEN revenue ELSE NULL END) AS jul_revenue, SUM(CASE WHEN month = 'Aug' THEN revenue ELSE NULL END) AS aug_revenue, SUM(CASE WHEN month = 'Sep' THEN revenue ELSE NULL END) AS sep_revenue, SUM(CASE WHEN month = 'Oct' THEN revenue ELSE NULL END) AS oct_revenue, SUM(CASE WHEN month = 'Nov' THEN revenue ELSE NULL END) AS nov_revenue, SUM(CASE WHEN month = 'Dec' THEN revenue ELSE NULL END) AS dec_revenue FROM department GROUP BY id ORDER BY 1 ;  ","id":228,"section":"posts","summary":"LC 1179 Reformat Department Table Write an SQL query to reformat the table such that there is a department id column and a revenue column for each month. Solution 2020-09-20 Notes: 这题和LC 618类似。 SELECT id, SUM(CASE WHEN month = 'Jan' THEN revenue ELSE NULL END) AS jan_revenue, SUM(CASE WHEN month = 'Feb' THEN revenue ELSE NULL END) AS feb_revenue, SUM(CASE WHEN","tags":["leetcode"],"title":"1179 Reformat Department Table","uri":"https://foxisawesome.github.io/posts/1179-reformat-department-table/","year":"2020"},{"content":"LC 253 Meeting Rooms II   Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required.\nInput: [[0, 30],[5, 10],[15, 20]] Output: 2   Solution 2020-09-20 Notes:  核心是用 存 ending time to a min-heap, 用starting time与heap比较。 但本题最大的困惑是：line#11，为什么用h_room.pop(0)就是不能全过。  class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -\u0026gt; int: if not intervals: return 0 h_room = [] intervals.sort(key = lambda i: i[0]) heapq.heappush(h_room, intervals[0][1]) for i in intervals[1:]: if i[0] \u0026gt;= h_room[0]: heapq.heappop(h_room) heapq.heappush(h_room, i[1]) return len(h_room) # Time O() # Space O()  ","id":229,"section":"posts","summary":"LC 253 Meeting Rooms II Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required. Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Solution 2020-09-20 Notes: 核心是用 存 ending time to a min-heap, 用starting time与heap比较","tags":["leetcode","heap"],"title":"253 Meeting Rooms II","uri":"https://foxisawesome.github.io/posts/253-meeting-rooms-ii/","year":"2020"},{"content":"LC 46 Permutations   Given a collection of distinct integers, return all possible permutations.\nInput: [1,2,3] Output: [ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]   Solution 2020-09-20 Notes:  Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums[i+1:]以避免dups。 经典的DFS，backtracking题。LC 47 保证distinct的条件是 sort + if i == n-1 or nums[i]!=nums[i+1]: 另外容易出错的地方是 append path时要使用 deep copy ans.append(path[:])，shallow copy不能正确返回。  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: if not nums: return [] ans = [] n = len(nums) self.backtracking(nums,ans,[]) return ans def backtracking(self, nums, ans, path): n = len(nums) if n == 0: ans.append(path[:]) return for i in range(n): path.append(nums[i]) self.backtracking(nums[:i]+nums[i+1:], ans, path) path.pop() # Time O(NlogN) # Space O(N)  ","id":230,"section":"posts","summary":"LC 46 Permutations Given a collection of distinct integers, return all possible permutations. Input: [1,2,3] Output: [ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Solution 2020-09-20 Notes: Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums","tags":["leetcode","DFS"],"title":"46 Permutations","uri":"https://foxisawesome.github.io/posts/46-permutations/","year":"2020"},{"content":"LC 994 Rotting Oranges   In a given grid, each cell can have one of three values:\n the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange.  Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.\n Solution 2020-09-20 Notes:  这题只能用BFS，因为是每分钟只有相邻的橘子被腐败。 这题先得走一遍grid把 =2的cell都加到queue里去，然后在走BFS，不能边走gird边做BFS。因为多处的rotten orange会同时开始腐败周围的橘子。 其他都是BFS的模版。  class Solution: def orangesRotting(self, grid: List[List[int]]) -\u0026gt; int: directions = [[0,1],[1,0],[0,-1],[-1,0]] queue = [] nr = len(grid) nc = len(grid[0]) t = 0 for i in range(nr): for j in range(nc): if grid[i][j] == 2: queue.append((i,j,t)) while queue: n = len(queue) for q in range(n): p = queue.pop(0) i, j, t = p[0], p[1], p[2] for d in directions: x, y = i+d[0], j+d[1] if 0\u0026lt;=x\u0026lt;nr and 0\u0026lt;=y\u0026lt;nc and grid[x][y]==1: queue.append((x,y,t+1)) grid[x][y] = 2 for i in range(nr): for j in range(nc): if grid[i][j] == 1: return -1 return t # Time O(N) # Space O(N)  ","id":231,"section":"posts","summary":"LC 994 Rotting Oranges In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this","tags":["leetcode","BFS"],"title":"994 Rotting Oranges","uri":"https://foxisawesome.github.io/posts/994-rotting-oranges/","year":"2020"},{"content":"LC 221 Maximal Square   Given a 2D binary matrix filled with 0\u0026rsquo;s and 1\u0026rsquo;s, find the largest square containing only 1\u0026rsquo;s and return its area.\nInput: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4   Solution 2020-09-20 Notes:    dp[i][j]: represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix. dp[0][j] = matrix[0][j] dp[i][0] = matrix[i][0] dp[i][j] = if matrix[i][j]==0 then 0, else min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1    class Solution: def maximalSquare(self, matrix: List[List[str]]) -\u0026gt; int: if not matrix: return 0 nrow = len(matrix) ncol = len(matrix[0]) dp = [ [0]*ncol for i in range(nrow)] for i in range(ncol): dp[0][i] = int(matrix[0][i]) for i in range(nrow): dp[i][0] = int(matrix[i][0]) for i in range(1,nrow): for j in range(1,ncol): if matrix[i][j]=='0': dp[i][j] = 0 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 return max(map(max, dp)) ** 2 # Time O() # Space O()  ","id":232,"section":"posts","summary":"LC 221 Maximal Square   Given a 2D binary matrix filled with 0\u0026rsquo;s and 1\u0026rsquo;s, find the largest square containing only 1\u0026rsquo;s and return its area.\nInput: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4   Solution 2020-09-20 Notes:    dp[i][j]: represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix.","tags":["leetcode","dp"],"title":"221 Maximal Square","uri":"https://foxisawesome.github.io/posts/221-maximal-square/","year":"2020"},{"content":"LC 7 Reverse Integer   Given a 32-bit signed integer, reverse digits of an integer.\nInput: -120 Output: -21   Solution 2020-09-20 Notes:  很简单的题，要记得overflow的处理。  class Solution: def reverse(self, x: int) -\u0026gt; int: if x == 0: return x sign = -1 if x \u0026lt; 0 else 1 x = abs(x) ans = 0 while x \u0026gt; 0: x, m = divmod(x,10) ans = ans*10 + m ans = ans * sign if ans not in range(-2**31,2**31-1): return 0 return ans # Time O(N) # Space O(1)  ","id":233,"section":"posts","summary":"LC 7 Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Input: -120 Output: -21 Solution 2020-09-20 Notes: 很简单的题，要记得overflow的处理。 class Solution: def reverse(self, x: int) -\u0026gt; int: if x == 0: return x sign = -1 if x \u0026lt; 0 else 1 x = abs(x) ans =","tags":["leetcode"],"title":"7 Reverse Integer","uri":"https://foxisawesome.github.io/posts/7-reverse-integer/","year":"2020"},{"content":"LC 394 Decode String   Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nInput: s = \u0026quot;3[a2[c]]\u0026quot; Output: \u0026quot;accaccacc\u0026quot;   Solution 2020-09-20 Notes:  比较简单的一道stack的题。类似于calculator，遇到 [,] 就将前面的string还有数字临时存入stack。  class Solution: def decodeString(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; stack = [] d = 0 ans = \u0026quot;\u0026quot; for i in s: if i.isdigit(): d = d*10 + int(i) elif i.isalpha(): ans += i elif i == '[': stack.append(d) stack.append(ans) ans = '' d = 0 elif i == ']': ans = stack.pop() + ans*stack.pop() return ans # Time O(N) # Space O(1)  ","id":234,"section":"posts","summary":"LC 394 Decode String Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. Input: s = \u0026quot;3[a2[c]]\u0026quot; Output: \u0026quot;accaccacc\u0026quot; Solution 2020-09-20 Notes: 比较简单的一道stack的题。类似于cal","tags":["leetcode","stack"],"title":"394 Decode String","uri":"https://foxisawesome.github.io/posts/394-decode-string/","year":"2020"},{"content":"LC 31 Next Permutation   Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3` → `1,3,2` `3,2,1` → `1,2,3` `1,1,5` → `1,5,1   Solution 2020-09-20 Notes: 很多小技巧的小题。大致的algo是这样的，需要 two-pass：\n 先找到从右往左第一个递减序列，1321 中的 321就是，标记 i=0。 然后在递减序列中找到第一个 i=0 大的数。2就是，标记 j=2。 swap nums[i], nums[j], 此时2311。 再翻转一下311 为 113.就是next greater permutation。和单调堆的思路很像。  class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: n = len(nums) i = n-2 while i \u0026gt;= 0 and nums[i+1] \u0026lt;= nums[i]: i -= 1 if i \u0026lt; 0: nums[:] = nums[::-1] return j = n-1 while j \u0026gt;= 0 and nums[i] \u0026gt;= nums[j]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i+1:] = nums[i+1:][::-1] return # Time O(N) # Space O(1)  ","id":235,"section":"posts","summary":"LC 31 Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3` →","tags":["leetcode","array"],"title":"31 Next Permutation","uri":"https://foxisawesome.github.io/posts/31-next-permutation/","year":"2020"},{"content":"LC 983 Minimum Cost for Tickets    Solution 2020-09-19 Notes:    # Time O() # Space O()  ","id":236,"section":"posts","summary":"LC 983 Minimum Cost for Tickets    Solution 2020-09-19 Notes:    # Time O() # Space O()  ","tags":["leetcode","dp"],"title":"983 Minimum Cost for Tickets","uri":"https://foxisawesome.github.io/posts/983-minimum-cost-for-tickets/","year":"2020"},{"content":"LC 322 Coin Change   You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nInput: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1   Solution 2020-09-19 Notes:  其实这题被 labuladong 解决的特别简单，只要一维dp。看每个amount能在 dp[amount-coin]上加一就好了。 完美。  class Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # dp[i]: min coins to get i amount dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(amount+1): for coin in coins: if i - coin \u0026gt;= 0 and dp[i-coin] != -1: dp[i] = min(dp[i], dp[i - coin]+1) return -1 if dp[amount] == float('inf') else dp[amount] # Time O(NM) # Space O(N)  ","id":237,"section":"posts","summary":"LC 322 Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5","tags":["leetcode","dp"],"title":"322 Coin Change","uri":"https://foxisawesome.github.io/posts/322-coin-change/","year":"2020"},{"content":"LC 692 Top K Frequent Words   Given a non-empty list of words, return the k most frequent elements.\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\n Solution 2020-09-19 Notes:   重要的来了，一般，我们认为找出k个最大最小的问题都是一个使用堆来做的。这个题中，学习了python的堆的用法。\n  heapq.heapify(heap)能在线性时间内，把一个列表转成堆。\n  heapq.heappop(heap)能直接弹出堆的堆顶。\n  heappush(heap,5)向堆中添加元素。\n  注意，heap是个list，哪怕使用了上述函数之后，这个仍然是list.\n  python中的堆默认是小根堆，如果想使用大根堆，在添加元素的时候使用负号即可。\n  class Solution: def topKFrequent(self, words: List[str], k: int) -\u0026gt; List[str]: count = collections.Counter(words) heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) return [heapq.heappop(heap)[1] for _ in range(k)] # Time O(N) # Space O(N)  ","id":238,"section":"posts","summary":"LC 692 Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Solution 2020-09-19 Notes: 重要的来了，一般，我们认为找出k个最大最小","tags":["leetcode","sort","hashtable","heap"],"title":"692 Top K Frequent Words","uri":"https://foxisawesome.github.io/posts/692-top-k-frequent-words/","year":"2020"},{"content":"LC 973 K Closest Points to Origin   We have a list of points on the plane. Find the K closest points to the origin (0, 0).\nInput: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u0026lt; sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].   Solution 2020-09-19 Notes:  Sort by Euclidean distance. O(nlogN) 用quicksort 可以减到 O(N). 还得再学习下quicksort的精妙。  class Solution: def kClosest(self, points: List[List[int]], K: int) -\u0026gt; List[List[int]]: points.sort(key = lambda x: x[0]**2+x[1]**2) return points[:K] # Time O(NlogN) # Space O(1)  ","id":239,"section":"posts","summary":"LC 973 K Closest Points to Origin We have a list of points on the plane. Find the K closest points to the origin (0, 0). Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u0026lt; sqrt(10), (-2, 2) is closer to the origin. We only want","tags":["leetcode","sort"],"title":"973 K Closest Points to Origin","uri":"https://foxisawesome.github.io/posts/973-k-closest-points-to-origin/","year":"2020"},{"content":"LC 20 Valid Parentheses   Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.   Solution 2020-09-19 Notes:  好经典的题。 思路如解。  class Solution: def isValid(self, s: str) -\u0026gt; bool: d = {'(': ')', '[':']', '{':'}'} stack = [] for i in s: if i in d: stack.append(d[i]) elif len(stack)==0 or i != stack[-1]: return False elif i == stack[-1]: stack.pop() return len(stack) == 0 # Time O(N) # Space O(N)  ","id":240,"section":"posts","summary":"LC 20 Valid Parentheses Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solution 2020-09-19 Notes: 好经典的题。 思路如解。 class Solution: def isValid(self,","tags":["leetcode","hashtable"],"title":"20 Valid Parentheses","uri":"https://foxisawesome.github.io/posts/20-valid-parentheses/","year":"2020"},{"content":"LC 953 Verifying an Alien Dictionary   In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.\nInput: words = [\u0026quot;word\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;row\u0026quot;], order = \u0026quot;worldabcefghijkmnpqstuvxyz\u0026quot; Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u0026gt; words[1], hence the sequence is unsorted.   Solution 2020-09-19 Notes:  algo：从第一个word开始往后扫，遇到false的case立马return False。 遇到相同符合order的case 就update下idx，然后remove这个word。一定要先update下 index 否则会出错。 遇到字母顺序完全一致的就保留到下一轮。 当第一个word扫完依然还有，remove掉这个word，从剩余的words重新再来一次。 看答案用了hash table，感觉time complexity也没有更优。  class Solution: def isAlienSorted(self, words: List[str], order: str) -\u0026gt; bool: stack = [] order_ = list(order) start = 0 while words: for i in range(start,len(words[0])): idx = order_.index(words[0][i]) for word in words[1:]: if i \u0026lt; len(word): if idx \u0026gt; order_.index(word[i]): return False elif idx \u0026lt; order_.index(word[i]): idx = order_.index(word[i]) words.remove(word) else: return False words.remove(words[0]) start = i+1 return True # Time O(NM): N: words length, M: max length of a signle word # Space O(1)  ","id":241,"section":"posts","summary":"LC 953 Verifying an Alien Dictionary In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. Input: words = [\u0026quot;word\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;row\u0026quot;],","tags":["leetcode","array","hashtable"],"title":"953 Verifying an Alien Dictionary","uri":"https://foxisawesome.github.io/posts/953-verifying-an-alien-dictionary/","year":"2020"},{"content":"LC 70 Climbing Stairs   You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n Solution 2020-09-15 Notes:  最经典的dp题了。dp[i] = dp[i-1] + dp[i-2], 主要是dp[i] 和 dp[i-1]直接差了一步，多走一步但毅然还是那条path。同理 dp[i] 与 dp[i-2]差了两步，但依然是同一条path，所以是之和。还可以继续优化sapce to O(1). 与 LC 91 一样。  class Solution: def climbStairs(self, n: int) -\u0026gt; int: dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 for i in range(2,n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] # Time O(N) # Space O(N)  recursion with memo\nclass Solution: def __init__(self): self.memo = dict() self.memo[0] = 1 self.memo[1] = 1 def climbStairs(self, n: int) -\u0026gt; int: if n in self.memo: return self.memo[n] self.memo[n] = self.climbStairs(n-1) + self.climbStairs(n-2) return self.memo[n] # Time O(N) # Space O(N)  ","id":242,"section":"posts","summary":"LC 70 Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Solution 2020-09-15 Notes: 最经典的dp题了。dp[i] = dp[i-1] + dp[i-2], 主要是dp[i] 和","tags":["leetcode","dp"],"title":"70 Climbing Stairs","uri":"https://foxisawesome.github.io/posts/70-climbing-stairs/","year":"2020"},{"content":"LC 91 Decode Ways   A message containing letters from A-Z is being encoded to numbers using the following mapping:\n'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26  Given a non-empty string containing only digits, determine the total number of ways to decode it.\nInput: \u0026ldquo;226\u0026rdquo; Output: 3 Explanation: It could be decoded as \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), or \u0026ldquo;BBF\u0026rdquo; (2 2 6).\n Solution 2020-09-15 Notes:  开始用了backtracking 复杂度太高不能过。 只能用dp，思想和 LC 70完全一样： dp[i]: ways of decode string s[:i]. dp[i] = dp[i-1] if s[i] != '0' + dp[i-2] if '10' \u0026lt;= s[i-2:i] \u0026lt;= '26' dp[0] = 1这个起始条件要注意，和stair一样。  class Solution: def numDecodings(self, s: str) -\u0026gt; int: if not s: return 0 n = len(s) dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2,n+1): path_1digit = dp[i-1] if s[i-1]!='0' else 0 path_2digit = dp[i-2] if '10' \u0026lt;= s[i-2:i] \u0026lt;= '26' else 0 dp[i] = path_1digit + path_2digit return dp[n] # Time O(N) # Space O(N)  ","id":243,"section":"posts","summary":"LC 91 Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Input: \u0026ldquo;226\u0026rdquo; Output: 3 Explanation: It could be decoded as \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), or \u0026ldquo;BBF\u0026rdquo; (2 2 6). Solution 2020-09-15 Notes: 开","tags":["leetcode","dp"],"title":"91 Decode Ways","uri":"https://foxisawesome.github.io/posts/91-decode-ways/","year":"2020"},{"content":"LC 238 Product of Array Except Self   Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nInput: [1,2,3,4] Output: [24,12,8,6]   Solution 2020-09-15 Notes:  3-pass, space O(N) solution. L[i] = cumulative product of nums[:i], R[i] = cumulative product of nums[:i:-1]  class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) L = [1]*n R = [1]*n ans = [] for i in range(1, n): L[i] = L[i-1] * nums[i-1] for j in range(n-2,-1,-1): R[j] = R[j+1] * nums[j+1] for k in range(n): ans.append(L[k]*R[k]) return ans # Time O(N) # Space O(N)   optimal solution, 2-pass, space O(N). 和楼上的思想一致。 先从左到右算一遍up to 前一位的连乘积，再从右到左算一遍连乘积。ans 不算入 space complexity。  class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) ans = [] prod = 1 for i in range(n): ans.append(prod) prod *= nums[i] prod = 1 for j in range(n-1,-1,-1): ans[j] *= prod prod *= nums[j] return ans  ","id":244,"section":"posts","summary":"LC 238 Product of Array Except Self Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Input: [1,2,3,4] Output: [24,12,8,6] Solution 2020-09-15 Notes: 3-pass, space O(N) solution. L[i] = cumulative product of nums[:i], R[i] = cumulative product of nums[:i:-1] class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n","tags":["leetcode","array"],"title":"238 Product of Array Except Self","uri":"https://foxisawesome.github.io/posts/238-product-of-array-except-self/","year":"2020"},{"content":"LC 56 Merge Intervals   Given a collection of intervals, merge all overlapping intervals.\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].   Solution 2020-09-15 Notes:  先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。  class Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: if not intervals: return [] intervals.sort(key = lambda x: (x[0],x[1])) ans = [intervals[0]] for i in intervals[1:]: if i[0] \u0026lt;= ans[-1][1]: if i[1] \u0026gt;= ans[-1][1]: ans[-1][1] = i[1] else: ans.append(i) return ans # Time O(NlogN) # Space O(N)  ","id":245,"section":"posts","summary":"LC 56 Merge Intervals Given a collection of intervals, merge all overlapping intervals. Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Solution 2020-09-15 Notes: 先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。 class Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: if not intervals:","tags":["leetcode","sort"],"title":"56 Merge Intervals","uri":"https://foxisawesome.github.io/posts/56-merge-intervals/","year":"2020"},{"content":"LC 23 Merge K Sorted Lists   You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] merging them into one sorted list: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6   Solution 2020-09-14 Notes:  最简单暴力，最挫的方法。  class Solution: def mergeKLists_1(self, lists: List[ListNode]) -\u0026gt; ListNode: nodes = [] head = cur = ListNode(0) for l in lists: while l: nodes.append(l.val) l = l.next nodes.sort() for i in nodes: cur.next = ListNode(i) cur = cur.next return head.next # Time O(NlogN) # Space O(N)   merge sort方法：要记一下这种merge sort的写法  class Solution: def mergeKLists(self, lists: List[ListNode]) -\u0026gt; ListNode: if not lists: return n = len(lists) interval = 1 head = cur = ListNode(0) while interval \u0026lt; n: for i in range(0, n-interval, interval*2): lists[i] = self.merge2ls(lists[i],lists[i+interval]) interval *= 2 return lists[0] def merge2ls(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = p = ListNode(0) while l1 and l2: if l1.val \u0026gt; l2.val: p.next = l2 l2 = l2.next else: p.next = l1 l1 = l1.next p = p.next l = l1 if l1 else l2 p.next = l return head.next # Time O(NlogK): N:# of nodes, K:# of list # Space O(1)   Heapq 方法: python 3 中无法比较tuple中的ListNode，于是只要是node.val 相等，就比较tuple的第二位，which is a proxy: x to work around this issue.  class Solution(object): def mergeKLists(self, lists): import heapq result = ListNode(-1) cur = result p = list() x = 0 for i in lists: while i: heapq.heappush(p, (i.val, x, i)) i = i.next x += 1 while p: cur.next = heapq.heappop(p)[2] cur = cur.next return result.next  ","id":246,"section":"posts","summary":"LC 23 Merge K Sorted Lists You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] merging them into one sorted list: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 Solution 2020-09-14 Notes: 最简单暴力，最挫的方法。","tags":["leetcode","linkedlist"],"title":"23 Merge K Sorted Lists","uri":"https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/","year":"2020"},{"content":"LC 3 Longest Substring Without Repeating Characters   Given a string s, find the length of the longest substring without repeating characters.\n Solution 2020-09-14 Notes:\n 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding window的 template 参见 labuladong 的文章，归纳的巨好。其实一个月前刚学会，今天又忘了。。。这个故事告诉我们，按主题刷完 按频率刷看啥题都brute force一样做。。。三刷得搞出来！  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: if not s: return 0 l, r, ans = 0, 0, 0 n = len(s) window = dict() while r \u0026lt; n: tail = s[r] window[tail] = window.get(tail,0)+1 r += 1 while window[tail] \u0026gt; 1: head = s[l] window[head] = window.get(head, 0) - 1 l += 1 ans = max(ans, r-l) return ans # Time O(N) # Space O(N)  ","id":247,"section":"posts","summary":"LC 3 Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters. Solution 2020-09-14 Notes: 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding w","tags":["leetcode","sliding_window"],"title":"3 Longest Substring Without Repeating Characters","uri":"https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/","year":"2020"},{"content":"LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence\u0026rsquo;s length in s. You may assume that the maximum length of s is 1000.\n Solution 2020-09-14 Notes:\n   class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] != s[j]: dp[i][j] = max(dp[i-1][j], dp[i][j+1]) # init: dp[i][i] = 1 dp = [[0]*n for _ in range(n)] for i in range(n,0,-1): dp[i-1][i-1] = 1 for j in range(i-1,n-1): if s[i-1] == s[j+1]: dp[i-1][j+1] = dp[i][j] + 2 else: dp[i-1][j+1] = max(dp[i-1][j], dp[i][j+1]) return dp[0][n-1] # Time O(N^2) # Space O(N^2)  ","id":248,"section":"posts","summary":"LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence\u0026rsquo;s length in s. You may assume that the maximum length of s is 1000.\n Solution 2020-09-14 Notes:\n   class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] !","tags":["leetcode"],"title":"516 Longest Palindromic Subsequence","uri":"https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/","year":"2020"},{"content":"LC 5 Longest Palindromic Substring   Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nInput: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer.   Solution 2020-09-14 Notes:\n 本质是dp，与LC 516相同  class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; n = len(s) for i in range(n): for j in range(n-1,i-1,-1): if j-i+1 \u0026lt; len(ans): break elif s[i:j+1] == s[i:j+1][::-1]: ans = s[i:j+1] return ans # Time O(N^2) # Space O(1)  ","id":249,"section":"posts","summary":"LC 5 Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Input: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer. Solution 2020-09-14 Notes: 本质是dp，与LC 516相同 class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; n =","tags":["leetcode"],"title":"5 Longest Palindromic Substring","uri":"https://foxisawesome.github.io/posts/5-longest-palindromic-substring/","year":"2020"},{"content":"LC 937 Reorder Data in Log Files   You have an array of logs. Each log is a space delimited string of words.\nFor each log, the first word in each log is an alphanumeric identifier. Then, either:\n Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier.\nReorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.\nReturn the final order of the logs.\n Solution 2020-09-14 Notes:\n 题目写的特别复杂，估计主要考查string的各种method。 sort的 lambda function还得多练练  class Solution: def reorderLogFiles(self, logs: List[str]) -\u0026gt; List[str]: if not logs: return [] digit = [] letter = [] for log in logs: l = log.split(' ') if l[1].isdigit(): digit.append(log) else: letter.append(l) letter.sort(key=lambda x: (x[1:], x[0])) l = [ ' '.join(i) for i in letter ] return l + digit # Time O(MNlogN) # Space O(N)  ","id":250,"section":"posts","summary":"LC 937 Reorder Data in Log Files You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs.","tags":["leetcode","string"],"title":"937 Reorder Data in Log Files","uri":"https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/","year":"2020"},{"content":"LC 53 Maximum Subarray   Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.   Solution 2020-09-13 Notes:\n 这是一道看似很简单的dp啊！首先我想到的是先算一遍cumulative sum，再double loop做一遍。$\\mathcal{O}(N^2)$. 然后看了答案惊叹哇好天才的做法。好受打击。 最后看了 负雪明烛 才明白原来这是道 dp。原来答案是优化了space后的dp。怪不得高级。 dp[i] = max(nums[i], dp[i-1]+nums[i])  class Solution: def maxSubArray_dp(self, nums: List[int]) -\u0026gt; int: pre_sum, dp = nums[0], nums for i in range(1,len(nums)): dp[i] = max(nums[i], dp[i-1]+nums[i]) return max(dp) def maxSubArray(self, nums: List[int]) -\u0026gt; int: pre_sum, gb_max = nums[0], nums[0] for i in nums[1:]: pre_sum = max(i, i+pre_sum) gb_max = max(gb_max, pre_sum) return gb_max # Time O(N) # Space O(N)  ","id":251,"section":"posts","summary":"LC 53 Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Solution 2020-09-13 Notes: 这是","tags":["leetcode","dp"],"title":"53 Maximum Subarray","uri":"https://foxisawesome.github.io/posts/53-maximum-subarray/","year":"2020"},{"content":"LC 262 Trips and Users   Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users.\nFor the above tables, your SQL query should return the following rows with the cancellation rate being rounded to two decimal places.\n+------------+-------------------+ | Day | Cancellation Rate | +------------+-------------------+ | 2013-10-01 | 0.33 | | 2013-10-02 | 0.00 | | 2013-10-03 | 0.50 | +------------+-------------------+   Solution 2020-09-13 Notes:\n 很烦而已的题。  SELECT Request_at AS day, ROUND( IFNULL( SUM(CASE WHEN status!='completed' THEN 1 ELSE 0 end) / SUM(1), 0) ,2) AS 'Cancellation Rate' FROM trips WHERE Client_id in (SELECT users_id FROM users WHERE banned = 'No') and driver_id in (SELECT users_id from users WHERE banned = 'No') and request_at between '2013-10-01' and '2013-10-03' GROUP BY 1 ORDER BY 1 ;  ","id":252,"section":"posts","summary":"LC 262 Trips and Users Write a SQL query to find the cancellation rate of requests made by unbanned users (both client and driver must be unbanned) between Oct 1, 2013 and Oct 3, 2013. The cancellation rate is computed by dividing the number of canceled (by client or driver) requests made by unbanned users by the total number of requests made by unbanned users. For the above tables, your","tags":["leetcode"],"title":"262 Trips and Users","uri":"https://foxisawesome.github.io/posts/262-trips-and-users/","year":"2020"},{"content":"LC 185 Department Top Three Salaries   Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).\n+------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe | 85000 | | IT | Will | 70000 | | Sales | Henry | 80000 | | Sales | Sam | 60000 | +------------+----------+--------+   Solution 2020-09-13 Notes:\nCTE + DENSE_RANK(). CTE里得完全列出所有的fields。未知原因，window function里partition by 只能departmentID才work。\nWITH combo AS( SELECT a.NAME AS department, b.name, salary, departmentid FROM employee a JOIN department b ON a.departmentid = b.id ) SELECT department, employee, salary FROM ( SELECT name AS employee, salary, departmentid, department, DENSE_RANK() OVER(PARTITION BY departmentid ORDER BY salary DESC) AS rk FROM combo ) a WHERE rk \u0026lt;= 3 ORDER BY departmentid, salary DESC ;  还有种的做法：\nselect b.name as Department, a.name as Employee, a.Salary from employee a inner join department b on a.departmentID = b.id where 3 \u0026gt;= ( select count(distinct c.salary) from employee c where c.salary \u0026gt;= a.salary and c.departmentid = a.departmentid ) ;  ","id":253,"section":"posts","summary":"LC 185 Department Top Three Salaries Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter). +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Randy | 85000 | | IT | Joe |","tags":["leetcode"],"title":"185 Department Top Three Salaries","uri":"https://foxisawesome.github.io/posts/185-department-top-three-salaries/","year":"2020"},{"content":"LC 175 Combine Two Tables   Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:\nFirstName, LastName, City, State   Solution 2020-09-13 Notes:\n Easy 小题考查left join  SELECT firstname, lastname, city, state FROM person a LEFT JOIN address b ON a.personid = b.personid  ","id":254,"section":"posts","summary":"LC 175 Combine Two Tables Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people: FirstName, LastName, City, State Solution 2020-09-13 Notes: Easy 小题考查left join SELECT firstname, lastname, city, state FROM person a LEFT JOIN address b ON a.personid = b.personid","tags":["leetcode"],"title":"175 Combine Two Tables","uri":"https://foxisawesome.github.io/posts/175-combine-two-tables/","year":"2020"},{"content":"LC 176 Second Highest Salary   Write a SQL query to get the second highest salary from the Employee table.\n Solution 2020-09-13 Notes:\n 这easy题有个小坑，要是table 不存在second highest，于是subquery就不会返回任何，必须得用max() 才能防止这个。  SELECT MAX(salary) AS secondHighestSalary FROM( SELECT salary, RANK() OVER(ORDER BY salary DESC) AS rk FROM employee ) a WHERE rk = 2  ","id":255,"section":"posts","summary":"LC 176 Second Highest Salary Write a SQL query to get the second highest salary from the Employee table. Solution 2020-09-13 Notes: 这easy题有个小坑，要是table 不存在second highest，于是subquery就不会","tags":["leetcode"],"title":"176 Second Highest Salary","uri":"https://foxisawesome.github.io/posts/176-second-highest-salary/","year":"2020"},{"content":"LC 146 LRU Cache   Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\nThe cache is initialized with a positive capacity.\nFollow up: Could you do both operations in O(1) time complexity?\n Solution 2020-09-13 Notes:\n 抄了一遍答案。多看几遍。  class ListNode: def __init__(self, key, value): self.key = key self.value = value self.prev = self self.next = self class LRUCache: def __init__(self, capacity: int): self.dict = dict() self.cap = capacity self.size = 0 self.root = ListNode(0, 0) def get(self, key: int) -\u0026gt; int: if key in self.dict: node = self.dict[key] self.removeFromList(node) self.insertIntoHead(node) return node.value else: return -1 def put(self, key: int, value: int) -\u0026gt; None: if key in self.dict: node = self.dict[key] self.removeFromList(node) self.insertIntoHead(node) node.value = value else: if self.size == self.cap: self.removeFromTail() self.size -= 1 node = ListNode(key, value) self.insertIntoHead(node) self.dict[key] = node self.size += 1 def removeFromList(self, node): if node == self.root: return prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node node.prev = node.next = None def insertIntoHead(self, node): head_node = self.root.next head_node.prev = node node.prev = self.root self.root.next = node node.next = head_node def removeFromTail(self): if self.size == 0: return tail_node = self.root.prev del self.dict[tail_node.key] self.removeFromList(tail_node) # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)  ","id":256,"section":"posts","summary":"LC 146 LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should","tags":["leetcode","linkedlist"],"title":"146 LRU Cache","uri":"https://foxisawesome.github.io/posts/146-lru-cache/","year":"2020"},{"content":"LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nInput: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:\n    ","id":257,"section":"posts","summary":"LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nInput: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:\n    ","tags":["leetcode","tree"],"title":"99 Recover Binary Search Tree","uri":"https://foxisawesome.github.io/posts/99-recover-binary-search-tree/","year":"2020"},{"content":"LC 92 Reverse Linked List ii   Reverse a linked list from position m to n. Do it in one-pass.\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL   Solution 2020-09-13 Notes:\n 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的utility function才测试方便。做出来还是很开心的！ algo:  准备一个 head 的copy， curr。初始时，curr得比head晚一步，否值 m==1时会有问题。 开始先跳过m步，此时head时reverse link的起点，curr在head之前一步 line#18 reverse 步骤完全和LC 206一致 完成reverse后，curr 要point到receved list的头 line#26 然后走完一遍curr，最后point回剩下的head。    # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -\u0026gt; ListNode: if not head: return curr = ListNode(0) curr.next = head dummy = curr c = 1 while head and c \u0026lt; m: curr = curr.next head = head.next c += 1 # now head at the starting point of reverse, curr.next = head pre = None while head and c \u0026lt; n+1: _next = head.next head.next = pre pre = head head = _next c += 1 # now reverse finished, head of reversed list is pre curr.next = pre while curr and curr.next: curr = curr.next curr.next = head return dummy.next # Time O(N) # Space O(1)  ","id":258,"section":"posts","summary":"LC 92 Reverse Linked List ii Reverse a linked list from position m to n. Do it in one-pass. Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL Solution 2020-09-13 Notes: 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的util","tags":["leetcode","linkedlist"],"title":"92 Reverse Linked List ii","uri":"https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/","year":"2020"},{"content":"LC 102 Binary Tree Level Order Traversal   Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7  return [[3],[9,20],[15,7]]\n Solution 2020-09-13 Notes:\n  与LC 109 一样\nRecursion 解法：\n  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.postOrder(root,0) out = [val for i, val in self.d.items()] return out def postOrder(self, root, h): if not root: return h += 1 self.d[h].append(root.val) self.postOrder(root.left,h) self.postOrder(root.right,h) return # Time O(N) # Space O(H)  iteration:\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: ans = [] if not root: return ans queue = [root] while queue: sub = [] for i in range(len(queue)): node = queue.pop(0) sub.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) ans.append(sub) return ans # Time O(N) # Space O(N)  ","id":259,"section":"posts","summary":"LC 102 Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return [[3],[9,20],[15,7]] Solution 2020-09-13 Notes: 与LC 109 一样 Recursion 解法： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0,","tags":["leetcode","tree"],"title":"102 Binary Tree Level Order Traversal","uri":"https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/","year":"2020"},{"content":"LC 199 Binary Tree Right Side View   Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample:\nInput: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 \u0026lt;--- / \\ 2 3 \u0026lt;--- \\ \\ 5 4 \u0026lt;---   Solution 2020-09-13 Notes:  一刷虽然做出来了 但是在输出的时候总感觉很冗余。algo就是post-order 走一遍，每一层都用一个dict记录下来，然后取每层的最后一个值。 与LC 102 一样  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def rightSideView(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.postOrder(root,0) out = [0] * max([i for i,val in self.d.items()]) for k, val in self.d.items(): out[k-1] = val[-1] return out def postOrder(self, root, h): if not root: return h += 1 self.postOrder(root.left,h) self.postOrder(root.right,h) self.d[h].append(root.val) return # Time O(N) # Space O(H)  结果看了下负雪明烛，只要pre-order用dict记录root.val就能保证字典里的顺序是in-order的。\nclass Solution: def rightSideView(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.preOrder(root,0) out = [val[-1] for i, val in self.d.items()] return out def preOrder(self, root, h): if not root: return h += 1 self.d[h].append(root.val) self.preOrder(root.left,h) self.preOrder(root.right,h) return # Time O(N) # Space O(H)  ","id":260,"section":"posts","summary":"LC 199 Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 \u0026lt;--- / \\ 2 3 \u0026lt;--- \\ \\ 5 4 \u0026lt;--- Solution 2020-09-13 Notes: 一刷虽然做出来了 但是在输出","tags":["leetcode","tree"],"title":"199 Binary Tree Right Side View","uri":"https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/","year":"2020"},{"content":"LC 987 Vertical Order Traversal of a Binary Tree   Given a binary tree, return the vertical order traversal of its nodes values.\nFor each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).\nIf two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\nReturn an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes.\nInput: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2).   Solution 2020-09-09 Notes:  这题最难的部分不是recursion， 而是需要经过三层sort得到题目要求的排序结果。。。题目要求：首先需要根据 x坐标排序，然后根据y坐标排序，最后若y相同再从小到大排序。。。于是line13-20都在茫茫的排序中。。。排了我美好Sunday的一个小时。。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def verticalTraversal(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return None ans = [] d = collections.defaultdict(list) self.preOrder(root,d,0,0) temp = [val for i, val in sorted(d.items(), key=lambda item: item[0])] for i in temp: t = [] i = sorted(i, key = lambda x: (x[0], x[1])) for j in i: t.append(j[1]) ans.append(t) return ans def preOrder(self, root, d, x, y): if not root: return None d[x].append((y,root.val)) self.preOrder(root.left, d, x-1, y+1) self.preOrder(root.right,d, x+1, y+1) return # Time O(N) # Space O(H)  ","id":261,"section":"posts","summary":"LC 987 Vertical Order Traversal of a Binary Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes","tags":["leetcode","tree","sort"],"title":"987 Vertical Order Traversal of a Binary Tree","uri":"https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/","year":"2020"},{"content":"LC 501 Find Mode in Binary Search Tree   Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\nAssume a BST is defined as follows:\n  The left subtree of a node contains only nodes with keys less than or equal to the node\u0026rsquo;s key.\n  The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key.\n  Both the left and right subtrees must also be binary search trees.\nexample: Given BST [1,null,2,2],\n   1 \\ 2 / 2  return [2].\n Solution 2020-09-12 Notes:  BST肯定用in-order, space O(N)是就用个counter dict来记录mode。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findMode(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] self.count = collections.Counter() self.inorder(root) ans = [] freq = self.count.most_common()[0][1] for k, val in self.count.items(): if val == freq: ans.append(k) return ans def inorder(self, root): if not root: return self.inorder(root.left) self.count[root.val] += 1 self.inorder(root.right) # Time O(N) # Space O(N)  Space O(1) 的解，走两次in-order。一次计算freq，两一次\n","id":262,"section":"posts","summary":"LC 501 Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal","tags":["leetcode","tree"],"title":"501 Find Mode in Binary Search Tree","uri":"https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/","year":"2020"},{"content":"LC 621 Task Scheduler   Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\nHowever, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\nInput: tasks = [\u0026quot;A\u0026quot;,\u0026quot;A\u0026quot;,\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;B\u0026quot;], n = 2 Output: 8 Explanation: A -\u0026gt; B -\u0026gt; idle -\u0026gt; A -\u0026gt; B -\u0026gt; idle -\u0026gt; A -\u0026gt; B There is at least 2 units of time between any two same tasks.   Solution 2020-09-12 Notes:\n 有个计算公式：$(\\text{most_freq}-1)*(n+1)+\\text{top_tasks}$ 因为最优就是尽可能利用间隔 n 的idle 时间，把他们填满了还有多余的tasks那就是len(tasks)了。所以频率最高的字母先排好，然后往idle时间里插入余下的不同种tasks。有$(\\text{most_freq}-1)$间隙，每个间隙duration是（n+1）。最后加上所有最高频率出现的distinct tasks. 最后要取max().  class Solution: def leastInterval(self, tasks: List[str], n: int) -\u0026gt; int: if not tasks: return 0 count = collections.Counter(tasks) most_freq = count.most_common()[0][1] top_tasks = len([k for k, val in count.items() if val == most_freq]) ans = max(len(tasks), (most_freq-1)*(n+1)+top_tasks) return ans # Time O(N) # Space O(N)  ","id":263,"section":"posts","summary":"LC 621 Task Scheduler Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two","tags":["leetcode","string","math"],"title":"621 Task Scheduler","uri":"https://foxisawesome.github.io/posts/621-task-scheduler/","year":"2020"},{"content":"LC 300 Longest Increasing Subsequence   Given an unsorted array of integers, find the length of longest increasing subsequence.\nExample:\nInput: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Solution 2020-09-12 Notes:\n  $\\mathcal{O}(N^2)$的解，25%通过了。经典的dp算法题，算法如下：\n 每个位置dp[i]:表示是nums中[0, i]中最长递增子序列length。nums[i+1]与之前每个num比较，要是更大，就能与其组成更长的数列，dp[i+1] = max(1, dp[j] | j \u0026lt; i+1 and num[j] \u0026lt; num[i+1]) 在top ranking的解里看到了用binary search的高级方法，二刷的时候在试试吧。    class Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) dp = [1]*n for i in range(1,n): for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j]+1) return max(dp) # Time O(N^2) # Space O(N)  ","id":264,"section":"posts","summary":"LC 300 Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Solution 2020-09-12 Notes: $\\mathcal{O}(N^2)$的解，25%通过了。经典的d","tags":["leetcode","dp"],"title":"300 Longest Increasing Subsequence","uri":"https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/","year":"2020"},{"content":"LC 767 Reorganize String   Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.\nIf possible, output any possible result. If not possible, return the empty string.\nInput: S = \u0026quot;aab\u0026quot; Output: \u0026quot;aba\u0026quot;   Solution 2020-10-09 Notes:   又刷了一遍，感觉algo不难想到吗，可是很难implement。\n  看了75%的答案，对dictionary的API 有了新认识。\n  algo 事例: ‘aaabbbccc’. [\u0026lsquo;a\u0026rsquo;, None, \u0026lsquo;a\u0026rsquo;, None, \u0026lsquo;a\u0026rsquo;, None, ‘b’, None]\n  class Solution: def reorganizeString(self, S: str) -\u0026gt; str: counter = collections.Counter(S) n, p = len(S), 0 maxItem, maxFreq = max(counter.items(), key=lambda x: x[1]) if n - maxFreq \u0026lt; maxFreq-1: return '' ans = [None] * n ans[:maxFreq*2:2] = [maxItem] * maxFreq idx = maxFreq*2 for i, c in counter.items(): if i == maxItem: continue for j in range(c): if idx \u0026gt;= n: idx = 1 ans[idx] = i idx += 2 return ''.join(ans)  2020-09-12 Notes:  这题的思路来自这：  有个dynamic的counter dictionary 每次按频率出现次数最多的顺序加入ans，如果频率一样取与ans[-1]不同的字母加入，直至取完或者无法满足条件。 每加入一个字母， 字典频率 -1，需要回到while loop, 重新load counter.most_common()    class Solution: def reorganizeString(self, S: str) -\u0026gt; str: counter = collections.Counter(S) ans = \u0026quot;@\u0026quot; while counter: stop = True for s, freq in counter.most_common(): if ans[-1] != s and freq != 0: stop = False ans += s counter[s] -= 1 if counter[s] == 0: del counter[s] break if stop: break return ans[1:] if len(ans[1:]) == len(S) else '' # Time O(N) # Space O(N)  ","id":265,"section":"posts","summary":"LC 767 Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Input: S = \u0026quot;aab\u0026quot; Output: \u0026quot;aba\u0026quot; Solution 2020-10-09 Notes: 又刷了一遍，感觉algo不难想到吗，可","tags":["leetcode","string","hashtable","dia"],"title":"767 Reorganize String","uri":"https://foxisawesome.github.io/posts/767-reorganize-string/","year":"2020"},{"content":"双指针技巧总结 我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。\n一、快慢指针的常见算法 快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。\n1、判定链表中是否含有环\n这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。\n单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。\n如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。\nboolean hasCycle(ListNode head) { while (head != null) head = head.next; return false; }  但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。\n经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。\nboolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) return true; } return false; }  2、已知链表中含有环，返回这个环的起始位置\n这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：\nListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; }  可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？\n第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（环长度的倍数）。\n设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。\n3、寻找链表的中点\n类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。\nwhile (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // slow 就在中间位置 return slow;  当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：\n寻找链表中点的一个重要作用是对链表进行归并排序。\n回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。\n但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。\n4、寻找链表的倒数第 k 个元素\n我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：\nListNode slow, fast; slow = fast = head; while (k-- \u0026gt; 0) fast = fast.next; while (fast != null) { slow = slow.next; fast = fast.next; } return slow;  二、左右指针的常用算法 左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。\n1、二分查找\n前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：\nint binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left \u0026lt;= right) { int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid - 1; } return -1; }  2、两数之和\n直接看一道 LeetCode 题目吧：\n只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：\nint[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { // 题目要求的索引是从 1 开始的 return new int[]{left + 1, right + 1}; } else if (sum \u0026lt; target) { left++; // 让 sum 大一点 } else if (sum \u0026gt; target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; }  3、反转数组\nvoid reverse(int[] nums) { int left = 0; int right = nums.length - 1; while (left \u0026lt; right) { // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; } }  4、滑动窗口算法\n这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。\n幸运的是，这类算法是有框架模板的，而且这篇文章就讲解了「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。\n致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\n","id":266,"section":"posts","summary":"双指针技巧总结 我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环","tags":[""],"title":"双指针技巧总结","uri":"https://foxisawesome.github.io/posts/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","year":"2020"},{"content":"团灭 LeetCode 股票买卖问题 很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。\n这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\nPS：本文参考自英文版 LeetCode 的一篇题解。\n先随便抽出一道题，看看别人的解法：\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i\u0026lt;prices.size();++i) { s1 = max(s1, -prices[i]); s2 = max(s2, s1+prices[i]); s3 = max(s3, s2-prices[i]); s4 = max(s4, s3+prices[i]); } return max(0,s4); }  能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。\n本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\n这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：\n第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。\n如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。\n一、穷举框架\n首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。\n递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。\n而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。\nfor 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...)  比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k \u0026gt; 0 的前提下操作。\n很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：\ndp[i][k][0 or 1] 0 \u0026lt;= i \u0026lt;= n-1, 1 \u0026lt;= k \u0026lt;= K n 为天数，大 K 为最多交易数 此问题共 n × K × 2 种状态，全部穷举就能搞定。 for 0 \u0026lt;= i \u0026lt; n: for 1 \u0026lt;= k \u0026lt;= K: for s in {0, 1}: dp[i][k][s] = max(buy, sell, rest)  而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？\n我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。\n记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。\n二、状态转移框架\n现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。\n通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell ) 解释：今天我没有持有股票，有两种可能： 要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有； 要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy ) 解释：今天我持有着股票，有两种可能： 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票； 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。  这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。\n现在，我们已经完成了动态规划中最困难的一步：状态转移方程。**如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。**不过还差最后一点点，就是定义 base case，即最简单的情况。\ndp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。 dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。  把上面的状态转移方程总结一下：\nbase case： dp[-1][k][0] = dp[i][0][0] = 0 dp[-1][k][1] = dp[i][0][1] = -infinity 状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])  读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。\n三、秒杀题目\n第一题，k = 1\n直接套状态转移方程，根据 base case，可以做一些化简：\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。 可以进行进一步化简去掉所有 k： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i])  直接写出代码：\nint n = prices.length; int[][] dp = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0];  显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：\nfor (int i = 0; i \u0026lt; n; i++) { if (i - 1 == -1) { dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; } dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0];  第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):\n// k == 1 int maxProfit_k_1(int[] prices) { int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); } return dp_i_0; }  两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。\n第二题，k = +infinity\n如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  直接翻译成代码：\nint maxProfit_k_inf(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); } return dp_i_0; }  第三题，k = +infinity with cooldown\n每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。  翻译成代码：\nint maxProfit_with_cool(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; } return dp_i_0; }  第四题，k = +infinity with fee\n每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) 解释：相当于买入股票的价格升高了。 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。  直接翻译成代码：\nint maxProfit_with_fee(int[] prices, int fee) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); } return dp_i_0; }  第五题，k = 2\nk = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。\n这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。\n原始的动态转移方程，没有可化简的地方 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])  按照之前的代码，我们可能想当然这样写代码（错误的）：\nint k = 2; int[][][] dp = new int[n][k + 1][2]; for (int i = 0; i \u0026lt; n; i++) if (i - 1 == -1) { /* 处理一下 base case*/ } dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][k][0];  为什么错误？我这不是照着状态转移方程写的吗？\n还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1：\n「代码截图」\n这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：\nint max_k = 2; int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i \u0026lt; n; i++) { for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { /*处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } } // 穷举了 n × max_k × 2 个状态，正确。 return dp[n - 1][max_k][0];  如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。\n这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]) dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) int maxProfit_k_2(int[] prices) { int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) { dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); } return dp_i20; }  有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。\n第六题，k = any integer\n有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？\n一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。\n直接把之前的代码重用：\nint maxProfit_k_any(int max_k, int[] prices) { int n = prices.length; if (max_k \u0026gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i \u0026lt; n; i++) for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { /* 处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][max_k][0]; }  至此，6 道题目通过一个状态转移方程全部解决。\n四、最后总结\n本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。\n关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？\n具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。\nHanmin 提供 Python3 代码:\n第一题，k = 1\ndef maxProfit(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, -price) return dp_i_0  第二题，k = +infinity\ndef maxProfit_k_inf(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, temp - price) return dp_i_0  第三题，k = +infinity with cooldown\ndef maxProfit_with_cool(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') dp_pre_0 = 0 ##代表 dp[i-2][0] for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, dp_pre_0 - price) dp_pre_0 = temp return dp_i_0  第四题，k = +infinity with fee\ndef maxProfit_with_fee(self, prices: List[int], fee: int) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, temp - price -fee) return dp_i_0  第五题，k = 2\ndef maxProfit_k_2(self, prices: List[int]) -\u0026gt; int: dp_i10,dp_i11 = 0,float('-inf') dp_i20,dp_i21 = 0,float('-inf') for price in prices: dp_i20 = max(dp_i20, dp_i21 + price) dp_i21 = max(dp_i21, dp_i10 - price) dp_i10 = max(dp_i10, dp_i11 + price) dp_i11 = max(dp_i11, -price) return dp_i20  第六题，k = any integer\ndef maxProfit_k_any(self, max_k: int, prices: List[int]) -\u0026gt; int: n = len(prices) if max_k \u0026gt; n // 2: return self.maxProfit_k_inf(prices) else: dp = [[[None, None] for _ in range(max_k + 1)] for _ in range(n)] for i in range(0,n): for k in range(max_k,0,-1): if i-1 == -1:## 处理 base case dp[i][k][0] = 0 ## 解释： ## dp[i][k][0] = max(dp[-1][k][0], dp[-1][k][1] + prices[i]) ## = max(0, -infinity + prices[i]) = 0 dp[i][k][1] = -prices[i] ## 解释： ## dp[i][1] = max(dp[-1][k][1], dp[-1][k][0] - prices[i]) ## = max(-infinity, 0 - prices[i]) = -prices[i] continue dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) return dp[n - 1][max_k][0];  z2z23n0 提供 C++ 代码:\n第一题，k = 1\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = max(dp_i_1, -prices[i - 1]); } return dp_i_0; }  第二题，k = +infinity\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = std::max(dp_i_1, temp - prices[i - 1]); } return dp_i_0; }  第三题，k = +infinity with cooldown\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 int dp_i_0 = 0, dp_i_1 = INT_MIN; // 表示第(i-2)天的最大利润，并且未持有股票 int prev_dp_i_0 = 0; for (int i = 1; i \u0026lt;= n; i++) { // temp和prev_dp_i_0用来记录第(i-2)天(前天)的最大利润 int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = std::max(dp_i_1, prev_dp_i_0 - prices[i - 1]); prev_dp_i_0 = temp; } return dp_i_0; }  第四题，k = +infinity with fee\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 //tips:为什么不在卖股票的时候减掉transaction fee？因为在base case中， dp_i_1 == INT_MIN, INT_MIN + prices[i] - fee 可能会造成整型溢出 dp_i_1 = std::max(dp_i_1, temp - prices[i - 1] - fee); } return dp_i_0; }  第五题，k = 2\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int size = prices.size(); int max_k = 2; // i从1开始而不是0，这样可以使base case是 dp[0][0][0] 和 dp[0][0][1] 而不是 dp[-1][0][0] 或者 dp[-1][0] int dp[size + 1][max_k + 1][2]; // 初始化 for (int k = max_k; k \u0026gt;= 0; k--) { dp[0][k][0] = 0; dp[0][k][1] = INT_MIN; } for (int i = 1; i \u0026lt;= size; i++) { dp[i][0][0] = 0; dp[i][0][1] = INT_MIN; for (int k = max_k; k \u0026gt;= 1; k--) { dp[i][k][0] = std::max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i - 1]); dp[i][k][1] = std::max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i - 1]); } } return dp[size][max_k][0]; }  第六题，k = any integer\nint maxProfit(int k, vector\u0026lt;int\u0026gt; \u0026amp;prices) { int size = prices.size(); if (k \u0026gt; size / 2) { return maxProfitLimitless(prices); } // i从1开始而不是0，这样可以使base case是 dp[0][0][0] 和 dp[0][0][1] 而不是 dp[-1][0][0] 或者 dp[-1][0][1] int dp[size + 1][k + 1][2]; // 初始化 for (int j = k; j \u0026gt;= 0; j--) { dp[0][j][0] = 0; dp[0][j][1] = INT_MIN; } for (int i = 1; i \u0026lt;= size; i++) { dp[i][0][0] = 0; dp[i][0][1] = INT_MIN; for (int j = k; j \u0026gt;= 1; j--) { dp[i][j][0] = std::max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]); dp[i][j][1] = std::max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); } } return dp[size][k][0]; }  上一篇：动态规划之KMP字符匹配算法\n下一篇：团灭 LeetCode 打家劫舍问题\n目录\n","id":267,"section":"posts","summary":"团灭 LeetCode 股票买卖问题 很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫","tags":["dp"],"title":"团灭LC股票问题","uri":"https://foxisawesome.github.io/posts/%E5%9B%A2%E7%81%ADlc%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"LC 142 Linked List Cycle ii   Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n Solution 2020-09-11 Notes:\n 这题的algo就是：  slow 和 fast同时head起走，fast走两步，slow一步一回合。 要么fast走完return None，要么有环和slow相遇。 要是相遇，此时第三个指针从head，fast从相遇地点同时一步一回合，相遇点就是环的起点。   用到 fast.next.next时一定记住while condition里要有 fast.next  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def detectCycle(self, head: ListNode) -\u0026gt; ListNode: if not head: return None slow = fast = head count = 0 while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None while head != fast: count += 1 head = head.next fast = fast.next return head # Time O(N) # Space O(1)  ","id":268,"section":"posts","summary":"LC 142 Linked List Cycle ii Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Solution 2020-09-11 Notes: 这题的","tags":["leetcode","linkedlist"],"title":"142 Linked List Cycle ii","uri":"https://foxisawesome.github.io/posts/142-linked-list-cycle-ii/","year":"2020"},{"content":"LC 4 Median of Two Sorted Arrays   Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n Solution 2020-09-11 Notes:\n山景城一姐的做法一目了然！第一种用了merge sort，第二种做法是binary search较短的array，time log(M)\n漂亮！漂亮！\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u0026gt; float: n1 = len(nums1) n2 = len(nums2) if n1 \u0026gt; n2: return self.findMedianSortedArrays(nums2, nums1) n = n1 + n2 l, r = 0, n1 while l \u0026lt;= r: m1 = l + (r-l)//2 m2 = (n+1)//2 - m1 l1 = -float('inf') if m1==0 else nums1[m1-1] l2 = -float('inf') if m2==0 else nums2[m2-1] r1 = float('inf') if m1==n1 else nums1[m1] r2 = float('inf') if m2==n2 else nums2[m2] if l1 \u0026gt; r2: r = m1-1 elif l2 \u0026gt; r1: l = m1+1 elif n % 2 == 0: return (max(l1,l2) + min(r1, r2))/2 elif n % 2 == 1: return max(l1,l2) return -1 # Time(logM) # Space(1)  2020-08-19 Notes:\n根据花花酱的做法写的。。。实在是被说的太复杂了，估计面试时根本hold不住\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u0026gt; float: n1 = len(nums1) n2 = len(nums2) if n1 \u0026gt; n2: return self.findMedianSortedArrays(nums2, nums1) k = (n1+n2+1) // 2 #left median l, r = 0, n1-1 while l \u0026lt;= r: m1 = l + (r-l)//2 m2 = k- m1 if nums1[m1] \u0026lt; nums2[m2-1]: l = m1 + 1 elif nums1[m1] \u0026gt;= nums2[m2-1]: r = m1 - 1 m1 = l m2 = k - m1 print(m1,m2) c1 = max(-float('inf') if m1\u0026lt;=0 else nums1[m1-1], -float('inf') if m2 \u0026lt;=0 else nums2[m2-1]) if (n1 + n2) % 2 == 1: return c1 c2 = min(float('inf') if m1 \u0026gt;= n1 else nums1[m1], float('inf') if m2 \u0026gt;= n2 else nums2[m2]) if (n1 + n2) % 2 == 0: return (c1+c2)/2 # Time O(log(M+N)) # Space O(1)  ","id":269,"section":"posts","summary":"LC 4 Median of Two Sorted Arrays Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Solution 2020-09-11 Notes: 山景城一姐的做法一目了然！第一种用了merge sort，第二种做法是binar","tags":["leetcode","binary_search"],"title":"4 Median of Two Sorted Arrays","uri":"https://foxisawesome.github.io/posts/4-median-of-two-sorted-arrays/","year":"2020"},{"content":"original labuladong post\n先给大家讲个笑话乐呵一下：\n有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。\n从此，图书馆丢了 N - 1 本书。\n二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：思路很简单，细节是魔鬼。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 \u0026lt;= 还是 \u0026lt;。\n你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。\n本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。\n零、二分查找框架 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u0026lt; target) { left = ... } else if (nums[mid] \u0026gt; target) { right = ... } } return ...; }  分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。\n其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。\n另外声明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。\n一、寻找一个数（基本的二分搜索） 这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。\nint binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; // 注意 else if (nums[mid] \u0026gt; target) right = mid - 1; // 注意 } return -1; }  1、为什么 while 循环的条件中是 \u0026lt;=，而不是 \u0026lt;？\n答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。\n我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。\n什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：\nif(nums[mid] == target) return mid;  但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。\nwhile(left \u0026lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。\nwhile(left \u0026lt; right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。\n当然，如果你非要用 while(left \u0026lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：\n//... while(left \u0026lt; right) { // ... } return nums[left] == target ? left : -1;  2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？\n答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？\n当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。\n3、此算法有什么缺陷？\n答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。\n比如说给你有序数组 nums = [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。\n这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。\n我们后续的算法就来讨论这两种二分查找的算法。\n二、寻找左侧边界的二分搜索 以下是最常见的代码形式，其中的标记是需要注意的细节：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; // 注意 } } return left; }  1、为什么 while 中是 \u0026lt; 而不是 \u0026lt;=?\n答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\nwhile(left \u0026lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。\nPS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的 right 不是 nums.length - 1 吗，为啥这里非要写成 nums.length 使得「搜索区间」变成左闭右开呢？\n因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。\n2、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：\n对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。\n比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。\n再比如说 nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。\n综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：\nwhile (left \u0026lt; right) { //... } // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1;  3、为什么 left = mid + 1，right = mid ？和之前的算法不一样？\n答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。\n4、为什么该算法能够搜索左侧边界？\n答：关键在于对于 nums[mid] == target 这种情况的处理：\nif (nums[mid] == target) right = mid;  可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n5、为什么返回 left 而不是 right？\n答：都是一样的，因为 while 终止的条件是 left == right。\n6、能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。\n答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：\n因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 \u0026lt;=：\nint left_bound(int[] nums, int target) { // 搜索区间为 [left, right] int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // if else ... }  因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下：\nif (nums[mid] \u0026lt; target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u0026gt; target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; }  由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界：\n因此，最后返回结果的代码应该检查越界情况：\nif (left \u0026gt;= nums.length || nums[left] != target) return -1; return left;  至此，整个算法就写完了，完整代码如下：\nint left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; // 搜索区间为 [left, right] while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u0026gt; target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } } // 检查出界情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; }  这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。\n三、寻找右侧边界的二分查找 类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：\nint right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; } } return left - 1; // 注意 }  1、为什么这个算法能够找到右侧边界？\n答：类似地，关键点还是这里：\nif (nums[mid] == target) { left = mid + 1;  当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。\n2、为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。\n答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。\n至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：\nif (nums[mid] == target) { left = mid + 1; // 这样想: mid = left - 1  因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。\n至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。\n3、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：\nwhile (left \u0026lt; right) { // ... } if (left == 0) return -1; return nums[left-1] == target ? (left-1) : -1;  4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。\n答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：\nint right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 这里改为检查 right 越界的情况，见下图 if (right \u0026lt; 0 || nums[right] != target) return -1; return right; }  当 target 比所有元素都小时，right 会被减到 -1，所以需要在最后防止越界：\n至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？\n四、逻辑统一 来梳理一下这些细节差异的因果逻辑：\n第一个，最基本的二分查找算法：\n因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u0026lt;= right) 同时也决定了 left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回  第二个，寻找左侧边界的二分查找：\n因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界  第三个，寻找右侧边界的二分查找：\n因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一  对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：\nint binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right \u0026lt; 0 || nums[right] != target) return -1; return right; }  如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。\n通过本文，你学会了：\n1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。\n2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。\n3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。\n4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。\n呵呵，此文对二分查找的问题无敌好吧！致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\n上一篇：回溯算法解题框架\n下一篇：滑动窗口解题框架\n目录\n","id":270,"section":"posts","summary":"original labuladong post 先给大家讲个笑话乐呵一下： 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿","tags":["binary_search"],"title":"二分查找详解","uri":"https://foxisawesome.github.io/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/","year":"2020"},{"content":"LC 829 Consecutive Numbers Sum   Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers?\nInput: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5   Solution 2020-09-11 Notes:\n  以为又是backtracking的解法呢。\n  一个数$N$能分解成连续自然数之和，就可以分解为: $$ N = a*k + (k+1)*k/2 $$ Where $a$ is a integer.\nupper bound comes from a\u0026gt;=0.\n  此题最大亮点是解答中这句话：\n The best way to solve this problem is to run Shor\u0026rsquo;s Algorithm on the quantum computer, that requires $\\mathcal{O}(\\log^2 N \\log \\log N \\log \\log \\log N)$ time. If there is no quantum computer in the interview room, just use classical GNFS Algorithm, which runs in a decent $\\mathcal{O}(e^{\\log^{1/3} N (\\log \\log N)^{2/3}})$time.\n   class Solution: def consecutiveNumbersSum(self, N: int) -\u0026gt; int: count = 0 upper = ceil((2*N +0.25)**0.5-0.5) for k in range(1, upper+1): if (N- k*(k+1)//2 ) % k == 0: count += 1 return count # Time O(sqrt(N)) # Space O(1)  ","id":271,"section":"posts","summary":"LC 829 Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Solution 2020-09-11 Notes: 以为又是backtrackin","tags":["leetcode","math"],"title":"829 Consecutive Numbers Sum","uri":"https://foxisawesome.github.io/posts/829-consecutive-numbers-sum/","year":"2020"},{"content":"LC 197 Rising Temperature   Write an SQL query to find all dates' id with higher temperature compared to its previous dates (yesterday).\nWeather +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ Result table: +----+ | id | +----+ | 2 | | 4 | +----+   Solution 2020-09-11 Notes:\nwindow function solution:\nSELECT DISTINCT id FROM( SELECT *, LAG(recorddate,1) OVER(ORDER BY recorddate) as LD, LAG(temperature,1) OVER(ORDER BY recorddate) as LT FROM weather ) a WHERE DATEDIFF(recorddate, ld) = 1 and temperature \u0026gt; LT  Self join solution:\nSELECT DISTINCT a.id FROM weather a JOIN weather b WHERE DATEDIFF(a.recorddate, b.recorddate) = 1 AND a.temperature \u0026gt; b.temperature  ","id":272,"section":"posts","summary":"LC 197 Rising Temperature   Write an SQL query to find all dates' id with higher temperature compared to its previous dates (yesterday).\nWeather +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ Result table: +----+ | id | +----+ | 2 | | 4 | +----+   Solution 2020-09-11 Notes:","tags":["leetcode"],"title":"197 Rising Temperature","uri":"https://foxisawesome.github.io/posts/197-rising-temperature/","year":"2020"},{"content":"LC 184 Department Highest Salary   The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\n+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+  The Department table holds all departments of the company.\n+----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+  Write a SQL query to find employees who have the highest salary in each of the departments. For the above tables, your SQL query should return the following rows (order of rows does not matter).\n+------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Jim | 90000 | | Sales | Henry | 80000 | +------------+----------+--------+   Solution 2020-09-11 Notes:\nSELECT department, employee, salary FROM ( SELECT a.name AS employee, departmentid, b.name AS department, salary, RANK() OVER(PARTITION BY departmentid ORDER BY salary DESC) as rk FROM employee a JOIN department b ON a.departmentid = b.id ) c WHERE c.rk = 1  ","id":273,"section":"posts","summary":"LC 184 Department Highest Salary   The Employee table holds all employees. Every employee has an Id, a salary, and there is also a column for the department Id.\n+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+  The Department table holds all departments of the company.","tags":["leetcode"],"title":"184 Department Highest Salary","uri":"https://foxisawesome.github.io/posts/184-department-highest-salary/","year":"2020"},{"content":"LC 182 Duplicate Emails   Write a SQL query to find all duplicate emails in a table named Person.\n+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+  For example, your query should return the following for the above table:\n+---------+ | Email | +---------+ | a@b.com | +---------+   Solution 2020-09-10 Notes:\n Self join: where a.id \u0026gt; b.id  SELECT DISTINCT a.email FROM person a JOIN person b WHERE a.id \u0026gt; b.id AND a.email=b.email  ","id":274,"section":"posts","summary":"LC 182 Duplicate Emails   Write a SQL query to find all duplicate emails in a table named Person.\n+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+  For example, your query should return the following for the above table:\n+---------+ | Email | +---------+ | a@b.com | +---------+   Solution 2020-09-10 Notes:","tags":["leetcode"],"title":"182 Duplicate Emails","uri":"https://foxisawesome.github.io/posts/182-duplicate-emails/","year":"2020"},{"content":"LC 178 Rank Scores   Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \u0026ldquo;holes\u0026rdquo; between ranks.\n+----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+  For example, given the above Scores table, your query should generate the following report (order by highest score):\n+-------+---------+ | score | Rank | +-------+---------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+---------+  Important Note: For MySQL solutions, to escape reserved words used as column names, you can use an apostrophe before and after the keyword. For example Rank.\n Solution 2020-09-10 Notes:  DENSE_RANK() 的解法比COUNT(DISTINCT)的解法要快一倍。window function更高效。 好几天不刷SQL又手生了。。。  SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as 'rank' FROM scores ORDER BY 2  sub query的写法，效率慢。\nSELECT score, (SELECT COUNT(DISTINCT score) FROM scores WHERE score \u0026gt;= a.score) as 'rank' FROM scores a ORDER BY 2  ","id":275,"section":"posts","summary":"LC 178 Rank Scores Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \u0026ldquo;holes\u0026rdquo; between ranks. +----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3","tags":["leetcode"],"title":"178 Rank Scores","uri":"https://foxisawesome.github.io/posts/178-rank-scores/","year":"2020"},{"content":"LC 312 Burst Balloons   Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nInput: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --\u0026gt; [3,5,8] --\u0026gt; [3,8] --\u0026gt; [8] --\u0026gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167   Solution 2020-09-10 Notes:\n幼稚的一刷，能解对但是ETL. 用了memo：\n [1] +nums+[1] 小trick可以简化边界条件。 track 区间的index应该能优化不少。  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() return self.dfs(nums) def dfs(self, nums): if not nums: return 0 if str(nums) in self.memo: return self.memo[str(nums)] temp = [] nums = [1] + nums + [1] n = len(nums) for i in range(1,n-1): new_nums = nums[1:i]+nums[i+1:n-1] temp.append(nums[i]*nums[i-1]*nums[i+1] + self.dfs(new_nums)) self.memo[str(nums)] = max(temp) return self.memo[str(nums)] # Time O(N!) # Space O()  看了答案，优化了一下：\n最关键的公式是：nums[i-1]*nums[k]*nums[j+1]: 含义如下\n Dfs(i,j) return 的是刺破[i,j]区间上所有气球后得到的最大值，前提是区间上所有气球都破了。 在[i,j]区间上，假设 [i,k-1], 和 [k+1,j] 已经被最优刺破，那么剩下的最后一个k-th 气球被刺破时，值就为nums[i-1]*nums[k]*nums[j+1]。是top-down的recursion。 labuladong 提供了相同解释  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() nums = [1] + nums + [1] return self.dfs(nums,1,len(nums)-2) def dfs(self, nums, i, j): if not nums: return 0 if (i,j) in self.memo: return self.memo[(i,j)] ans = 0 for k in range(i,j+1): ans = max(ans, self.dfs(nums,i,k-1) + nums[i-1]*nums[k]*nums[j+1] + self.dfs(nums,k+1,j)) self.memo[(i,j)] = ans return self.memo[(i,j)] # Time O(N^3) # Space O(N^2)  ","id":276,"section":"posts","summary":"LC 312 Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum","tags":["leetcode","dp","recursion"],"title":"312 Burst Balloons","uri":"https://foxisawesome.github.io/posts/312-burst-balloons/","year":"2020"},{"content":"LC 110 Balanced Binary Tree   Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\n a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n Given the following tree [3,9,20,null,null,15,7]:Return true.\n 3 / \\ 9 20 / \\ 15 7  Given the following tree [1,2,2,3,3,null,null,4,4]:Return false.\n 1 / \\ 2 2 / \\ 3 3 / \\ 4 4   Solution 2020-09-10 Notes:  Time complexity is O(NlogN), 这个花花讲了原因不是很懂 其实isBalance()输出的时 需要判断left child and right child if existed.否则左右是两条单链的情况不能过。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True l = self.treeHeight(root.left) r = self.treeHeight(root.right) return (abs(l-r) \u0026lt; 2) and self.isBalanced(root.left) and self.isBalanced(root.right) def treeHeight(self,root): if not root: return 0 l = self.treeHeight(root.left) r = self.treeHeight(root.right) return max(l,r) + 1 # Time O(NlogN) # Space O(H)  ","id":277,"section":"posts","summary":"LC 110 Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Given the following tree [3,9,20,null,null,15,7]:Return true. 3 / \\ 9 20 / \\ 15 7 Given the following tree [1,2,2,3,3,null,null,4,4]:Return false. 1 / \\ 2","tags":["leetcode","tree"],"title":"110 Balanced Binary Tree","uri":"https://foxisawesome.github.io/posts/110-balanced-binary-tree/","year":"2020"},{"content":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.   Solution 2020-09-10 Notes:\n Pretty similar to symetric tree. need to judge flipping or not flipping cases  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: TreeNode, root2: TreeNode) -\u0026gt; bool: if not root1 and not root2: return True if not root1 or not root2: return False # flipping l1 = self.flipEquiv(root1.left, root2.right) r1 = self.flipEquiv(root1.right, root2.left) # not flipping l2 = self.flipEquiv(root1.left, root2.left) r2 = self.flipEquiv(root1.right, root2.right) return root1.val == root2.val and ((l1 and r1) or (l2 and r2)) # Time O(N) # Space O(logN)  ","id":278,"section":"posts","summary":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.","tags":["leetcode","tree"],"title":"951 Flip Equivalent Binary Trees","uri":"https://foxisawesome.github.io/posts/951-flip-equivalent-binary-trees/","year":"2020"},{"content":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case. need to create a mirror() with two arguments.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSymmetric_recur(self, root: TreeNode) -\u0026gt; bool: if not root: return True return self.mirror(root.left, root.right) def mirror(self, r1, r2): if not r1 and not r2: return True if not r1 or not r2: return False outer = self.mirror(r1.left, r2.right) inner = self.mirror(r1.right, r2.left) return r1.val==r2.val and outer and inner def isSymmetric_iter(self, root: TreeNode) -\u0026gt; bool: if not root: return True stack = [] stack.append((root.left, root.right)) while stack: l, r = stack.pop() if not l and not r: continue if not l or not r or l.val != r.val: return False stack.append((l.left, r.right)) stack.append((l.right,r.left)) return True # Time O(N) # Space O(logN)  ","id":279,"section":"posts","summary":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case.","tags":["leetcode","tree"],"title":"101 Symmetric Tree","uri":"https://foxisawesome.github.io/posts/101-symmetric-tree/","year":"2020"},{"content":"LC 100 Same Tree   Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\n Solution 2020-09-09 Notes:\n Two roots 的pattern 和 single root一样。Tree 刷的略有感觉了！  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: if not p and not q: return True if not p or not q: return False l = self.isSameTree(p.left, q.left) r = self.isSameTree(p.right, q.right) return p.val == q.val and l and r # Time O(N) # Space O(logN)  ","id":280,"section":"posts","summary":"LC 100 Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Solution 2020-09-09 Notes: Two roots 的pattern 和 single root一样。Tree 刷的略有感","tags":["leetcode","tree"],"title":"100 Same Tree","uri":"https://foxisawesome.github.io/posts/100-same-tree/","year":"2020"},{"content":"LC 112 Path Sum   Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1  return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\n Solution 2020-09-09 Notes:  recursion 可以把pathSm()合并到主函数，因为input，output都一致。但我还是刷出来了！😊。 每一层传入的是 target-root.val, 穿出的是left bool or right bool 领悟是if not root: return None (or False in this case)是default，肯定要的。 iteration的做法在第二部分。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum_recur(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False return self.pathSum(root, sum) def pathSum(self, root, target): if not root: return if not root.left and not root.right: return root.val == target l = self.pathSum(root.left, target - root.val) r = self.pathSum(root.right, target - root.val) return l or r # Time O(N) # Space O(logN) def hasPathSum_iter(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False stack = [(root, root.val)] while stack: node, path = stack.pop() if not node.left and not node.right and path == sum: return True if node.left: stack.append((node.left, path + node.left.val)) if node.right: stack.append((node.right, path + node.right.val)) return False # Time O(N) # Space O(N)  ","id":281,"section":"posts","summary":"LC 112 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum","tags":["leetcode","tree"],"title":"112 Path Sum","uri":"https://foxisawesome.github.io/posts/112-path-sum/","year":"2020"},{"content":"LC 104 Maximum Depth of Binary Tree   Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-09-09 Notes:\n 注意patterns. Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.maxDepth(root.left) r = self.maxDepth(root.right) return max(l,r)+1 # Time O(N) # Space: best scenario O(H)=O(logN)  ","id":282,"section":"posts","summary":"LC 104 Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 Solution 2020-09-09 Notes: 注意patterns. Beat the TREE! # Definition for","tags":["leetcode","tree"],"title":"104 Maximum Depth of Binary Tree","uri":"https://foxisawesome.github.io/posts/104-maximum-depth-of-binary-tree/","year":"2020"},{"content":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.minDepth(root.left) r = self.minDepth(root.right) if not l and r: return r+1 if not r and l: return l+1 return min(l,r)+1 # Time O(N) # Space O(logN)  ","id":283,"section":"posts","summary":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node.","tags":["leetcode","tree"],"title":"111 Minimum Depth of Binary Tree","uri":"https://foxisawesome.github.io/posts/111-minimum-depth-of-binary-tree/","year":"2020"},{"content":"LC 124 Binary Tree Maximum Path Sum   Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nInput: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42   Solution 2020-09-09 Notes:\n 因为要online update ans，所以得要个helper()。helper() 返回的是 maxPathSum。 line #23: 是因为每条sub-path只能取左child或者右child中的较大path。   类似题: LC 543  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: TreeNode) -\u0026gt; int: self.ans = -float('inf') self.helperMax(root) return self.ans def helperMax(self, root): if not root: return 0 left = self.helperMax(root.left) right = self.helperMax(root.right) left = left if left \u0026gt; 0 else 0 right = right if right \u0026gt; 0 else 0 self.ans = max(self.ans, left+right+root.val) return root.val + max(left, right) # Time O(N) # Space O(H)  ","id":284,"section":"posts","summary":"LC 124 Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15","tags":["leetcode","tree"],"title":"124 Binary Tree Maximum Path Sum","uri":"https://foxisawesome.github.io/posts/124-binary-tree-maximum-path-sum/","year":"2020"},{"content":"LC 236 Lowest Common Ancestor of a Binary Tree   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n Solution 2020-09-09 Notes:  递归灵魂三问 (reference: labuladong)：  递归函数return的是什么？ 递归函数的arguments？ 如何利用递归函数的返回值？   part 1: 最底层返回条件，root== p 或 q时， 返回root。 这题底层就两种情况，啥也没找到 Null，找到p, q，就不再开新的recursion， 直接返回p, q。 part 2: 固定的binary tree recursion模版 part 3: 此处是post-order, 返回值的利用，就三种情况：a. p, q 同时都在root里, 那么root就是LCA, 把这个LCA一层层返回上去。 b. p,q 都不在root里, 返回None。c. p,q 其一在root里，那个层层返回p 或 q 的这两个单独节点，直到他们相遇的root才是LCA。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u0026gt; 'TreeNode': # part 1 if root is None: return None if root == p or root == q: return root # part 2 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # part 3 if left and right: return root if not left and not right: return None return left if left else right # Time O(N) # Space O(?)  ","id":285,"section":"posts","summary":"LC 236 Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be","tags":["leetcode","tree"],"title":"236 Lowest Common Ancestor of a Binary Tree","uri":"https://foxisawesome.github.io/posts/236-lowest-common-ancestor-of-a-binary-tree/","year":"2020"},{"content":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:  O(N) is easy.  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: l = 0 out = '' for i in s: while l \u0026lt; len(t): if t[l]==i: out += t[l] l +=1 break l += 1 return out == s # Time O(M), M:len(t) # Space O(1)   the follow-up of this questions: while s\u0026raquo;t, O(N) is not satisfied. here is O(MlogN) solution using binary search is pretty hard to think of:  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: d = dict() for i, val in enumerate(t): if val not in d: d[val] = [i] else: d[val].append(i) tar = 0 for i, val in enumerate(s): if val not in d: return False pos = self.leftBound(d[val],tar) if pos == len(d[val]): return False tar = d[val][pos] + 1 return True def leftBound(self, idx_ls, p): l, r = 0, len(idx_ls) while l \u0026lt; r: m = l + (r-l)//2 if idx_ls[m] \u0026lt; p: l = m + 1 elif idx_ls[m] \u0026gt;= p: r = m return l # Time O(MlogN), N:len(s), M:len(t) # Space O(M)  ","id":286,"section":"posts","summary":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:  O(N) is easy.","tags":["leetcode","binary_search"],"title":"392 Is Subsequence","uri":"https://foxisawesome.github.io/posts/392-is-subsequence/","year":"2020"},{"content":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","id":287,"section":"posts","summary":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"268 Missing Number","uri":"https://foxisawesome.github.io/posts/268-missing-number/","year":"2020"},{"content":"LC 645 Set Mismatch   The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n Solution 2020-09-08 Notes:\n 可以直接算出来， sum(1-n) - sum(set(nums)) 也可以用hash table的思想构造 count dict 来做， one-pass。要真用dict() 得two-pass了。还得pass一边dictionary。  class Solution: def findErrorNums(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) h = [0]*n for i in range(n): h[nums[i]-1] += 1 return [h.index(2)+1, h.index(0)+1] # Time O(N) # Space O(N)  ","id":288,"section":"posts","summary":"LC 645 Set Mismatch The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number","tags":["leetcode","hashtable"],"title":"645 Set Mismatch","uri":"https://foxisawesome.github.io/posts/645-set-mismatch/","year":"2020"},{"content":"LC 234 Palindrome Linked List   Given a singly linked list, determine if it is a palindrome.\n Solution 2020-09-08 Notes:   Recursion solution参考了 labuladong\n  以下是一种比较直观但是不是optimal的解法\n  line 13 is a post-order traverse.\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: ListNode) -\u0026gt; bool: self.left = head return self.traverse(head) def traverse(self, right): if not right: return True res = self.traverse(right.next) res = res and right.val ==self.left.val self.left = self.left.next return res # Time O(N) # Space O(?)  ","id":289,"section":"posts","summary":"LC 234 Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Solution 2020-09-08 Notes: Recursion solution参考了 labuladong 以下是一种比较直观但是不是optimal的解法 line 13 is a post-order traverse. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"234 Palindrome Linked List","uri":"https://foxisawesome.github.io/posts/234-palindrome-linked-list/","year":"2020"},{"content":"LC 325 Maximum Size Subarray Sum Equals K   Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead.\nInput: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.   Solution 2020-09-08 Notes:\n 此题解法跟 LC560 一摸一样。用cumulative + hash table 的one-pass O(N). 因为hash table需要用来存nums的index dict()的value 需要是list  class Solution: def maxSubArrayLen(self, nums: List[int], k: int) -\u0026gt; int: if not nums: return 0 d = collections.defaultdict(list) cum_sum = 0 d[0].append(0) n = len(nums) ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans = max(ans, i-min(d[target_sum])+1) d[cum_sum].append(i+1) return ans # Time O(N) # Space O(N)  ","id":290,"section":"posts","summary":"LC 325 Maximum Size Subarray Sum Equals K Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead. Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Solution 2020-09-08 Notes: 此题解法跟","tags":["leetcode","array","hashtable"],"title":"325 Maximum Size Subarray Sum Equals K","uri":"https://foxisawesome.github.io/posts/325-maximum-size-subarray-sum-equals-k/","year":"2020"},{"content":"LC 560 Subarray Sum Equals K   Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\nInput:nums = [1,1,1], k = 2 Output: 2   Solution 2020-09-08 Notes:\n  看了labuladong 的总结\n  预先算一个cumulative sum 的dictionary，只要 cum_sum - k in d 那么 ans 就叠加次数。\n  需要dict记录frequency, (nums可能有0)。\n  FB 热门题\n  class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: d = dict() n = len(nums) cum_sum = 0 d[cum_sum] = 1 ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans += d[target_sum] d[cum_sum] = d.get(cum_sum,0) + 1 return ans # Time O(N) # Space O(1)  ","id":291,"section":"posts","summary":"LC 560 Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Input:nums = [1,1,1], k = 2 Output: 2 Solution 2020-09-08 Notes: 看了labuladong 的总结 预先算一个cumulativ","tags":["leetcode","array","hashtable"],"title":"560 Subarray Sum Equals K","uri":"https://foxisawesome.github.io/posts/560-subarray-sum-equals-k/","year":"2020"},{"content":"LC 1109 Corporate Flight Bookings   There are n flights, and they are labeled from 1 to n.\nWe have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive.\nReturn an array answer of length n, representing the number of seats booked on each flight in order of their label.\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25]   Solution 2020-09-08 Notes:\n 题目很绕口，核心是起点和终点之间的所有节点都会 carry over seats number。 用 labuladong的差分数列的算法只要 one-pass of booking array O(N). :  首先构造 diff_arr[i] = nums[i] - nums[i-1], where diff_arr[0] = nums[0] 这个操作 diff_arr[i] += val and diff_arr[j+1] -= val 就可以操作 nums[i], ..., nums[j] all +val. With corner case, if j+1 \u0026lt; len(nums):diff_arr[j+1] -= val  回复nums: nums[i] = diff_arr[i] + nums[i-1] 如此只要 one-pass 操作区间的节点就可以对整个数列进行多次计算，直接返回要求值。   类似的技术还有先计算 cumulative sum of nums 再操作，FB有很多热门题这么做。  class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u0026gt; List[int]: diff_arr = [0] * n # diff[i] = arr[i]- arrr[i-1] ans = [0] * n for book in bookings: i = book[0]-1 j = book[1]-1 seat = book[2] diff_arr[i] += seat if j+1 \u0026lt; n: diff_arr[j+1] -= seat ans[0] = diff_arr[0] for i in range(1,n): ans[i] = diff_arr[i] + ans[i-1] return ans # Time O(N) # Space O(N)  ","id":292,"section":"posts","summary":"LC 1109 Corporate Flight Bookings There are n flights, and they are labeled from 1 to n. We have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label. Input: bookings = [[1,2,10],[2,3,20],[2,5,25]],","tags":["leetcode","array"],"title":"1109 Corporate Flight Bookings","uri":"https://foxisawesome.github.io/posts/1109-corporate-flight-bookings/","year":"2020"},{"content":"LC 1539 Kth Missing Positive Number   Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nInput: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.   Solution 2020-09-07 Notes:  O(N) solution is pretty easy, but not optimal. the binary solution is optimal.  arr[i]-(i+1): 返回的是 arr[i]和i+1 之间miss了几个数，如果arr没miss数，返回的因该是0. 所以这个条件和k比较可以快速找到最接近的位置。 我疏忽的是：这题是求k-th missing value 的起始左边界，以下是搜索左边界的标准做法。 Binary search而不是找 exact的 target (需要保证存在唯一解，才能用)，是搜索target的左边界，所以在binary search时单独例举 arr[i]-(i+1)==k 跳出会报错。应该合并 \u0026gt;=两种情况这种写法才对。 另外这题是 1-indexed，所以会有 i+1, l+k 这种小细节要搞清。    class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr) while l\u0026lt;r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m return l+k # 2nd way of writing this left boundary search. same results. def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr)-1 while l\u0026lt;=r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m - 1 return l+k # Time O(logN) # Space O(1)  class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: stack = [] if arr[-1] - len(arr) \u0026lt; k: return arr[-1]+(k-arr[-1]+len(arr)) elif arr[-1] - len(arr) \u0026gt;= k: stack = [i for i in range(1, arr[-1]+1)] [stack.remove(i) for i in arr] return stack[k-1] # Time O(N) # Space O(N)  ","id":293,"section":"posts","summary":"LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary","tags":["leetcode","binary_Search"],"title":"1539 Kth Missing Positive Number","uri":"https://foxisawesome.github.io/posts/1539-kth-missing-positive-number/","year":"2020"},{"content":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:  One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","id":294,"section":"posts","summary":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:  One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","tags":["leetcode","hashtable"],"title":"1512 Number of Good Pairs","uri":"https://foxisawesome.github.io/posts/1512-number-of-good-pairs/","year":"2020"},{"content":"SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.\nHere is an example that shows how to compare each employee\u0026rsquo;s salary with the average salary in his or her department:\nSELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary; depname | empno | salary | avg -----------+-------+--------+------ develop | 11 | 5200 | 5020 develop | 7 | 4200 | 5020 develop | 9 | 4500 | 5020 develop | 8 | 6000 | 5020 develop | 10 | 5200 | 5020 personnel | 5 | 3500 | 3700 personnel | 2 | 3900 | 3700 sales | 3 | 4800 | 4866 sales | 1 | 5000 | 4866 sales | 4 | 4800 | 4866 (10 rows)  The first three output columns come directly from the table empsalary, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same depname value as the current row. (This actually is the same function as the regular avg aggregate function, but the OVER clause causes it to be treated as a window function and computed across an appropriate set of rows.)\nA window function call always contains an OVER clause directly following the window function\u0026rsquo;s name and argument(s). This is what syntactically distinguishes it from a regular function or aggregate function. The OVER clause determines exactly how the rows of the query are split up for processing by the window function. The PARTITION BY list within OVER specifies dividing the rows into groups, or partitions, that share the same values of the PARTITION BY expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.\nYou can also control the order in which rows are processed by window functions using ORDER BY within OVER. (The window ORDER BY does not even have to match the order in which the rows are output.) Here is an example:\nSELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary; depname | empno | salary | rank -----------+-------+--------+------ develop | 8 | 6000 | 1 develop | 10 | 5200 | 2 develop | 11 | 5200 | 2 develop | 9 | 4500 | 4 develop | 7 | 4200 | 5 personnel | 2 | 3900 | 1 personnel | 5 | 3500 | 2 sales | 1 | 5000 | 1 sales | 4 | 4800 | 2 sales | 3 | 4800 | 2 (10 rows)  As shown here, the rank function produces a numerical rank within the current row\u0026rsquo;s partition for each distinct ORDER BY value, in the order defined by the ORDER BY clause. rank needs no explicit parameter, because its behavior is entirely determined by the OVER clause.\n==The rows considered by a window function are those of the \u0026ldquo;virtual table\u0026rdquo; produced by the query\u0026rsquo;s FROM clause as filtered by its WHERE, GROUP BY, and HAVING clauses if any==. For example, a row removed because it does not meet the WHERE condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways by means of different OVER clauses, but they all act on the same collection of rows defined by this virtual table.\nWe already saw that ORDER BY can be omitted if the ordering of rows is not important. It is also possible to omit PARTITION BY, in which case there is just one partition containing all the rows.\nThere is another important concept associated with window functions: for each row, there is a set of rows within its partition called its window frame. Many (but not all) window functions act only on the rows of the window frame, rather than of the whole partition. By default, if ORDER BY is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the ORDER BY clause. When ORDER BY is omitted the default frame consists of all rows in the partition. [1] Here is an example using sum:\nSELECT salary, sum(salary) OVER () FROM empsalary; salary | sum --------+------- 5200 | 47100 5000 | 47100 3500 | 47100 4800 | 47100 3900 | 47100 4200 | 47100 4500 | 47100 4800 | 47100 6000 | 47100 5200 | 47100 (10 rows)  Above, since there is no ORDER BY in the OVER clause, the window frame is the same as the partition, which for lack of PARTITION BY is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an ORDER BY clause, we get very different results:\nSELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; salary | sum --------+------- 3500 | 3500 3900 | 7400 4200 | 11600 4500 | 16100 4800 | 25700 4800 | 25700 5000 | 30700 5200 | 41100 5200 | 41100 6000 | 47100 (10 rows)  Here the sum is taken from the first (lowest) salary up through the current one, ==including any duplicates of the current one (notice the results for the duplicated salaries)==.\nWindow functions are permitted only in the SELECT list and the ORDER BY clause of the query. ==They are forbidden elsewhere, such as in GROUP BY, HAVING and WHERE clauses. This is because they logically execute after the processing of those clauses.== ==Also, window functions execute after regular aggregate functions.== This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.\nIf there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:\nSELECT depname, empno, salary, enroll_date FROM (SELECT depname, empno, salary, enroll_date, rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos FROM empsalary ) AS ss WHERE pos \u0026lt; 3;  The above query only shows the rows from the inner query having rank less than 3.\nWhen a query involves multiple window functions, it is possible to write out each one with a separate OVER clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a WINDOW clause and then referenced in OVER. For example:\nSELECT sum(salary) OVER w, avg(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);  Some functions   ROUND(var,2)\n  IFNULL(var,0)\n  COUNT(*) is all rows in the table, COUNT(Expression) is where the expression is non-null only.\n  DATEDIFF(date1, date2)=1`: date1 - date2 = 1 day, datediff(curdate(), data_var) \u0026lt;= 7\n  date should use purchase_date between start_date and end_date instead of start_date\u0026lt;= purchase_date \u0026lt;=end_date (see LC1251)\n  When you add an order by to an aggregate used as a window function that aggregate turns into a \u0026ldquo;running count\u0026rdquo; (or whatever aggregate you use). link\n  The count(*) will return the number of rows up until the \u0026ldquo;current one\u0026rdquo; based on the order specified.\n  SUM(case when status='start' then 1 else 0 end) OVER(ORDER BY time): to add a sessionId to this table.\n warehouse status units time sessionID xyz start 1 01:00:00 1 xyz add 2 02:00:00 1 xyz add 1 03:00:00 1 xyz complete null 04:00:00 1 xyz start 3 05:00:00 2 xyz add 2 06:00:00 2 xyz complete null 07:00:00 2      2020-07-16 to 2020-07 LEFT(trans_date, 7) AS month or DATE_FORMAT(trans_date, '%Y-%m') AS month\n  The only difference between Union and Union All is that ==Union All will not removes duplicate rows or records==, instead, it just selects all the rows from all the tables which meets the conditions of your specifics query and combines them into the result table.\n  group_concat() : LC 1484\nActivities table: +------------+-------------+ | sell_date | product | +------------+-------------+ | 2020-05-30 | Headphone | | 2020-06-01 | Pencil | | 2020-06-02 | Mask | | 2020-05-30 | Basketball | | 2020-06-01 | Bible | | 2020-06-02 | Mask | | 2020-05-30 | T-Shirt | +------------+-------------+ Result table: +------------+----------+------------------------------+ | sell_date | num_sold | products | +------------+----------+------------------------------+ | 2020-05-30 | 3 | Basketball,Headphone,T-shirt | | 2020-06-01 | 2 | Bible,Pencil | | 2020-06-02 | 1 | Mask | +------------+----------+------------------------------+ select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product asc separator ',') as products from activities group by sell_date order by sell_date    Common Table Expressions (CTE) WITH cte1 AS (SELECT a, b FROM table1), cte2 AS (SELECT c, d FROM table2) SELECT b, d FROM cte1 JOIN cte2 WHERE cte1.a = cte2.c;  Aggregation Function  LC585: Investments in 2016\nWrite a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria:\n Have the same TIV_2015 value as one or more other policyholders (none unique tiv_2015). Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).   select sum(TIV_2016) as TIV_2016 from insurance where TIV_2015 in (select TIV_2015 from insurance group by TIV_2015 having sum(1)\u0026gt;1) and pid in (select pid from insurance group by CONCAT(lat, lon) having sum(1) \u0026lt; 2)   LC 1369: Get the Second Most Recent Activity: Write an SQL query to show the second most recent activity of each user. If the user only has one activity, return that one. A user can\u0026rsquo;t perform more than one activity at the same time. Return the result table in any order.\n select username, activity, startDate, endDate from ( select *, count(activity) over(partition by username) ct, row_number() over(partition by username order by startdate desc) nb_act from UserActivity ) a where a.ct \u0026lt; 2 or nb_act=2  Rank Scores  LC178: Rank Scores Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \u0026ldquo;holes\u0026rdquo; between ranks.\n # dense_rank() solution (faster): select score, dense_rank() over(order by score desc) as rank from scores order by rank desc # rank algo solution: select score, (select count(distinct score) from scores b where b.score\u0026gt;=a.score) as 'rank' from scores a order by 'rank'   LC 185: Department Top Three Salaries Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).\n select b.name as Department, a.name as Employee, a.Salary from employee a inner join department b on a.departmentID = b.id where 3 \u0026gt;= ( select count(distinct c.salary) from employee c where c.salary \u0026gt;= a.salary and c.departmentid = a.departmentid )   LC 1355. Activity Participants: Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants.\n select activity from ( select activity, dense_rank() over(order by count(id) desc) as rank_desc, dense_rank() over(order by count(id)) as rank_asc from friends group by activity ) a where a.rank_desc != 1 and a.rank_asc != 1  Rolling window, cumulative sum  LC 579. Find Cumulative Salary of an Employee: Write a SQL to get the cumulative sum of an employee\u0026rsquo;s salary over a period of 3 months but exclude the most recent month.\n select id, month, sum(salary) over(partition by id order by month rows 2 preceding) as salary from employee a where a.month \u0026lt; (select max(month) from employee where id = a.id) order by id, month desc;  Note:\n sum(salary) over(partition by id order by month) gives cumulative sum for each id. sum() over(XXX rows 2 preceding) gives a rolling window for sum over only 3 months. or sum(salary) over(order by date desc rows between 2 preceding and current row) where a.month \u0026lt; (select max(month) from employee where id = a.id) this excludes the most recent month row for each id.  Rolling Average  hive rolling average when some days missing: I am working with hive on huge dataset and trying rolling average for past one week with missing dates in the input table.\n select date, volume, avg(volume) over(order by date rows between 6 preceding and current row) as row7_avg, avg(volume) over(order by date range between 6 preceding and current row) as moving_avg, sum(volume) over(order by date range between 6 preceding and current row)/7 as avg_weekly from job_history  notes:\n ==range between== will account for missing dates row between will skip missing dates, just going back 6 rows avg() will skip rows not showing up in the table. one should use sum()/7 to account for weekly avg.  Lead function  LC 1454. Active Users:Write an SQL query to find the id and the name of active users. Active users are those who logged in to their accounts for 5 or more consecutive days. Return the result table ordered by the id.\n select distinct a.id, a.name from accounts a join ( select id, login_date, lead(login_date,4) over(partition by id order by login_date) as lead_date from (select distinct id, login_date from logins) c ) b on a.id = b.id where datediff(lead_date, login_date) = 4 order by 1  Note:\n lead(date) need to accompany with partition by and order by same time in line 5 consecutive algo is using lead() with datediff() in line 9  Self Join no duplicates  What we have: [A1, A2, A3, B1, B2, C1, C2]. what to archive: [A1 A2, A1 A3, A2 A3, B1 B2, C1 C2]\n SELECT mytable.*, self.* FROM mytable INNER JOIN mytable AS self ON (mytable.letter = self.letter and mytable.number \u0026gt; self.number)  Notes: self join use inner join, mytable.number \u0026gt; self.number do not use != to avoid duplicated rows.\n LC 182. Duplicate Emails:\n select distinct a.email from person a inner join person b on a.id \u0026gt; b.id and a.email = b.email  Consecutive rows  LC 603. Consecutive Available Seats Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?\n select distinct a.seat_id from cinema a join cinema b on abs(a.seat_id - b.seat_id) = 1 and a.free = 1 and b.free = 1 order by a.seat_id  Note: 1. self join; 2. id - 1, id + 1\nSome good excises  LC 626. Exchange Seats: Mary is a teacher in a middle school and she has a table seat storing students' names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary?\n # solution 1 select case when mod(id, 2) != 0 and counts != id then id +1 when mod(id, 2) != 0 and counts = id then id else id - 1 end as id, student from seat, (select count(*) as counts from seat) as seat_counts order by id; # solution 2 SELECT s1.id, s2.student FROM seat s1, seat s2 WHERE (CASE WHEN s1.id%2 = 1 AND s1.id = (SELECT MAX(id) FROM seat) THEN s1.id = s2.id WHEN s1.id%2=0 THEN s1.id = s2.id + 1 ELSE s2.id = s1.id +1 END) ORDER BY s1.id;  Note: from a, b is a implicit join, one should put on condition in where clause. if no join condition specified, then it is a cartesian join.\nOuter join  We have two tables. One table has all mobile actions, i.e. all pages visited by the users on mobile. The other table has all web actions, i.e. all pages visited on web by the users.\nWrite a query that returns the percentage of users who only visited mobile, only web and both. That is, the percentage of users who are only in the mobile table, only in the web table and in both tables. The sum of the percentages should return 1.\n SELECT 100*SUM(CASE WHEN m.user_id IS null THEN 1 ELSE 0 END)/COUNT(*) as WEB_ONLY, 100*SUM(CASE WHEN w.user_id IS null THEN 1 ELSE 0 END)/COUNT(*) as MOBILE_ONLY, 100*SUM(CASE WHEN m.user_id IS NOT null AND w.user_id IS NOT null THEN 1 ELSE 0 END)/COUNT(*) as BOTH FROM (SELECT distinct user_id FROM query_two_web ) w FULL OUTER JOIN (SELECT distinct user_id FROM query_two_mobile ) m ON m.user_id = w.user_id;  Median Algo  We have two tables. One is user id and their signup date. The other one shows all transactions done by those users, when the transaction happens and its corresponding dollar amount.\nFind the average and median transaction amount only considering those transactions that happen on the same date as that user signed-up.\n row_asc | row_desc 1 | 5 2 | 4 3 | 3 --- row_asc is between row_desc -1 and row_desc +1 4 | 2 5 | 1 ---- SELECT AVG(transaction_amount) AS average, AVG(CASE WHEN row_num_asc BETWEEN row_num_desc-1 and row_num_desc+1 THEN transaction_amount ELSE NULL END ) AS median FROM ( SELECT transaction_amount, ROW_NUMBER() OVER(ORDER BY transaction_amount) row_num_asc, COUNT(*) OVER() - ROW_NUMBER() OVER(ORDER BY transaction_amount) + 1 AS row_num_desc FROM query_five_users a JOIN (SELECT *, to_date(transaction_date) AS date_only FROM query_five_transactions) b ON a.user_id = b.user_id AND a.sign_up_date = b.date_only ) tmp;  Find country with minimum and max accounts SELECT country, user_count FROM ( SELECT *, ROW_NUMBER() OVER (ORDER BY user_count) as count_asc, ROW_NUMBER() OVER (ORDER BY user_count desc) as count_desc FROM ( SELECT country, COUNT(distinct user_id) as user_count FROM query_six GROUP BY country )a ) tmp WHERE count_asc = 1 or count_desc = 1;  Find MAX() or MIN() from consecutive records Basic idea: MAX() or MIN() group by feature - row index\n LC 1225. Report Contiguous Dates\nhttps://leetcode.com/problems/report-contiguous-dates/\n WITH combined as ( SELECT fail_date as dt, 'failed' as period_state, DAYOFYEAR(fail_date) - row_number() over(ORDER BY fail_date) as period_group FROM Failed WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31' UNION ALL SELECT success_date as dt, 'succeeded' as period_state, DAYOFYEAR(success_date) - row_number() over(ORDER BY success_date) as period_group FROM Succeeded WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31' ) SELECT period_state, min(dt) as start_date, max(dt) as end_date FROM combined GROUP BY period_state, period_group ORDER BY start_date   LC 1285. Find the Start and End Number of Continuous Ranges\nhttps://leetcode.com/problems/find-the-start-and-end-number-of-continuous-ranges/\n SELECT min(log_id) as start_id, max(log_id) as end_id FROM (SELECT log_id, ROW_NUMBER() OVER(ORDER BY log_id) as num FROM Logs) a GROUP BY log_id - num  Pivot Table Trick  | name | continent | |--------|-----------| | Jack | America | | Pascal | Europe | | Xi | Asia | | Jane | America |  to this:\n| America | Asia | Europe | |---------|------|--------| | Jack | Xi | Pascal | | Jane | | |   SELECT MAX(CASE WHEN continent = 'America' THEN name ELSE NULL END) AS America, MAX(CASE WHEN continent = 'Asia' THEN name ELSE NULL END) AS Asia, MAX(CASE WHEN continent = 'Europe' THEN name ELSE NULL END) AS Europe FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY NAME) AS row_id FROM student ) a GROUP BY row_id ORDER BY row_id  note:\n ROW_NUMBER() + GROUP BY : will give out name by continent MAX() will remove NULL for each continent  SQL function sample  LC177. Nth Highest Salary): Write a SQL query to get the nth highest salary from the Employee table. For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. input: {\u0026ldquo;headers\u0026rdquo;: {\u0026ldquo;Employee\u0026rdquo;: [\u0026ldquo;Id\u0026rdquo;, \u0026ldquo;Salary\u0026rdquo;]}, \u0026ldquo;argument\u0026rdquo;: 2, \u0026ldquo;rows\u0026rdquo;: {\u0026ldquo;Employee\u0026rdquo;: [[1, 100], [2, 200], [3, 300]]}}\n CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN declare m int; set m = n-1; RETURN ( select salary from Employee group by salary order by salary desc limit m, 1 ); END  Pivot Function This example uses the star1 table, with the following definition and contents:\nCREATE TABLE star1(country VARCHAR(20),state VARCHAR(10), yr INTEGER,qtr VARCHAR(3),sales INTEGER,cogs INTEGER); SELECT * FROM star1; country state yr qtr sales cogs ------- ----- ----------- --- ----------- ----------- USA CA 2001 Q1 30 15 Canada ON 2001 Q2 10 0 Canada BC 2001 Q3 10 0 USA NY 2001 Q1 45 25 USA CA 2001 Q2 50 20  In this example, the IN list contains alias names. The alias names are concatenated with the alias names specified by the aggregate functions to build the column names of the output pivoted table.\nSELECT * FROM star1 PIVOT ( SUM(sales) as ss1, SUM(cogs) as sc FOR qtr IN (‘Q1’ AS Quarter1, ‘Q2’ AS Quarter2, ‘Q3’ AS Quarter3) )Tmp;  The output is re-written as an equivalent SELECT query using CASE statements:\nSELECT * FROM (SELECT country ,state ,yr , SUM(CASE WHEN qtr = 'Q1' THEN sales ELSE NULL END) AS Quarter1_ss1, SUM(CASE WHEN qtr = 'Q1' THEN (cogs) ELSE NULL END) AS Quarter1_sc, SUM(CASE WHEN qtr = 'Q2' THEN (sales) ELSE NULL END) AS Quarter2_ss1, SUM(CASE WHEN qtr = 'Q2' THEN (cogs) ELSE NULL END) AS Quarter2_sc, SUM(CASE WHEN qtr = 'Q3' THEN (sales) ELSE NULL END) AS Quarter3_ss1, SUM(CASE WHEN qtr = 'Q3' THEN (cogs) ELSE NULL END) AS Quarter3_sc FROM star1 GROUP BY country ,state ,yr ) Tmp ;  Output pivoted table:\ncountry state yr Quarter1_ss1 Quarter1_sc Quarter2_ss1 Quarter2_sc Quarter3_ssl Quarter3_sc ------- ---- ---- ------------ ----------- ------------ ----------- ------------ ----------- USA CA 2001 30 15 50 20 ? ? USA NY 2001 45 25 ? ? ? ? Canada ON 2001 ? ? 10 0 ? ? Canada BC 2001 ? ? ? ? 10 0  ","id":295,"section":"posts","summary":"SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.","tags":["template"],"title":"SQL Notes","uri":"https://foxisawesome.github.io/posts/sql-notes/","year":"2020"},{"content":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:  Details: python built-in divmod() returns floor, which is not friendly in negative case. need to take int(a/b) I was scared what if the division tests on a infinite unreapted, then toasted. However, the test cases have none. convet all calc to postive nums once determined. Loop through mod and record each mod’s index place.  class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -\u0026gt; str: if denominator == 0: return '' ans = '-' if numerator * denominator \u0026lt; 0 else '' numerator, denominator = abs(numerator), abs(denominator) d = dict() div, mod = self.myDivmod(numerator, denominator) if mod == 0: ans += str(div) return ans ans += str(div) + '.' d[mod] = len(ans) while mod: div, mod = self.myDivmod(mod*10, denominator) ans += str(div) if mod in d: idx = d[mod] ans = ans[:idx] + '(' + ans[idx:] + ')' break else: d[mod] = len(ans) return ans def myDivmod(self, a, b): d = int(a/b) m = a - d*b return (d, m)  ","id":296,"section":"posts","summary":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:  Details: python built-in divmod() returns floor, which is not friendly in negative case.","tags":["leetcode"],"title":"166 Fraction to Recurring Decimal","uri":"https://foxisawesome.github.io/posts/166-fraction-to-recurring-decimal/","year":"2020"},{"content":"LC 159 Longest Substring With at Most Two Distinct Characters   Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters.\nInput: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5.   Solution 2020-09-05 Notes:\n 今天周末出去走了一圈，回家刷题效率可以啊。  class Solution: def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u0026gt; int: if not s: return 0 out = 0 n = len(s) for i in range(n): l = 1 while i+l \u0026lt; n and len(set(s[i:i+l+1])) \u0026lt; 3: l += 1 out = max(out, l) return out # Time O(N) # Space O(1)  ","id":297,"section":"posts","summary":"LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def","tags":["leetcode"],"title":"159 Longest Substring With at Most Two Distinct Characters","uri":"https://foxisawesome.github.io/posts/159-longest-substring-with-at-most-two-distinct-characters/","year":"2020"},{"content":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:  Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.add(num) else: stack.remove(num) return stack.pop() # Time O(N) # Space O(N)  If we take XOR of zero and some bit, it will return that bit: $a \\oplus 0 = a$ If we take XOR of two same bits, it will return 0: $a \\oplus a = 0$\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for num in nums: a ^= num return a  class Solution(object): def singleNumber(self, nums): return 2 * sum(set(nums)) - sum(nums)  ","id":298,"section":"posts","summary":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:  Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.","tags":["leetcode"],"title":"136 Single Number","uri":"https://foxisawesome.github.io/posts/136-single-number/","year":"2020"},{"content":"LC 187 Repeated Dna Sequences   All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n Solution 2020-09-05 Notes:  很简单的题，两个小陷进：  Substring = s[i-9:i+1] NOT s[i-10:i] because 0-indexed. avoid dups in the output.    class Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: n = len(s) if not s or n\u0026lt;10: return [] count = dict() out = [] for i in range(9,n): entry = s[i-9:i+1] ct = count.get(entry,0) + 1 count[entry]= ct if ct \u0026gt; 1 and entry not in out: out.append(entry) return out # Time O(N) # Space O(1)  ","id":299,"section":"posts","summary":"LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷","tags":["leetcode"],"title":"187 Repeated Dna Sequences","uri":"https://foxisawesome.github.io/posts/187-repeated-dna-sequences/","year":"2020"},{"content":"LC 1249 Minimum Remove to Make Valid Parentheses   Given a string s of '(' , ')' and lowercase English characters.\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\nInput: s = \u0026quot;lee(t(c)o)de)\u0026quot; Output: \u0026quot;lee(t(c)o)de\u0026quot; Explanation: \u0026quot;lee(t(co)de)\u0026quot; , \u0026quot;lee(t(c)ode)\u0026quot; would also be accepted.   Solution 2020-09-05 Notes:  很简单的题，但是发现在line#16，用set() 要比 list()的extend 快好多好多！  class Solution: def minRemoveToMakeValid(self, s: str) -\u0026gt; str: if not s: return '' stack = [] to_rm = [] ans = '' for i, val in enumerate(s): if val not in ('(',')'): continue elif val == '(': stack.append(i) elif val == ')': if stack: stack.pop() elif not stack: to_rm.append(i) to_rm = set(to_rm + stack) for i, val in enumerate(s): if i not in to_rm: ans += val return ans # Time O(N) # Space O(N)  ","id":300,"section":"posts","summary":"LC 1249 Minimum Remove to Make Valid Parentheses Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Input: s = \u0026quot;lee(t(c)o)de)\u0026quot; Output: \u0026quot;lee(t(c)o)de\u0026quot; Explanation: \u0026quot;lee(t(co)de)\u0026quot; , \u0026quot;lee(t(c)ode)\u0026quot; would also be accepted. Solution 2020-09-05 Notes: 很简","tags":["leetcode","stack"],"title":"1249 Minimum Remove to Make Valid Parentheses","uri":"https://foxisawesome.github.io/posts/1249-minimum-remove-to-make-valid-parentheses/","year":"2020"},{"content":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Sam e\n  class Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: count = dict() stack = [] for l in s: count[l] = count.get(l,0) + 1 for c in s: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":301,"section":"posts","summary":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration.","tags":["leetcode"],"title":"316 Remove Dup Letters","uri":"https://foxisawesome.github.io/posts/316-remove-dup-letters/","year":"2020"},{"content":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Same as LC 316\n  class Solution: def smallestSubsequence(self, text: str) -\u0026gt; str: count = dict() stack = [] for l in text: count[l] = count.get(l,0) + 1 for c in text: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":302,"section":"posts","summary":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.","tags":["leetcode"],"title":"1081 Smallest Subsequence of Distinct Char","uri":"https://foxisawesome.github.io/posts/1081-smallest-subsequence-of-distinct-char/","year":"2020"},{"content":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing asLC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.get(nums[fast],0) + 1 if count[nums[fast]] \u0026lt;= 2: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":303,"section":"posts","summary":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing asLC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.","tags":["leetcode","two_pointers"],"title":"80 Remove Dup From Sorted Array II","uri":"https://foxisawesome.github.io/posts/80-remove-dup-from-sorted-array-ii/","year":"2020"},{"content":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.   Solution 2020-09-04 Notes:\n Two pointers: slow and fast. updates when fast == slow. Same thing asLC 80.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: slow, fast = 0, 1 while fast \u0026lt; len(nums): if nums[fast] != nums[slow]: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":304,"section":"posts","summary":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.","tags":["leetcode","two_pointers"],"title":"26 Remove Dup From Sorted Array","uri":"https://foxisawesome.github.io/posts/26-remove-dup-from-sorted-array/","year":"2020"},{"content":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes: K - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: nums.sort() return self.kSum(nums, target, 4) def kSum(self, nums: List[int], target: int, k: int) -\u0026gt; List[List[int]]: res = [] if len(nums)==0 or nums[0] * k \u0026gt; target or nums[-1] * k \u0026lt; target: return res if k == 2: return self.twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for _, val in enumerate(self.kSum(nums[i+1:], target-nums[i], k-1)): res.append([nums[i]] + val) return res def twoSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: res = [] lo, hi = 0, len(nums) - 1 while (lo \u0026lt; hi): sum = nums[lo] + nums[hi] if sum \u0026lt; target or (lo \u0026gt; 0 and nums[lo] == nums[lo - 1]): lo += 1 elif sum \u0026gt; target or (hi \u0026lt; len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res # Time O(N^(k-1)) # Space O(N)  ","id":305,"section":"posts","summary":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes: K - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):","tags":["leetcode"],"title":"18 K Sum","uri":"https://foxisawesome.github.io/posts/18-k-sum/","year":"2020"},{"content":"LC 140 Word Break II   Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\nInput: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ]   Solution 2020-09-03 Notes:  第一次尝试，哇！这不是和 word break 一摸一样嘛。照模版写了个bt如下，试了两个例子都过了。提交了才发现，严重超时。一看官方解答是dp做的，感叹要不怎么是medium，一题是hard呢。但我觉得我要能加上memo 跟下面的dfs应该是同理。 于是看了大牛的解答，带memo的recursion是可以过的  # backtracking, exceed time limit! class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) out = [] self.backtracking(s,wordDict,[],out,n) return out def backtracking(self, s, wordDict, path, out, n): m = len(s) if m == 0: out.append(\u0026quot; \u0026quot;.join(path)) return for i in range(m): if s[:i+1] in wordDict: path.append(s[:i+1]) for self.backtracking(s[i+1:], wordDict, path, out, n) path.pop() # Time O() # Space O()  recursion with memo:\n need to add () to this res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)). Otherwise, it will interperate as res.append((w + '') if not r else (\u0026quot; \u0026quot; + r))  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: res = [] memo = dict() return self.dfs(s,wordDict,memo) def dfs(self, s,wordDict,memo): if s in memo: return memo[s] if not s: return [\u0026quot;\u0026quot;] res = [] for w in wordDict: if s[:len(w)] == w: for r in self.dfs(s[len(w):], wordDict, memo): res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)) memo[s] = res return res  ","id":306,"section":"posts","summary":"LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] Solution 2020-09-03 Notes: 第一","tags":["leetcode","dp","recursion","backtracking","DFS"],"title":"140 Word Break II","uri":"https://foxisawesome.github.io/posts/140-word-break-ii/","year":"2020"},{"content":"LC 128 Longest Consecutive Sequence   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Solution 2020-09-03 Notes:\n  题目 time complexity 要求O(N)，那没其他办法只能 hash table做了，看了花花的视频， 没话说一讲就很简单了。\n  solution #1: 用dictionary做，key记录nums里的每个数，val=但这个数字的最长连续数字长度。查看num-1 和 num+1的val. online 求最长长度。\n  solution #2: 用set做, if num-1 not in the set, then num is the starting point of a consecutive list. Count the length until num+l not in the set. offline getting longest length.\n  class Solution: def longestConsecutive_solu1(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #1 h = dict() # key: num, val: consecutive length until key out = 0 for i in nums: if i in h: continue l = h[i-1] if i-1 in h else 0 r = h[i+1] if i+1 in h else 0 h[i] = h[i-l] = h[i+r] = l+r+1 out = max(out, h[i]) return out def longestConsecutive_solu2(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #2 h = set(nums) out = 0 for num in nums: if num-1 not in h: l = 1 while num+l in h: l += 1 out = max(out, l) return out # Time O(N) # Space O(N)  ","id":307,"section":"posts","summary":"LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: 题目 time complexity 要求O(N)，那没其","tags":["leetcode"],"title":"128 Longest Consecutive Sequence","uri":"https://foxisawesome.github.io/posts/128-longest-consecutive-sequence/","year":"2020"},{"content":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n Solution 2020-09-02 Notes:\n Height of a tree: max(left_height, right_height) + 1 width of a tree (diameter): max(left_height + right_height) Diameter needs to be calculated along the way in this case.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: if not root: return 0 self.diameter = 0 self.DFS(root) return self.diameter def DFS(self, root) -\u0026gt; int: # DFS returns the height if not root: return 0 L_height = self.DFS(root.left) R_height = self.DFS(root.right) self.diameter = max(self.diameter, L_height+R_height) return max(L_height, R_height) + 1 # Time O(N) # Space O(N)  ","id":308,"section":"posts","summary":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].","tags":["leetcode","tree"],"title":"543 Diameter of Binary Tree","uri":"https://foxisawesome.github.io/posts/543-diameter-of-binary-tree/","year":"2020"},{"content":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.\n  Algo #2: one pass, same time complexity. some details need to figure out.\n  rotation algo: r, c = c, n-r-1\n  row in range(n//2+n%2) and col in range(n//2)\n  while rotating the k, cycle from the last element: t[(k-1)%4]\n    class Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: n = len(matrix) # two-pass: 1. transpose; 2. reverse rows for i in range(n): for j in range(i,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() # one-pass: for i in range(n//2+n%2): for j in range(n//2): r, c = i, j t = [0]*4 for k in range(4): t[k] = matrix[r][c] r, c = c, n-r-1 for k in range(4): matrix[r][c] = t[(k-1)%4] r, c = c, n-r-1 # Time O(N^2) # Space O(1)  ","id":309,"section":"posts","summary":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.","tags":["leetcode"],"title":"48 Rotate Image","uri":"https://foxisawesome.github.io/posts/48-rotate-image/","year":"2020"},{"content":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).\nMore formally, the probability of picking index i is w[i] / sum(w).\n Solution 2020-09-02 Notes:\n first, construct cumulative sum / total sum list. binary search for the nearest element \u0026gt; rand.uniform(0,1). I used closed interval in binary search, hence return l. No == case, because the robablilty of element exactly equal to random draw is 0.  class Solution: import random def __init__(self, w: List[int]): self.w = w self.w_sum = [] wsum = 0 tot = sum(self.w) for i in w: wsum += i prob = wsum/tot self.w_sum.append(prob) def pickIndex(self) -\u0026gt; int: target = random.uniform(0,1) l, r = 0, len(self.w)-1 while l \u0026lt;= r: m = l + (r-l)//2 if self.w_sum[m] \u0026gt; target: r = m - 1 elif self.w_sum[m] \u0026lt; target: l = m + 1 return l # Time O(N) + O(logN) # Space O(N)  ","id":310,"section":"posts","summary":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.","tags":["leetcode"],"title":"528 Random Pick With Weight","uri":"https://foxisawesome.github.io/posts/528-random-pick-with-weight/","year":"2020"},{"content":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7   Solution 2020-09-02 Notes:\n Scan two linked lists first, using stack to store the node value. use the same LC 2 add two numbers to add them up from the end. Use LC 206 reverse linked list to store reversely along the way.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while stack1 and stack2: carry, r = divmod(stack1.pop() + stack2.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp stack = stack1 if stack1 else stack2 while stack: carry, r = divmod(stack.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp if carry != 0: temp = head head = ListNode(carry) head.next = temp return head # Time O(N) # Space O(1)  ","id":311,"section":"posts","summary":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists?","tags":["leetcode","linkedList"],"title":"445 Add Two Num II","uri":"https://foxisawesome.github.io/posts/445-add-two-num-ii/","year":"2020"},{"content":"LC 295 Find Median From Data Stream   Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Solution 2020-09-01 Notes:   Follow 了花花酱的solu#1。 python the heapq implementation is a bit messy, while involving max heapq. python heapq library default heap is min-heap. filp all nums to -num to a heap, then it becomes a max-heap. Recover while pop.\n  Algo 想法挺简单但很巧: 分两堆：small (max-heap) 在左，large (min-heap)在右。\n Step1: add number to small heap while num \u0026lt;= small[0] Step2: balancing two heaps, 0\u0026lt;=len(small)-len(large)\u0026lt;2    class MedianFinder: import heapq def __init__(self): self.large = [] # min heap, right heap self.small = [] # max heap, left heap def addNum(self, num: int) -\u0026gt; None: if not self.small or num \u0026lt;= -self.small[0] : #default heapq is min heap, use -1*num will turn it as max heapq heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # balance two heaps if len(self.small) \u0026lt; len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) - len(self.large) == 2: heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -\u0026gt; float: if len(self.small) == len(self.large): return (-self.small[0] + self.large[0])/2 else: return -self.small[0] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() # Time O(nlogn) # Space O(N)  ","id":312,"section":"posts","summary":"LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow 了花花酱的so","tags":["leetcode","heap"],"title":"295 Find Median From Data Stream","uri":"https://foxisawesome.github.io/posts/295-find-median-from-data-stream/","year":"2020"},{"content":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:  Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head l_tail = slow = fast = head while fast and fast.next: l_tail = slow slow = slow.next fast = fast.next.next l_tail.next = None l = self.sortList(head) r = self.sortList(slow) return self.mergeTwoSorted(l,r) def mergeTwoSorted(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = dummy = ListNode(0) while l1 and l2: if l1.val \u0026lt; l2.val: head.next = l1 l1 = l1.next else: head.next = l2 l2 = l2.next head = head.next head.next = l1 if l1 else l2 return dummy.next # Time O(nlogn): merge sort # Space O(1): actually not O(1), since recursion is not O(1)  ","id":313,"section":"posts","summary":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:  Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.","tags":["leetcode","linkedList"],"title":"148 Sort List","uri":"https://foxisawesome.github.io/posts/148-sort-list/","year":"2020"},{"content":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.   Solution 2020-09-01 Notes:\n classic DFS/backtracking problem. The biggest thing I\u0026rsquo;ve learnt from this: to return True/False instead of a list of retults. one needs to pass the true from bottom to top. Line 31-32 is doing this! Otherwise, if only line 23, on the the bottom DFS functions returns True, other lays return None.  class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: n = len(board) m = len(board[0]) directions = [[1,0], [-1,0], [0,1], [0,-1]] inits = [] for i in range(n): for j in range(m): if board[i][j] == word[0]: inits.append((i,j)) while inits: start = inits.pop() visited = set() visited.add(start) if self.dfs(board, word, directions, word[0], start, visited, m,n): return True return False def dfs(self, board, word, directions, path, point, visited,m,n): i, j = point[0], point[1] if path == word: return True for d in directions: x0, y0 = d[0], d[1] x1, y1 = x0+i, y0+j if 0\u0026lt;=x1\u0026lt;n and 0\u0026lt;=y1\u0026lt;m and (x1,y1) not in visited and board[x1][y1]==word[len(path)]: next_pt = (x1,y1) visited.add(next_pt) if self.dfs(board, word, directions, path+board[x1][y1],next_pt,visited,m,n): return True visited.remove(next_pt) # Time O(N*3^L), where L is the length of word # Space O(N)  ","id":314,"section":"posts","summary":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true.","tags":["leetcode","backtracking","DFS"],"title":"79 Word Search","uri":"https://foxisawesome.github.io/posts/79-word-search/","year":"2020"},{"content":"LC 981 Time Based Key Value Store   Create a timebased key-value store class TimeMap, that supports two operations.\n set(string key, string value, int timestamp)   Stores the key and value, along with the given timestamp.  get(string key, int timestamp)   Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).   Solution 2020-09-01 Notes:  抄了一遍：这个reference  class TimeMap: def __init__(self): self.v_ = collections.defaultdict(list) self.t_ = collections.defaultdict(list) def set(self, key: str, value: str, timestamp: int) -\u0026gt; None: self.t_[key].append(timestamp) self.v_[key].append(value) def get(self, key: str, timestamp: int) -\u0026gt; str: if key not in self.t_: return \u0026quot;\u0026quot; # bisect is efficient algo to search key i = bisect.bisect_right(self.t_[key], timestamp) if i: return self.v_[key][i-1] return \u0026quot;\u0026quot; # Your TimeMap object will be instantiated and called as such: # obj = TimeMap() # obj.set(key,value,timestamp) # param_2 = obj.get(key,timestamp)  ","id":315,"section":"posts","summary":"LC 981 Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are","tags":["leetcode"],"title":"981 Time Based Key Value Store","uri":"https://foxisawesome.github.io/posts/981-time-based-key-value-store/","year":"2020"},{"content":"LC 1041 Robot Bounded in Circle \n On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:\n \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n 2020-08-31 Notes:  没见过这种implementation。好经典的做法，二刷希望能刷出来。  class Solution: def isRobotBounded(self, instructions: str) -\u0026gt; bool: # north = 0, east = 1, south = 2, west = 3 directions = [[0,1],[1,0],[0,-1],[-1,0]] x = y = 0 idx = 0 for i in instructions: if i == 'L': idx = (idx + 3) % 4 elif i == 'R': idx = (idx + 1) % 4 else: x += directions[idx][0] y += directions[idx][1] return (x==0 and y==0) or idx != 0  ","id":316,"section":"posts","summary":"LC 1041 Robot Bounded in Circle On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in","tags":["leetcode"],"title":"1041 Robot Bounded in Circle","uri":"https://foxisawesome.github.io/posts/1041-robot-bounded-in-circle/","year":"2020"},{"content":"LC 957 Prison Cells \n There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can\u0026rsquo;t have two adjacent neighbors.)\nWe describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\n 2020-08-31 Notes:\n  这题做了好久，好多corner case没过。最后才明白：\n  cycle = 14\n  two cases:\n​\ta. head in the cycle of 14; days %= 14\n​\tb. head not in the cycle of 14. in this case, days = (days-1)%14,\n    class Solution: def nextDay(self, cells): cells_nd = [0] for i in range(1,len(cells)-1): if cells[i-1] == cells[i+1]: cells_nd.append(1) else: cells_nd.append(0) cells_nd.append(0) return cells_nd def prisonAfterNDays(self, cells: List[int], N: int) -\u0026gt; List[int]: if not cells: return [] if N == 0: return cells memo = dict() memo[str(cells[:])] = 0 n = len(cells) for d in range(1,N+1): cells = self.nextDay(cells) print(d,cells) if str(cells) in memo: cycle = d - memo[str(cells)] break memo[str(cells[:])] = d # cycle is always 14. But two cases: 1. head is in the cycle; 2. head is not in the cycle. if d \u0026lt; N: if memo[str(cells)]==0: # head in the cycle case days = (N)%cycle else: # head not in the cycle case. days = (N-1)%cycle for d in range(days): cells = self.nextDay(cells) return cells  ","id":317,"section":"posts","summary":"LC 957 Prison Cells There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the","tags":["leetcode"],"title":"957 Prison Cells","uri":"https://foxisawesome.github.io/posts/957-prison-cells/","year":"2020"},{"content":"LC 735 Aseroid Collision \n We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.  Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other.  Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.  Example 4:\nInput: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   2020-08-31 Notes:\n 一次就做对了如下。虽然不简洁，但能用上recursion，也算挺开心了。 一看官方解答，跟简洁，能combine 很多的case。而且最关键的：while+ continue+break的组合完美的绕开了recursion的做法。看了下时间比较差距不大。  class Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: stack = self.helper(stack, a) return stack def helper(self, stack, a): if not stack: stack.append(a) elif stack[-1] * a \u0026gt; 0 or stack[-1] \u0026lt; 0 and a \u0026gt; 0: stack.append(a) elif abs(stack[-1]) == abs(a): stack.pop() elif abs(stack[-1]) \u0026lt; abs(a): stack.pop() return self.helper(stack, a) return stack # Time O(N) # Space O(N)  官方解答：\nclass Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: while stack and a \u0026lt; 0 \u0026lt; stack[-1]: if stack[-1] \u0026lt; -a: stack.pop() continue elif stack[-1] == -a: stack.pop() break else: stack.append(a) return stack  ","id":318,"section":"posts","summary":"LC 735 Aseroid Collision We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size,","tags":["leetcode","recursion","stack"],"title":"735 Aseroid Collision","uri":"https://foxisawesome.github.io/posts/735-aseroid-collision/","year":"2020"},{"content":"LC 141 Linked List Cycle \n Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.   08/29/2020 Notes:\n Fast two steps at a time, slow pointer one step a time. 一次也就过了。  class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if not head: return slow = fast = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False  ","id":319,"section":"posts","summary":"LC 141 Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There","tags":["leetcode","linkedList"],"title":"141 Linked List Cycle","uri":"https://foxisawesome.github.io/posts/141-linked-list-cycle/","year":"2020"},{"content":"LC 328 Odd Even Linked List  Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL   Solution 2020-08-30 Notes: linked list 终于在周末刷出感觉了。这题也一遍就过了。\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return odd = p1 = ListNode(1) even = p2 = ListNode(0) count = 1 while head: if count % 2 == 1: odd.next = ListNode(head.val) odd = odd.next else: even.next = ListNode(head.val) even = even.next head = head.next count += 1 odd.next = p2.next return p1.next  ","id":320,"section":"posts","summary":"LC 328 Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL Solution 2020-08-30 Notes: linked list 终","tags":["leetcode","linkedList"],"title":"328 Odd Even Linked List","uri":"https://foxisawesome.github.io/posts/328-odd-even-linked-list/","year":"2020"},{"content":"LC 1266 Minimum Time Visiting All Points  On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.   Solution 8-30-2020 Notes: 一遍就过的题，没啥好说的。\nclass Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -\u0026gt; int: n = len(points) m = len(points[0]) time = 0 if not points or n == 0 or m == 0: return time for i in range(1, n): x1, y1 = points[i-1] x2, y2 = points[i] time += max(abs(x1-x2), abs(y1-y2)) return time  ","id":321,"section":"posts","summary":"LC 1266 Minimum Time Visiting All Points On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points. You can move according to the next rules: In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in","tags":["leetcode"],"title":"1266 Minimum Time Visiting All Points","uri":"https://foxisawesome.github.io/posts/1266-minimum-time-visiting-all-points/","year":"2020"},{"content":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:\n BST has a property that: if in-order traverse, the output is a sorted list. Time complex is O(N), if store everything, then space complexity is O(N). I can only maintain min_diff in each root step to reduce space complexity to O(1). recursion here is pretty easy: standard in-order traversal recursion.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getMinimumDifference(self, root: TreeNode) -\u0026gt; int: self.prev = None self.min_diff = float('inf') self.inorder(root) return self.min_diff def inorder(self, root): if not root: return self.inorder(root.left) if self.prev is not None: self.min_diff = min(self.min_diff, root.val - self.prev) self.prev = root.val self.inorder(root.right)  ","id":322,"section":"posts","summary":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:","tags":["leetcode","tree","BST"],"title":"530 Min Abs Dif BST","uri":"https://foxisawesome.github.io/posts/530-min-abs-dif-bst/","year":"2020"},{"content":"LC 98 Valid BST\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  Solution 08/30/2020 Notes:  two ways: 1. Check if a sorted list returned after in-order traversal. 2. check if alway root.right.val \u0026gt; root.val \u0026gt; root.left.val I used the first way. 这又是个很高级的recursion。  class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: self.prev = None return self.inorder(root) def inorder(self, root): if not root: return True if not self.inorder(root.left): return False if self.prev is not None and root.val \u0026lt;= self.prev: return False self.prev = root.val return self.inorder(root.right)  ","id":323,"section":"posts","summary":"LC 98 Valid BST Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example","tags":["leetcode","tree","BST"],"title":"98 Valid BST","uri":"https://foxisawesome.github.io/posts/98-valid-bst/","year":"2020"},{"content":"LC 701\n Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5  You can return this binary search tree:\n 4 / \\ 2 7 / \\ / 1 3 5  This tree is also valid:\n 5 / \\ 2 7 / \\ 1 3 \\ 4   08/30/2020 Notes:\n 这个recursion 好高级，似懂非懂回头还得在刷。 一定要明确 resursion function return 的是什么。 这个return的是TreeNode。  9/10/2020 Note:\n刷了一阵tree之后终于搞懂了，给tree添加leaf node的操作是 root.left = TreeNode(val), 所以if not root: return root.val. 最后添加完之后就是return这个root 一层一层返回。\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def insertIntoBST(self, root: TreeNode, val: int) -\u0026gt; TreeNode: if not root: return TreeNode(val) if root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root  ","id":324,"section":"posts","summary":"LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST","tags":["leetcode","tree","BST"],"title":"701 Insert Into BST","uri":"https://foxisawesome.github.io/posts/701-insert-into-bst/","year":"2020"},{"content":"滑动窗口算法的思路是这样：\n1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。\n2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。\n3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到right到达字符串S的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\nrefrence: wx:labuladong\nCode Template:\ndef slidingWindow(s: str, t: str) -\u0026gt; str: target, window = {}, {} for i in t: target[i] = target.get(i,0) + 1 left, right, valid = 0, 0, 0 while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] # move right index right += 1 # 进行窗口内数据的一系列更新 ... # /*** debug 输出的位置 ***/ print('s: '+s2[left:right]+' window' + str(window) + ' valid: ' + str(valid)) # see if needs to shrink window while (window shrinking condition): d = s[left] left += 1 # 进行窗口内数据的一系列更新 ... return ...  ","id":325,"section":"posts","summary":"滑动窗口算法的思路是这样： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)","tags":["template"],"title":"Sliding Window Note","uri":"https://foxisawesome.github.io/posts/sliding-window-note/","year":"2020"},{"content":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post!\nIt takes a while for me to get how exactly Linked List works. I used following utility functions to keep my leetcode solutions and run codes locally.\nNote:\n say head = ListNode(0), then head = head.next is to iterate to next node on the Linked List. use head.next = a to point to next node.  # My liked list utility functions: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def list2ListNode(list): head = LinkedList = ListNode(0) for i in range(len(list)): LinkedList.next = ListNode(list[i]) LinkedList = LinkedList.next return head.next def printListNode(p): head = ListNode(0) head.next = p out = [] while p: out.append(p.val) p = p.next return out # e.g.: indata = [1,2,3,4,5,6] head = ListNode.list2ListNode(indata) ListNode.printListNode(head)  ","id":326,"section":"posts","summary":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post! It takes a while for me to get how exactly Linked List","tags":["template","linkedList"],"title":"Linked List Note (First Post)","uri":"https://foxisawesome.github.io/posts/linked-list-note/","year":"2020"},{"content":"LC 917 Reverse Only Letters   Given a string S, return the \u0026ldquo;reversed\u0026rdquo; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.\n Solution 2020-08-29 Notes: class Solution: def reverseOnlyLetters(self, S: str) -\u0026gt; str: if not S: return '' out = list(S) n = len(S) l, r = 0, n-1 while l \u0026lt; r: if not S[l].isalpha() and not S[r].isalpha(): l += 1 r -= 1 elif not S[l].isalpha() and S[r].isalpha() : l += 1 elif S[l].isalpha() and not S[r].isalpha() : r -= 1 else: out[l], out[r] = out[r], out[l] l += 1 r -= 1 return ''.join(out) # Time O(N) # Space O(1)  ","id":327,"section":"posts","summary":"LC 917 Reverse Only Letters   Given a string S, return the \u0026ldquo;reversed\u0026rdquo; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.\n Solution 2020-08-29 Notes: class Solution: def reverseOnlyLetters(self, S: str) -\u0026gt; str: if not S: return '' out = list(S) n = len(S) l, r = 0, n-1 while l \u0026lt; r: if not S[l].isalpha() and not S[r].","tags":["leetcode","two_pointers"],"title":"917 Reverse Only Letters","uri":"https://foxisawesome.github.io/posts/917-reverse-only-letters/","year":"2020"},{"content":"LC 50 Powx N   Implement pow(x, n), which calculates x raised to the power n (i.e. x^n).\n Solution 2020-09-25 Notes:  一个月水平进化了一点。  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: return self.myPow(1/x,abs(n)) if n == 0: return 1 if n % 2 ==0: ans = self.myPow(x,n//2) ** 2 else: ans = x * self.myPow(x, n//2) ** 2 return ans # Time O(logN) # Space O(1)  2020-08-28 Notes:  一遍就过了, 二分法的思想  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: x = 1/x n = -n return self.doubleup(x,n) def doubleup(self,x,n): if n == 0: return 1 half = self.doubleup(x,n//2) if n % 2 == 0: return half * half else: return half * half * x  ","id":328,"section":"posts","summary":"LC 50 Powx N Implement pow(x, n), which calculates x raised to the power n (i.e. x^n). Solution 2020-09-25 Notes: 一个月水平进化了一点。 class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: return self.myPow(1/x,abs(n)) if n == 0: return 1 if n % 2 ==0: ans = self.myPow(x,n//2) ** 2 else: ans = x * self.myPow(x, n//2)","tags":["leetcode","recursion"],"title":"50 Powx N","uri":"https://foxisawesome.github.io/posts/50-powx-n/","year":"2020"},{"content":"本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。\nLeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。\n本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：\nunordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。\n可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。\n所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。\n本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。\n一、最小覆盖子串 题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。\n如果我们使用暴力解法，代码大概是这样的：\nfor (int i = 0; i \u0026lt; s.size(); i++) for (int j = i + 1; j \u0026lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案  思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。\n滑动窗口算法的思路是这样：\n1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。\n2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。\n这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。**左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。\n下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。\n初始状态：\n增加 right，直到窗口 [left, right] 包含了 T 中所有字符：\n现在开始增加 left，缩小窗口 [left, right]。\n直到窗口中的字符串不再符合要求，left 不再继续移动。\n之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。\n如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。\n上述过程可以简单地写出如下伪码框架：\nstring s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; while(right \u0026lt; s.size()) { window.add(s[right]); right++; // 如果符合要求，移动 left 缩小窗口 while (window 符合要求) { // 如果这个窗口的子串更短，则更新 res res = minLen(res, window); window.remove(s[left]); left++; } } return res;  如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left\u0026hellip;right] 是否符合要求，是否包含 t 的所有字符呢？\n可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。\n现在将上面的框架继续细化：\nstring s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; // 相当于两个计数器 unordered_map\u0026lt;char, int\u0026gt; window; unordered_map\u0026lt;char, int\u0026gt; needs; for (char c : t) needs[c]++; // 记录 window 中已经有多少字符符合要求了 int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; // 加入 window if (window[c1] == needs[c1]) // 字符 c1 的出现次数符合要求了 match++; } right++; // window 中的字符串已符合 needs 的要求了 while (match == needs.size()) { // 更新结果 res res = minLen(res, window); char c2 = s[left]; if (needs.count(c2)) { window[c2]--; // 移出 window if (window[c2] \u0026lt; needs[c2]) // 字符 c2 出现次数不再符合要求 match--; } left++; } } return res;  上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！\nstring minWindow(string s, string t) { // 记录最短子串的开始位置和长度 int start = 0, minLen = INT_MAX; int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; window; unordered_map\u0026lt;char, int\u0026gt; needs; for (char c : t) needs[c]++; int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; if (window[c1] == needs[c1]) match++; } right++; while (match == needs.size()) { if (right - left \u0026lt; minLen) { // 更新最小子串的位置和长度 start = left; minLen = right - left; } char c2 = s[left]; if (needs.count(c2)) { window[c2]--; if (window[c2] \u0026lt; needs[c2]) match--; } left++; } } return minLen == INT_MAX ? \u0026quot;\u0026quot; : s.substr(start, minLen); }  如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？\n这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。\n读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。\n二、找到字符串中所有字母异位词 这道题的难度是 Easy，但是评论区点赞最多的一条是这样：\nHow can this problem be marked as easy???\n实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解：\nvector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { // 用数组记录答案 vector\u0026lt;int\u0026gt; res; int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; needs; unordered_map\u0026lt;char, int\u0026gt; window; for (char c : t) needs[c]++; int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; if (window[c1] == needs[c1]) match++; } right++; while (match == needs.size()) { // 如果 window 的大小合适 // 就把起始索引 left 加入结果 if (right - left == t.size()) { res.push_back(left); } char c2 = s[left]; if (needs.count(c2)) { window[c2]--; if (window[c2] \u0026lt; needs[c2]) match--; } left++; } } return res; }  因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。\n三、无重复字符的最长子串 遇到子串问题，首先想到的就是滑动窗口技巧。\n类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复：\nint lengthOfLongestSubstring(string s) { int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; window; int res = 0; // 记录最长长度 while (right \u0026lt; s.size()) { char c1 = s[right]; window[c1]++; right++; // 如果 window 中出现重复字符 // 开始移动 left 缩小窗口 while (window[c1] \u0026gt; 1) { char c2 = s[left]; window[c2]--; left++; } res = max(res, right - left); } return res; }  需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。\n最后总结 通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：\nint left = 0, right = 0; while (right \u0026lt; s.size()) { window.add(s[right]); right++; while (valid) { window.remove(s[left]); left++; } }  其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。\n稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～\nJiajun 提供最小覆盖子串 Python3 代码：\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: # 最短子串开始位置和长度 start, min_len = 0, float('Inf') left, right = 0, 0 res = s # 两个计数器 needs = Counter(t) window = collections.defaultdict(int) # defaultdict在访问的key不存在的时候返回默认值0, 可以减少一次逻辑判断 match = 0 while right \u0026lt; len(s): c1 = s[right] if needs[c1] \u0026gt; 0: window[c1] += 1 if window[c1] == needs[c1]: match += 1 right += 1 while match == len(needs): if right - left \u0026lt; min_len: # 更新最小子串长度 min_len = right - left start = left c2 = s[left] if needs[c2] \u0026gt; 0: window[c2] -= 1 if window[c2] \u0026lt; needs[c2]: match -= 1 left += 1 return s[start:start+min_len] if min_len != float(\u0026quot;Inf\u0026quot;) else \u0026quot;\u0026quot;  ","id":329,"section":"posts","summary":"本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是","tags":["sliding_window"],"title":"滑动窗口技巧","uri":"https://foxisawesome.github.io/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/","year":"2020"},{"content":"LC 42 Trapping Rain Water   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n Solution 2020-08-05 Notes:\n 短边原理，左右指针同时走，r_max 大时短边在left，所以计算left side。 每一格计算下相较于短边的容水量即可  左右指针的 while loop，设为 l\u0026lt;=r 或者 了l\u0026lt;r 都一样，因为l=r跳出时只可能r_max = l_max = height[r]=height[l], water=0.    class Solution: def trap(self, height: List[int]) -\u0026gt; int: if not height: return 0 l, r = 0, len(height)-1 l_max, r_max = height[0], height[-1] ans = 0 while l \u0026lt; r: l_max = max(l_max, height[l]) r_max = max(r_max, height[r]) if l_max \u0026lt; r_max: ans += l_max - height[l] l += 1 else: ans += r_max - height[r] r -= 1 return ans # Time O(N) # Space O(1)  ","id":330,"section":"posts","summary":"LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: 短边原理，左右指针同时走，r_max 大时短边在left，所以计算lef","tags":["leetcode"],"title":"42 Trapping Rain Water","uri":"https://foxisawesome.github.io/posts/42-trapping-rain-water/","year":"2020"},{"content":"LC 206 Reverse Linked List   Reverse a singly linked list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   Solution 2020-09-01 Notes:\n  这题刷了不下10遍了，终于明白iteration这里的四步操作了。\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: # iteration def reverseList_iter(self, head: ListNode) -\u0026gt; ListNode: if not head: return None prev = None curr = head while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev # Time O(N) for iteration # Space O(1)   recursion的做法还是似懂非懂，还得再看看。感觉TreeNode, ListNode 的recursion 都是if not head/root: return head/root。 另外，recession 这里返回的是 以head.next为头reversed 的list，只需要再把head.next\t reverse 下就好了。  2020-9-12 Notes:\n睡了个午觉，顿悟了这个解法。\ninput: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 head head.next line#4: 1 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 head p head.next line#5: 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 p head.next head  # recursion def reverseList_rec(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p  可是这道题的进化版好难：LC 92\n","id":331,"section":"posts","summary":"LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL Solution 2020-09-01 Notes: 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next","tags":["leetcode","linkedList"],"title":"206 Reverse Linked List","uri":"https://foxisawesome.github.io/posts/206-reverse-linked-list/","year":"2020"},{"content":"这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。\n废话不多说，直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。\n代码方面，回溯算法的框架：\nresult = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择  其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。\n什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！\n一、全排列问题 我们在高中的时候就做过排列组合的数学题，我们也知道 n 个不重复的数，全排列共有 n! 个。\nPS：为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字。\n那么我们当时是怎么穷举全排列的呢？比方说给三个数 [1,2,3]，你肯定不会无规律地乱穷举，一般是这样：\n先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……\n其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：\n只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。\n为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上：\n你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。\n现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。\n如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：\n我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。\n再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：\nvoid traverse(TreeNode root) { for (TreeNode child : root.childern) // 前序遍历需要的操作 traverse(child); // 后序遍历需要的操作 }  而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：\n前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。\n回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：\n现在，你是否理解了回溯算法的这段核心框架？\nfor 选择 in 选择列表: # 做选择 将该选择从选择列表移除 路径.add(选择) backtrack(路径, 选择列表) # 撤销选择 路径.remove(选择) 将该选择再加入选择列表  我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。\n下面，直接看全排列代码：\nList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); /* 主函数，输入一组不重复的数字，返回它们的全排列 */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { // 记录「路径」 LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(nums, track); return res; } // 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 的那些元素 // 结束条件：nums 中的元素全都在 track 中出现 void backtrack(int[] nums, LinkedList\u0026lt;Integer\u0026gt; track) { // 触发结束条件 if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进入下一层决策树 backtrack(nums, track); // 取消选择 track.removeLast(); } }  我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 nums 和 track 推导出当前的选择列表：\n至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，因为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。\n但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。\n明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。\n二、N 皇后问题 这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。\nPS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。\n这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。\n直接套用框架:\nvector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; /* 输入棋盘边长 n，返回所有合法的放置 */ vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { // '.' 表示空，'Q' 表示皇后，初始化空棋盘。 vector\u0026lt;string\u0026gt; board(n, string(n, '.')); backtrack(board, 0); return res; } // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后一行 void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int n = board[row].size(); for (int col = 0; col \u0026lt; n; col++) { // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = 'Q'; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; } }  这部分主要代码，其实跟全排列问题差不多，isValid 函数的实现也很简单：\n/* 是否可以在 board[row][col] 放置皇后？ */ bool isValid(vector\u0026lt;string\u0026gt;\u0026amp; board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i \u0026lt; n; i++) { if (board[i][col] == 'Q') return false; } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == 'Q') return false; } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == 'Q') return false; } return true; }  函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：\n如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。\n当 N = 8 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。\n不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 isValid 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 N = 10 的时候，计算就已经很耗时了。\n有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。\n其实特别简单，只要稍微修改一下回溯算法的代码即可：\n// 函数找到一个答案后就返回 true bool backtrack(vector\u0026lt;string\u0026gt;\u0026amp; board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return true; } ... for (int col = 0; col \u0026lt; n; col++) { ... board[row][col] = 'Q'; if (backtrack(board, row + 1)) return true; board[row][col] = '.'; } return false; }  这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？\n三、最后总结 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：\ndef backtrack(...): for 选择 in 选择列表: 做选择 backtrack(...) 撤销选择  写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。\n其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？\n某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。\n致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\nZongshuai 提供全排列 Python3解法代码：\nclass Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: # 回溯算法 result = [] track = [] # 可行路径 def trackBack(nums_, track_): if len(track_) == len(nums_): # 满足终止条件 result.append(track_[:]) return for i in nums_: #所有可选项 if i in track_: # 判断是否可选 continue track.append(i) # 选择 trackBack(nums_, track_) # 递归 track.pop() # 回溯 trackBack(nums, track) return result  上一篇：动态规划答疑篇\n下一篇：二分查找解题框架\n目录\n","id":332,"section":"posts","summary":"这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套","tags":["backtracking"],"title":"回溯算法详解","uri":"https://foxisawesome.github.io/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/","year":"2020"},{"content":"LC 2 Add Two Num   You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807.   Solution 2020-07-02 Notes:  比较简单，但是 don’t forget line 17 and 25。  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: head = out = ListNode(0) carry = 0 while l1 and l2: carry, m = divmod(l1.val + l2.val + carry, 10) out.next = ListNode(m) l1 = l1.next l2 = l2.next out = out.next l = l1 if l1 else l2 while l: carry, m = divmod(l.val + carry, 10) out.next = ListNode(m) out = out.next l = l.next if carry \u0026gt; 0: out.next = ListNode(carry) return head.next # Time O(N) # Space O(1)  ","id":333,"section":"posts","summary":"LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt;","tags":["leetcode","linkedList"],"title":"2 Add Two Num","uri":"https://foxisawesome.github.io/posts/2-add-two-num/","year":"2020"},{"content":"LC 169 Majority Element   Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\n Solution 2020-09-24 Notes:  这道题有很多种方法做。  hash table做法。\nclass Solution: def majorityElement(self, nums: List[int]) -\u0026gt; int: d = dict() n = len(nums) target = n//2 for i in nums: d[i] = d.get(i,0) + 1 if d[i] \u0026gt; target: return i # Time O(N) # Space O(N)  sort\nclass Solution: def majorityElement(self, nums): nums.sort() return nums[len(nums)//2] # Time O(NlogN) # Space O(1)  还有divide and concur 等。\n","id":334,"section":"posts","summary":"LC 169 Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution 2020-09-24 Notes: 这道题有很多种方法做。 hash table做法。 class Solution:","tags":["leetcode","hashtable"],"title":"169 Majority Element","uri":"https://foxisawesome.github.io/posts/169-majority-element/","year":"2020"},{"content":"LC 204 Count Primes   Count the number of prime numbers less than a non-negative number, **n**.\n Solution 2020-09-12 Notes:   In mathematics, the sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.\n  class Solution: def countPrimes(self, n: int) -\u0026gt; int: if n \u0026lt; 2: return 0 grid = [1] * n grid[0] = 0 grid[1] = 0 for i in range(2,int(n**0.5)+1): if grid[i] == 0: continue for j in range(i*i, n, i): grid[j] = 0 return sum(grid) # Time O(NloglogN)?? # Space O(N)  ","id":335,"section":"posts","summary":"LC 204 Count Primes   Count the number of prime numbers less than a non-negative number, **n**.\n Solution 2020-09-12 Notes:   In mathematics, the sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.\n  class Solution: def countPrimes(self, n: int) -\u0026gt; int: if n \u0026lt; 2: return 0 grid = [1] * n grid[0] = 0 grid[1] = 0 for i in range(2,int(n**0.","tags":["leetcode","math","dia"],"title":"204 Count Primes","uri":"https://foxisawesome.github.io/posts/204-count-primes/","year":"2020"},{"content":"LC 69 Sqrtx   Implement int sqrt(int x).\nSqrt(8) = 2\n Solution 2020-03-07 Notes:  标准的binary search 模版， right 从x//2开始。  2020-10-06 Notes：  今天又做了一遍，这题虽然看起来像是寻找left bound，但其实就是return right binary search: l, r 一定是搜索的值域范围，然后while loop里的condition 构造一个 f(m) ~ target。有时是left bound， 有时是return m。  class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x: return mid elif mid**2 \u0026gt; x: right = mid -1 elif mid**2 \u0026lt; x: left = mid + 1 # exit at [right, left], hence return right return right # Time O(logN) # Space O(1)  ","id":336,"section":"posts","summary":"LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: 标准的binary search 模版， right 从x//2开始。 2020-10-06 Notes： 今天又做了一遍，这题虽然看起来像是寻找left bound","tags":["leetcode","binary_Search"],"title":"69 Sqrtx","uri":"https://foxisawesome.github.io/posts/69-sqrtx/","year":"2020"},{"content":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","id":337,"section":"posts","summary":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","tags":["leetcode","array","hashtable"],"title":"1 Two Sum","uri":"https://foxisawesome.github.io/posts/1-two-sum/","year":"2020"},{"content":"前缀和技巧 今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。\n那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行了。\n关键是，如何快速得到某个子数组的和呢，比如说给你一个数组 nums，让你实现一个接口 sum(i, j)，这个接口要返回 nums[i..j] 的和，而且会被多次调用，你怎么实现这个接口呢？\n因为接口要被多次调用，显然不能每次都去遍历 nums[i..j]，有没有一种快速的方法在 O(1) 时间内算出 nums[i..j] 呢？这就需要前缀和技巧了。\n一、什么是前缀和 前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：\nint n = nums.length; // 前缀和数组 int[] preSum = new int[n + 1]; preSum[0] = 0; for (int i = 0; i \u0026lt; n; i++) preSum[i + 1] = preSum[i] + nums[i];  这个前缀和数组 preSum 的含义也很好理解，preSum[i] 就是 nums[0..i-1] 的和。那么如果我们想求 nums[i..j] 的和，只需要一步操作 preSum[j+1]-preSum[i] 即可，而不需要重新去遍历数组了。\n回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：\nint subarraySum(int[] nums, int k) { int n = nums.length; // 构造前缀和 int[] sum = new int[n + 1]; sum[0] = 0; for (int i = 0; i \u0026lt; n; i++) sum[i + 1] = sum[i] + nums[i]; int ans = 0; // 穷举所有子数组 for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; i; j++) // sum of nums[j..i-1] if (sum[i] - sum[j] == k) ans++; return ans; }  这个解法的时间复杂度 $O(N^2)$ 空间复杂度 $O(N)$，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。\n二、优化解法 前面的解法有嵌套的 for 循环：\nfor (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; i; j++) if (sum[i] - sum[j] == k) ans++;  第二层 for 循环在干嘛呢？翻译一下就是，**在计算，有几个 j 能够使得 sum[i] 和 sum[j] 的差为 k。**毎找到一个这样的 j，就把结果加一。\n我们可以把 if 语句里的条件判断移项，这样写：\nif (sum[j] == sum[i] - k) ans++;  优化的思路是：我直接记录下有几个 sum[j] 和 sum[i] - k 相等，直接更新结果，就避免了内层的 for 循环。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。\nint subarraySum(int[] nums, int k) { int n = nums.length; // map：前缀和 -\u0026gt; 该前缀和出现的次数 HashMap\u0026lt;Integer, Integer\u0026gt; preSum = new HashMap\u0026lt;\u0026gt;(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i \u0026lt; n; i++) { sum0_i += nums[i]; // 这是我们想找的前缀和 nums[0..j] int sum0_j = sum0_i - k; // 如果前面有这个前缀和，则直接更新答案 if (preSum.containsKey(sum0_j)) ans += preSum.get(sum0_j); // 把前缀和 nums[0..i] 加入并记录出现次数 preSum.put(sum0_i, preSum.getOrDefault(sum0_i, 0) + 1); } return ans; }  比如说下面这个情况，需要前缀和 8 就能找到和为 k 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。\n这样，就把时间复杂度降到了 $O(N)$，是最优解法了。\n三、总结 前缀和不难，却很有用，主要用于处理数组区间的问题。\n比如说，让你统计班上同学考试成绩在不同分数段的百分比，也可以利用前缀和技巧：\nint[] scores; // 存储着所有同学的分数 // 试卷满分 150 分 int[] count = new int[150 + 1] // 记录每个分数有几个同学 for (int score : scores) count[score]++ // 构造前缀和 for (int i = 1; i \u0026lt; count.length; i++) count[i] = count[i] + count[i-1];  这样，给你任何一个分数段，你都能通过前缀和相减快速计算出这个分数段的人数，百分比也就很容易计算了。\n但是，稍微复杂一些的算法问题，不止考察简单的前缀和技巧。比如本文探讨的这道题目，就需要借助前缀和的思路做进一步的优化，借助哈希表去除不必要的嵌套循环。可见对题目的理解和细节的分析能力对于算法的优化是至关重要的。\n希望本文对你有帮助。\n坚持原创高质量文章，致力于把算法问题讲清楚，欢迎关注我的公众号 labuladong 获取最新文章：\nlabuladong 提供JAVA解法代码：\nint subarraySum(int[] nums, int k) { int n = nums.length; // map：前缀和 -\u0026gt; 该前缀和出现的次数 HashMap\u0026lt;Integer, Integer\u0026gt; preSum = new HashMap\u0026lt;\u0026gt;(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i \u0026lt; n; i++) { sum0_i += nums[i]; // 这是我们想找的前缀和 nums[0..j] int sum0_j = sum0_i - k; // 如果前面有这个前缀和，则直接更新答案 if (preSum.containsKey(sum0_j)) ans += preSum.get(sum0_j); // 把前缀和 nums[0..i] 加入并记录出现次数 preSum.put(sum0_i, preSum.getOrDefault(sum0_i, 0) + 1); } return ans; }  Jinglun Zhou 提供C++解法代码：\nclass Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n=nums.size(); unordered_map\u0026lt;int,int\u0026gt; preSum; // map: 前缀和 -\u0026gt; 该前缀和出现的次数 preSum[0]=1; // base case: 例如当数组中只有一个元素， 而k恰好等于这个元素 int ans=0, sum0_i=0; // sum0_i 表示前缀和 nums[0...i] for(int i=0;i\u0026lt;n;i++) { sum0_i +=nums[i]; // 这是我们想找的前缀和 nums[0...j] int sum0_j=sum0_i-k; // 如果前面有这个前缀和，则直接更新答案 if(preSum.count(sum0_j)) ans+=preSum[sum0_j]; //把前缀和 nums[0...i] 加入并记录出现次数 preSum[sum0_i]++; // 把当前的前缀和加入到map中 } return ans; } };  上一篇：烧饼排序\n下一篇：字符串乘法\n目录\n","id":338,"section":"posts","summary":"前缀和技巧 今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。 那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行","tags":null,"title":"","uri":"https://foxisawesome.github.io/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/","year":"0001"}],"tags":[{"title":"array","uri":"https://foxisawesome.github.io/tags/array/"},{"title":"backtracking","uri":"https://foxisawesome.github.io/tags/backtracking/"},{"title":"BFS","uri":"https://foxisawesome.github.io/tags/bfs/"},{"title":"binary_search","uri":"https://foxisawesome.github.io/tags/binary_search/"},{"title":"BST","uri":"https://foxisawesome.github.io/tags/bst/"},{"title":"DFS","uri":"https://foxisawesome.github.io/tags/dfs/"},{"title":"dia","uri":"https://foxisawesome.github.io/tags/dia/"},{"title":"dia_sql","uri":"https://foxisawesome.github.io/tags/dia_sql/"},{"title":"dp","uri":"https://foxisawesome.github.io/tags/dp/"},{"title":"GRAPH","uri":"https://foxisawesome.github.io/tags/graph/"},{"title":"greedy","uri":"https://foxisawesome.github.io/tags/greedy/"},{"title":"hashtable","uri":"https://foxisawesome.github.io/tags/hashtable/"},{"title":"heap","uri":"https://foxisawesome.github.io/tags/heap/"},{"title":"leetcode","uri":"https://foxisawesome.github.io/tags/leetcode/"},{"title":"linkedlist","uri":"https://foxisawesome.github.io/tags/linkedlist/"},{"title":"martix","uri":"https://foxisawesome.github.io/tags/martix/"},{"title":"math","uri":"https://foxisawesome.github.io/tags/math/"},{"title":"matrix","uri":"https://foxisawesome.github.io/tags/matrix/"},{"title":"monotonic","uri":"https://foxisawesome.github.io/tags/monotonic/"},{"title":"recursion","uri":"https://foxisawesome.github.io/tags/recursion/"},{"title":"sliding_window","uri":"https://foxisawesome.github.io/tags/sliding_window/"},{"title":"sort","uri":"https://foxisawesome.github.io/tags/sort/"},{"title":"stack","uri":"https://foxisawesome.github.io/tags/stack/"},{"title":"string","uri":"https://foxisawesome.github.io/tags/string/"},{"title":"template","uri":"https://foxisawesome.github.io/tags/template/"},{"title":"tree","uri":"https://foxisawesome.github.io/tags/tree/"},{"title":"two_pointers","uri":"https://foxisawesome.github.io/tags/two_pointers/"}]}