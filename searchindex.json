{"categories":[{"title":"algo","uri":"https://foxisawesome.github.io/categories/algo/"},{"title":"SQL","uri":"https://foxisawesome.github.io/categories/sql/"}],"posts":[{"content":"LC 1539 Kth Missing Positive Number   Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nInput: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.   Solution 2020-09-07 Notes:\n O(N) solution is pretty easy, but not optimal. the binary solution is optimal.  arr[i]-(i+1): 返回的是 arr[i]和i+1 之间miss了几个数，如果arr没miss数，返回的因该是0. 所以这个条件和k比较可以快速找到最接近的位置。 我疏忽的是：binary search 跳出条件是 l==r in this case, 并不是 arr[i]-(i+1)==k。所以只能return l+k。还有这题是求逼近，而不是找 exact的 target (需要保证存在唯一解，才能用)，所以在binary search时例举 arr[i]-(i+1)==k 跳出会报错。所以 while l \u0026lt; r 外加列举\u0026lt;和 \u0026gt;=两种情况这种写法才对。 另外这题是 1-indexed，所以会有 i+1, l+k 这种小细节要搞清。    class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr)-1 while l\u0026lt;r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m - 1 return l+k # Time O(logN) # Space O(1)  class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: stack = [] if arr[-1] - len(arr) \u0026lt; k: return arr[-1]+(k-arr[-1]+len(arr)) elif arr[-1] - len(arr) \u0026gt;= k: stack = [i for i in range(1, arr[-1]+1)] [stack.remove(i) for i in arr] return stack[k-1] # Time O(N) # Space O(N)  ","id":0,"section":"posts","summary":"LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary","tags":["leetcode","binarySearch"],"title":"1539 Kth Missing Positive Number","uri":"https://foxisawesome.github.io/1539-kth-missing-positive-number/","year":"2020"},{"content":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","id":1,"section":"posts","summary":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","tags":["leetcode","hashtable"],"title":"1512 Number of Good Pairs","uri":"https://foxisawesome.github.io/1512-number-of-good-pairs/","year":"2020"},{"content":"SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.\nHere is an example that shows how to compare each employee\u0026rsquo;s salary with the average salary in his or her department:\nSELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary; depname | empno | salary | avg -----------+-------+--------+------ develop | 11 | 5200 | 5020 develop | 7 | 4200 | 5020 develop | 9 | 4500 | 5020 develop | 8 | 6000 | 5020 develop | 10 | 5200 | 5020 personnel | 5 | 3500 | 3700 personnel | 2 | 3900 | 3700 sales | 3 | 4800 | 4866 sales | 1 | 5000 | 4866 sales | 4 | 4800 | 4866 (10 rows)  The first three output columns come directly from the table empsalary, and there is one output row for each row in the table. The fourth column represents an average taken across all the table rows that have the same depname value as the current row. (This actually is the same function as the regular avg aggregate function, but the OVER clause causes it to be treated as a window function and computed across an appropriate set of rows.)\nA window function call always contains an OVER clause directly following the window function\u0026rsquo;s name and argument(s). This is what syntactically distinguishes it from a regular function or aggregate function. The OVER clause determines exactly how the rows of the query are split up for processing by the window function. The PARTITION BY list within OVER specifies dividing the rows into groups, or partitions, that share the same values of the PARTITION BY expression(s). For each row, the window function is computed across the rows that fall into the same partition as the current row.\nYou can also control the order in which rows are processed by window functions using ORDER BY within OVER. (The window ORDER BY does not even have to match the order in which the rows are output.) Here is an example:\nSELECT depname, empno, salary, rank() OVER (PARTITION BY depname ORDER BY salary DESC) FROM empsalary; depname | empno | salary | rank -----------+-------+--------+------ develop | 8 | 6000 | 1 develop | 10 | 5200 | 2 develop | 11 | 5200 | 2 develop | 9 | 4500 | 4 develop | 7 | 4200 | 5 personnel | 2 | 3900 | 1 personnel | 5 | 3500 | 2 sales | 1 | 5000 | 1 sales | 4 | 4800 | 2 sales | 3 | 4800 | 2 (10 rows)  As shown here, the rank function produces a numerical rank within the current row\u0026rsquo;s partition for each distinct ORDER BY value, in the order defined by the ORDER BY clause. rank needs no explicit parameter, because its behavior is entirely determined by the OVER clause.\n==The rows considered by a window function are those of the \u0026ldquo;virtual table\u0026rdquo; produced by the query\u0026rsquo;s FROM clause as filtered by its WHERE, GROUP BY, and HAVING clauses if any==. For example, a row removed because it does not meet the WHERE condition is not seen by any window function. A query can contain multiple window functions that slice up the data in different ways by means of different OVER clauses, but they all act on the same collection of rows defined by this virtual table.\nWe already saw that ORDER BY can be omitted if the ordering of rows is not important. It is also possible to omit PARTITION BY, in which case there is just one partition containing all the rows.\nThere is another important concept associated with window functions: for each row, there is a set of rows within its partition called its window frame. Many (but not all) window functions act only on the rows of the window frame, rather than of the whole partition. By default, if ORDER BY is supplied then the frame consists of all rows from the start of the partition up through the current row, plus any following rows that are equal to the current row according to the ORDER BY clause. When ORDER BY is omitted the default frame consists of all rows in the partition. [1] Here is an example using sum:\nSELECT salary, sum(salary) OVER () FROM empsalary; salary | sum --------+------- 5200 | 47100 5000 | 47100 3500 | 47100 4800 | 47100 3900 | 47100 4200 | 47100 4500 | 47100 4800 | 47100 6000 | 47100 5200 | 47100 (10 rows)  Above, since there is no ORDER BY in the OVER clause, the window frame is the same as the partition, which for lack of PARTITION BY is the whole table; in other words each sum is taken over the whole table and so we get the same result for each output row. But if we add an ORDER BY clause, we get very different results:\nSELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary; salary | sum --------+------- 3500 | 3500 3900 | 7400 4200 | 11600 4500 | 16100 4800 | 25700 4800 | 25700 5000 | 30700 5200 | 41100 5200 | 41100 6000 | 47100 (10 rows)  Here the sum is taken from the first (lowest) salary up through the current one, ==including any duplicates of the current one (notice the results for the duplicated salaries)==.\nWindow functions are permitted only in the SELECT list and the ORDER BY clause of the query. ==They are forbidden elsewhere, such as in GROUP BY, HAVING and WHERE clauses. This is because they logically execute after the processing of those clauses.== ==Also, window functions execute after regular aggregate functions.== This means it is valid to include an aggregate function call in the arguments of a window function, but not vice versa.\nIf there is a need to filter or group rows after the window calculations are performed, you can use a sub-select. For example:\nSELECT depname, empno, salary, enroll_date FROM (SELECT depname, empno, salary, enroll_date, rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos FROM empsalary ) AS ss WHERE pos \u0026lt; 3;  The above query only shows the rows from the inner query having rank less than 3.\nWhen a query involves multiple window functions, it is possible to write out each one with a separate OVER clause, but this is duplicative and error-prone if the same windowing behavior is wanted for several functions. Instead, each windowing behavior can be named in a WINDOW clause and then referenced in OVER. For example:\nSELECT sum(salary) OVER w, avg(salary) OVER w FROM empsalary WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);  Some functions   ROUND(var,2)\n  IFNULL(var,0)\n  COUNT(*) is all rows in the table, COUNT(Expression) is where the expression is non-null only.\n  DATEDIFF(date1, date2)=1`: date1 - date2 = 1 day, datediff(curdate(), data_var) \u0026lt;= 7\n  date should use purchase_date between start_date and end_date instead of start_date\u0026lt;= purchase_date \u0026lt;=end_date (see LC1251)\n  When you add an order by to an aggregate used as a window function that aggregate turns into a \u0026ldquo;running count\u0026rdquo; (or whatever aggregate you use). link\nThe count(*) will return the number of rows up until the \u0026ldquo;current one\u0026rdquo; based on the order specified.\n  2020-07-16 to 2020-07 LEFT(trans_date, 7) AS month or DATE_FORMAT(trans_date, '%Y-%m') AS month\n  The only difference between Union and Union All is that ==Union All will not removes duplicate rows or records==, instead, it just selects all the rows from all the tables which meets the conditions of your specifics query and combines them into the result table.\n  group_concat()\nActivities table: +------------+-------------+ | sell_date | product | +------------+-------------+ | 2020-05-30 | Headphone | | 2020-06-01 | Pencil | | 2020-06-02 | Mask | | 2020-05-30 | Basketball | | 2020-06-01 | Bible | | 2020-06-02 | Mask | | 2020-05-30 | T-Shirt | +------------+-------------+ Result table: +------------+----------+------------------------------+ | sell_date | num_sold | products | +------------+----------+------------------------------+ | 2020-05-30 | 3 | Basketball,Headphone,T-shirt | | 2020-06-01 | 2 | Bible,Pencil | | 2020-06-02 | 1 | Mask | +------------+----------+------------------------------+ select sell_date, count(distinct product) as num_sold, group_concat(distinct product order by product asc separator ',') as products from activities group by sell_date order by sell_date    Common Table Expressions (CTE) WITH cte1 AS (SELECT a, b FROM table1), cte2 AS (SELECT c, d FROM table2) SELECT b, d FROM cte1 JOIN cte2 WHERE cte1.a = cte2.c;  Aggregation Function  LC585: Investments in 2016\nWrite a query to print the sum of all total investment values in 2016 (TIV_2016), to a scale of 2 decimal places, for all policy holders who meet the following criteria:\n Have the same TIV_2015 value as one or more other policyholders (none unique tiv_2015). Are not located in the same city as any other policyholder (i.e.: the (latitude, longitude) attribute pairs must be unique).   select sum(TIV_2016) as TIV_2016 from insurance where TIV_2015 in (select TIV_2015 from insurance group by TIV_2015 having sum(1)\u0026gt;1) and pid in (select pid from insurance group by CONCAT(lat, lon) having sum(1) \u0026lt; 2)   LC 1369: Get the Second Most Recent Activity: Write an SQL query to show the second most recent activity of each user. If the user only has one activity, return that one. A user can\u0026rsquo;t perform more than one activity at the same time. Return the result table in any order.\n select username, activity, startDate, endDate from ( select *, count(activity) over(partition by username) ct, row_number() over(partition by username order by startdate desc) nb_act from UserActivity ) a where a.ct \u0026lt; 2 or nb_act=2  Rank Scores  LC178: Rank Scores Write a SQL query to rank scores. If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no \u0026ldquo;holes\u0026rdquo; between ranks.\n # dense_rank() solution (faster): select score, dense_rank() over(order by score desc) as rank from scores order by rank desc # rank algo solution: select score, (select count(distinct score) from scores b where b.score\u0026gt;=a.score) as 'rank' from scores a order by 'rank'   LC 185: Department Top Three Salaries Write a SQL query to find employees who earn the top three salaries in each of the department. For the above tables, your SQL query should return the following rows (order of rows does not matter).\n select b.name as Department, a.name as Employee, a.Salary from employee a inner join department b on a.departmentID = b.id where 3 \u0026gt;= ( select count(distinct c.salary) from employee c where c.salary \u0026gt;= a.salary and c.departmentid = a.departmentid )   LC 1355. Activity Participants: Write an SQL query to find the names of all the activities with neither maximum, nor minimum number of participants.\n select activity from ( select activity, dense_rank() over(order by count(id) desc) as rank_desc, dense_rank() over(order by count(id)) as rank_asc from friends group by activity ) a where a.rank_desc != 1 and a.rank_asc != 1  Rolling window, cumulative sum  LC 579. Find Cumulative Salary of an Employee: Write a SQL to get the cumulative sum of an employee\u0026rsquo;s salary over a period of 3 months but exclude the most recent month.\n select id, month, sum(salary) over(partition by id order by month rows 2 preceding) as salary from employee a where a.month \u0026lt; (select max(month) from employee where id = a.id) order by id, month desc;  Note:\n sum(salary) over(partition by id order by month) gives cumulative sum for each id. sum() over(XXX rows 2 preceding) gives a rolling window for sum over only 3 months. or sum(salary) over(order by date desc rows between 2 preceding and current row) where a.month \u0026lt; (select max(month) from employee where id = a.id) this excludes the most recent month row for each id.  Rolling Average  hive rolling average when some days missing: I am working with hive on huge dataset and trying rolling average for past one week with missing dates in the input table.\n select date, volume, avg(volume) over(order by date rows between 6 preceding and current row) as row7_avg, avg(volume) over(order by date range between 6 preceding and current row) as moving_avg, sum(volume) over(order by date range between 6 preceding and current row)/7 as avg_weekly from job_history  notes:\n ==range between== will account for missing dates row between will skip missing dates, just going back 6 rows avg() will skip rows not showing up in the table. one should use sum()/7 to account for weekly avg.  Lead function  LC 1454. Active Users:Write an SQL query to find the id and the name of active users. Active users are those who logged in to their accounts for 5 or more consecutive days. Return the result table ordered by the id.\n select distinct a.id, a.name from accounts a join ( select id, login_date, lead(login_date,4) over(partition by id order by login_date) as lead_date from (select distinct id, login_date from logins) c ) b on a.id = b.id where datediff(lead_date, login_date) = 4 order by 1  Note:\n lead(date) need to accompany with partition by and order by same time in line 5 consecutive algo is using lead() with datediff() in line 9  Self Join no duplicates  What we have: [A1, A2, A3, B1, B2, C1, C2]. what to archive: [A1 A2, A1 A3, A2 A3, B1 B2, C1 C2]\n SELECT mytable.*, self.* FROM mytable INNER JOIN mytable AS self ON (mytable.letter = self.letter and mytable.number \u0026gt; self.number)  Notes: self join use inner join, mytable.number \u0026gt; self.number do not use != to avoid duplicated rows.\n LC 182. Duplicate Emails:\n select distinct a.email from person a inner join person b on a.id \u0026gt; b.id and a.email = b.email  Consecutive rows  LC 603. Consecutive Available Seats Several friends at a cinema ticket office would like to reserve consecutive available seats. Can you help to query all the consecutive available seats order by the seat_id using the following cinema table?\n select distinct a.seat_id from cinema a join cinema b on abs(a.seat_id - b.seat_id) = 1 and a.free = 1 and b.free = 1 order by a.seat_id  Note: 1. self join; 2. id - 1, id + 1\nSome good excises  LC 626. Exchange Seats: Mary is a teacher in a middle school and she has a table seat storing students\u0026rsquo; names and their corresponding seat ids. The column id is continuous increment. Mary wants to change seats for the adjacent students. Can you write a SQL query to output the result for Mary?\n # solution 1 select case when mod(id, 2) != 0 and counts != id then id +1 when mod(id, 2) != 0 and counts = id then id else id - 1 end as id, student from seat, (select count(*) as counts from seat) as seat_counts order by id; # solution 2 SELECT s1.id, s2.student FROM seat s1, seat s2 WHERE (CASE WHEN s1.id%2 = 1 AND s1.id = (SELECT MAX(id) FROM seat) THEN s1.id = s2.id WHEN s1.id%2=0 THEN s1.id = s2.id + 1 ELSE s2.id = s1.id +1 END) ORDER BY s1.id;  Note: from a, b is a implicit join, one should put on condition in where clause. if no join condition specified, then it is a cartesian join.\nOuter join  We have two tables. One table has all mobile actions, i.e. all pages visited by the users on mobile. The other table has all web actions, i.e. all pages visited on web by the users.\nWrite a query that returns the percentage of users who only visited mobile, only web and both. That is, the percentage of users who are only in the mobile table, only in the web table and in both tables. The sum of the percentages should return 1.\n SELECT 100*SUM(CASE WHEN m.user_id IS null THEN 1 ELSE 0 END)/COUNT(*) as WEB_ONLY, 100*SUM(CASE WHEN w.user_id IS null THEN 1 ELSE 0 END)/COUNT(*) as MOBILE_ONLY, 100*SUM(CASE WHEN m.user_id IS NOT null AND w.user_id IS NOT null THEN 1 ELSE 0 END)/COUNT(*) as BOTH FROM (SELECT distinct user_id FROM query_two_web ) w FULL OUTER JOIN (SELECT distinct user_id FROM query_two_mobile ) m ON m.user_id = w.user_id;  Median Algo  We have two tables. One is user id and their signup date. The other one shows all transactions done by those users, when the transaction happens and its corresponding dollar amount.\nFind the average and median transaction amount only considering those transactions that happen on the same date as that user signed-up.\n row_asc | row_desc 1 | 5 2 | 4 3 | 3 --- row_asc is between row_desc -1 and row_desc +1 4 | 2 5 | 1 ---- SELECT AVG(transaction_amount) AS average, AVG(CASE WHEN row_num_asc BETWEEN row_num_desc-1 and row_num_desc+1 THEN transaction_amount ELSE NULL END ) AS median FROM ( SELECT transaction_amount, ROW_NUMBER() OVER(ORDER BY transaction_amount) row_num_asc, COUNT(*) OVER() - ROW_NUMBER() OVER(ORDER BY transaction_amount) + 1 AS row_num_desc FROM query_five_users a JOIN (SELECT *, to_date(transaction_date) AS date_only FROM query_five_transactions) b ON a.user_id = b.user_id AND a.sign_up_date = b.date_only ) tmp;  Find country with minimum and max accounts SELECT country, user_count FROM ( SELECT *, ROW_NUMBER() OVER (ORDER BY user_count) as count_asc, ROW_NUMBER() OVER (ORDER BY user_count desc) as count_desc FROM ( SELECT country, COUNT(distinct user_id) as user_count FROM query_six GROUP BY country )a ) tmp WHERE count_asc = 1 or count_desc = 1;  Find MAX() or MIN() from consecutive records Basic idea: MAX() or MIN() group by feature - row index\n LC 1225. Report Contiguous Dates\nhttps://leetcode.com/problems/report-contiguous-dates/\n WITH combined as ( SELECT fail_date as dt, 'failed' as period_state, DAYOFYEAR(fail_date) - row_number() over(ORDER BY fail_date) as period_group FROM Failed WHERE fail_date BETWEEN '2019-01-01' AND '2019-12-31' UNION ALL SELECT success_date as dt, 'succeeded' as period_state, DAYOFYEAR(success_date) - row_number() over(ORDER BY success_date) as period_group FROM Succeeded WHERE success_date BETWEEN '2019-01-01' AND '2019-12-31' ) SELECT period_state, min(dt) as start_date, max(dt) as end_date FROM combined GROUP BY period_state, period_group ORDER BY start_date   LC 1285. Find the Start and End Number of Continuous Ranges\nhttps://leetcode.com/problems/find-the-start-and-end-number-of-continuous-ranges/\n SELECT min(log_id) as start_id, max(log_id) as end_id FROM (SELECT log_id, ROW_NUMBER() OVER(ORDER BY log_id) as num FROM Logs) a GROUP BY log_id - num  Pivot Table Trick  | name | continent | |--------|-----------| | Jack | America | | Pascal | Europe | | Xi | Asia | | Jane | America |  to this:\n| America | Asia | Europe | |---------|------|--------| | Jack | Xi | Pascal | | Jane | | |   SELECT MAX(CASE WHEN continent = 'America' THEN name ELSE NULL END) AS America, MAX(CASE WHEN continent = 'Asia' THEN name ELSE NULL END) AS Asia, MAX(CASE WHEN continent = 'Europe' THEN name ELSE NULL END) AS Europe FROM ( SELECT *, ROW_NUMBER() OVER(PARTITION BY continent ORDER BY NAME) AS row_id FROM student ) a GROUP BY row_id ORDER BY row_id  note:\n ROW_NUMBER() + GROUP BY : will give out name by continent MAX() will remove NULL for each continent  SQL function sample  LC177. Nth Highest Salary): Write a SQL query to get the nth highest salary from the Employee table. For example, given the above Employee table, the nth highest salary where n = 2 is 200. If there is no nth highest salary, then the query should return null. input: {\u0026ldquo;headers\u0026rdquo;: {\u0026ldquo;Employee\u0026rdquo;: [\u0026ldquo;Id\u0026rdquo;, \u0026ldquo;Salary\u0026rdquo;]}, \u0026ldquo;argument\u0026rdquo;: 2, \u0026ldquo;rows\u0026rdquo;: {\u0026ldquo;Employee\u0026rdquo;: [[1, 100], [2, 200], [3, 300]]}}\n CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT BEGIN declare m int; set m = n-1; RETURN ( select salary from Employee group by salary order by salary desc limit m, 1 ); END  ","id":2,"section":"posts","summary":"SQL Notes Window Functions A window function performs a calculation across a set of table rows that are somehow related to the current row. This is comparable to the type of calculation that can be done with an aggregate function. But ==unlike regular aggregate functions, use of a window function does not cause rows to become grouped into a single output row — the rows retain their separate identities==. Behind the scenes, the window function is able to access more than just the current row of the query result.","tags":["template"],"title":"SQL Notes","uri":"https://foxisawesome.github.io/sql-notes/","year":"2020"},{"content":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case. need to take int(a/b) I was scared what if the division tests on a infinite unreapted, then toasted. However, the test cases have none. convet all calc to postive nums once determined. Loop through mod and record each mod’s index place.  class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -\u0026gt; str: if denominator == 0: return '' ans = '-' if numerator * denominator \u0026lt; 0 else '' numerator, denominator = abs(numerator), abs(denominator) d = dict() div, mod = self.myDivmod(numerator, denominator) if mod == 0: ans += str(div) return ans ans += str(div) + '.' d[mod] = len(ans) while mod: div, mod = self.myDivmod(mod*10, denominator) ans += str(div) if mod in d: idx = d[mod] ans = ans[:idx] + '(' + ans[idx:] + ')' break else: d[mod] = len(ans) return ans def myDivmod(self, a, b): d = int(a/b) m = a - d*b return (d, m)  ","id":3,"section":"posts","summary":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case.","tags":["leetcode"],"title":"166 Fraction to Recurring Decimal","uri":"https://foxisawesome.github.io/166-fraction-to-recurring-decimal/","year":"2020"},{"content":"LC 159 Longest Substring With at Most Two Distinct Characters   Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters.\nInput: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5.   Solution 2020-09-05 Notes:\n 今天周末出去走了一圈，回家刷题效率可以啊。  class Solution: def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u0026gt; int: if not s: return 0 out = 0 n = len(s) for i in range(n): l = 1 while i+l \u0026lt; n and len(set(s[i:i+l+1])) \u0026lt; 3: l += 1 out = max(out, l) return out # Time O(N) # Space O(1)  ","id":4,"section":"posts","summary":"LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def","tags":["leetcode"],"title":"159 Longest Substring With at Most Two Distinct Characters","uri":"https://foxisawesome.github.io/159-longest-substring-with-at-most-two-distinct-characters/","year":"2020"},{"content":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.add(num) else: stack.remove(num) return stack.pop() # Time O(N) # Space O(N)  If we take XOR of zero and some bit, it will return that bit: $a \\oplus 0 = a$ If we take XOR of two same bits, it will return 0: $a \\oplus a = 0$\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for num in nums: a ^= num return a  class Solution(object): def singleNumber(self, nums): return 2 * sum(set(nums)) - sum(nums)  ","id":5,"section":"posts","summary":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.","tags":["leetcode"],"title":"136 Single Number","uri":"https://foxisawesome.github.io/136-single-number/","year":"2020"},{"content":"LC 187 Repeated Dna Sequences   All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n Solution 2020-09-05 Notes:\n 很简单的题，两个小陷进：  Substring = s[i-9:i+1] NOT s[i-10:i] because 0-indexed. avoid dups in the output.    class Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: n = len(s) if not s or n\u0026lt;10: return [] count = dict() out = [] for i in range(9,n): entry = s[i-9:i+1] ct = count.get(entry,0) + 1 count[entry]= ct if ct \u0026gt; 1 and entry not in out: out.append(entry) return out # Time O(N) # Space O(1)  ","id":6,"section":"posts","summary":"LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷","tags":["leetcode"],"title":"187 Repeated Dna Sequences","uri":"https://foxisawesome.github.io/187-repeated-dna-sequences/","year":"2020"},{"content":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","id":7,"section":"posts","summary":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","tags":["leetcode"],"title":"1249 Minimum Remove to Make Valid Parentheses","uri":"https://foxisawesome.github.io/1249-minimum-remove-to-make-valid-parentheses/","year":"2020"},{"content":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Sam e\n  class Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: count = dict() stack = [] for l in s: count[l] = count.get(l,0) + 1 for c in s: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":8,"section":"posts","summary":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration.","tags":["leetcode"],"title":"316 Remove Dup Letters","uri":"https://foxisawesome.github.io/316-remove-dup-letters/","year":"2020"},{"content":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Same as LC 316\n  class Solution: def smallestSubsequence(self, text: str) -\u0026gt; str: count = dict() stack = [] for l in text: count[l] = count.get(l,0) + 1 for c in text: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":9,"section":"posts","summary":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.","tags":["leetcode"],"title":"1081 Smallest Subsequence of Distinct Char","uri":"https://foxisawesome.github.io/1081-smallest-subsequence-of-distinct-char/","year":"2020"},{"content":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.get(nums[fast],0) + 1 if count[nums[fast]] \u0026lt;= 2: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":10,"section":"posts","summary":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.","tags":["leetcode","twopointers"],"title":"80 Remove Dup From Sorted Array II","uri":"https://foxisawesome.github.io/80-remove-dup-from-sorted-array-ii/","year":"2020"},{"content":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.   Solution 2020-09-04 Notes:\n Two pointers: slow and fast. updates when fast == slow.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: slow, fast = 0, 1 while fast \u0026lt; len(nums): if nums[fast] != nums[slow]: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":11,"section":"posts","summary":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.","tags":["leetcode","twopointers"],"title":"26 Remove Dup From Sorted Array","uri":"https://foxisawesome.github.io/26-remove-dup-from-sorted-array/","year":"2020"},{"content":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: nums.sort() return self.kSum(nums, target, 4) def kSum(self, nums: List[int], target: int, k: int) -\u0026gt; List[List[int]]: res = [] if len(nums)==0 or nums[0] * k \u0026gt; target or nums[-1] * k \u0026lt; target: return res if k == 2: return self.twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for _, val in enumerate(self.kSum(nums[i+1:], target-nums[i], k-1)): res.append([nums[i]] + val) return res def twoSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: res = [] lo, hi = 0, len(nums) - 1 while (lo \u0026lt; hi): sum = nums[lo] + nums[hi] if sum \u0026lt; target or (lo \u0026gt; 0 and nums[lo] == nums[lo - 1]): lo += 1 elif sum \u0026gt; target or (hi \u0026lt; len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res # Time O(N^(k-1)) # Space O(N)  ","id":12,"section":"posts","summary":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):","tags":["leetcode"],"title":"18 K Sum","uri":"https://foxisawesome.github.io/18-k-sum/","year":"2020"},{"content":"LC 140 Word Break II   Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\nInput: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ]   Solution 2020-09-03 Notes:\n 第一次尝试，哇！这不是和 word break 一摸一样嘛。照模版写了个bt如下，试了两个例子都过了。提交了才发现，严重超时。一看官方解答是dp做的，感叹要不怎么是medium，一题是hard呢。但我觉得我要能加上memo 跟下面的dfs应该是同理。 于是看了大牛的解答，带memo的recursion是可以过的  # backtracking, exceed time limit! class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) out = [] self.backtracking(s,wordDict,[],out,n) return out def backtracking(self, s, wordDict, path, out, n): m = len(s) if m == 0: out.append(\u0026quot; \u0026quot;.join(path)) return for i in range(m): if s[:i+1] in wordDict: path.append(s[:i+1]) for self.backtracking(s[i+1:], wordDict, path, out, n) path.pop() # Time O() # Space O()  recursion with memo:\n need to add () to this res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)). Otherwise, it will interperate as res.append((w + '') if not r else (\u0026quot; \u0026quot; + r))  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: res = [] memo = dict() return self.dfs(s,wordDict,memo) def dfs(self, s,wordDict,memo): if s in memo: return memo[s] if not s: return [\u0026quot;\u0026quot;] res = [] for w in wordDict: if s[:len(w)] == w: for r in self.dfs(s[len(w):], wordDict, memo): res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)) memo[s] = res return res  ","id":13,"section":"posts","summary":"LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] Solution 2020-09-03 Notes: 第一","tags":["leetcode","dp","recursion","backtracking"],"title":"140 Word Break II","uri":"https://foxisawesome.github.io/140-word-break-ii/","year":"2020"},{"content":"LC 128 Longest Consecutive Sequence   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Solution 2020-09-03 Notes:\n  题目 time complexity 要求O(N)，那没其他办法只能 hash table做了，看了花花的视频， 没话说一讲就很简单了。\n  solution #1: 用dictionary做，key记录nums里的每个数，val=但这个数字的最长连续数字长度。查看num-1 和 num+1的val. online 求最长长度。\n  solution #2: 用set做, if num-1 not in the set, then num is the starting point of a consecutive list. Count the length until num+l not in the set. offline getting longest length.\n  class Solution: def longestConsecutive_solu1(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #1 h = dict() # key: num, val: consecutive length until key out = 0 for i in nums: if i in h: continue l = h[i-1] if i-1 in h else 0 r = h[i+1] if i+1 in h else 0 h[i] = h[i-l] = h[i+r] = l+r+1 out = max(out, h[i]) return out def longestConsecutive_solu2(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #2 h = set(nums) out = 0 for num in nums: if num-1 not in h: l = 1 while num+l in h: l += 1 out = max(out, l) return out # Time O(N) # Space O(N)  ","id":14,"section":"posts","summary":"LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: 题目 time complexity 要求O(N)，那没其","tags":["leetcode"],"title":"128 Longest Consecutive Sequence","uri":"https://foxisawesome.github.io/128-longest-consecutive-sequence/","year":"2020"},{"content":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n Solution 2020-09-02 Notes:\n Height of a tree: max(left_height, right_height) + 1 width of a tree (diameter): max(left_height + right_height) Diameter needs to be calculated along the way in this case.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: if not root: return 0 self.diameter = 0 self.DFS(root) return self.diameter def DFS(self, root) -\u0026gt; int: # DFS returns the height if not root: return 0 L_height = self.DFS(root.left) R_height = self.DFS(root.right) self.diameter = max(self.diameter, L_height+R_height) return max(L_height, R_height) + 1 # Time O(N) # Space O(N)  ","id":15,"section":"posts","summary":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].","tags":["leetcode","tree"],"title":"543 Diameter of Binary Tree","uri":"https://foxisawesome.github.io/543-diameter-of-binary-tree/","year":"2020"},{"content":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.\n  Algo #2: one pass, same time complexity. some details need to figure out.\n  rotation algo: r, c = c, n-r-1\n  row in range(n//2+n%2) and col in range(n//2)\n  while rotating the k, cycle from the last element: t[(k-1)%4]\n    class Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: n = len(matrix) # two-pass: 1. transpose; 2. reverse rows for i in range(n): for j in range(i,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() # one-pass: for i in range(n//2+n%2): for j in range(n//2): r, c = i, j t = [0]*4 for k in range(4): t[k] = matrix[r][c] r, c = c, n-r-1 for k in range(4): matrix[r][c] = t[(k-1)%4] r, c = c, n-r-1 # Time O(N^2) # Space O(1)  ","id":16,"section":"posts","summary":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.","tags":["leetcode"],"title":"48 Rotate Image","uri":"https://foxisawesome.github.io/48-rotate-image/","year":"2020"},{"content":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).\nMore formally, the probability of picking index i is w[i] / sum(w).\n Solution 2020-09-02 Notes:\n first, construct cumulative sum / total sum list. binary search for the nearest element \u0026gt; rand.uniform(0,1). I used closed interval in binary search, hence return l. No == case, because the robablilty of element exactly equal to random draw is 0.  class Solution: import random def __init__(self, w: List[int]): self.w = w self.w_sum = [] wsum = 0 tot = sum(self.w) for i in w: wsum += i prob = wsum/tot self.w_sum.append(prob) def pickIndex(self) -\u0026gt; int: target = random.uniform(0,1) l, r = 0, len(self.w)-1 while l \u0026lt;= r: m = l + (r-l)//2 if self.w_sum[m] \u0026gt; target: r = m - 1 elif self.w_sum[m] \u0026lt; target: l = m + 1 return l # Time O(N) + O(logN) # Space O(N)  ","id":17,"section":"posts","summary":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.","tags":["leetcode"],"title":"528 Random Pick With Weight","uri":"https://foxisawesome.github.io/528-random-pick-with-weight/","year":"2020"},{"content":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7   Solution 2020-09-02 Notes:\n Scan two linked lists first, using stack to store the node value. use the same LC 2 add two numbers to add them up from the end. Use LC 206 reverse linked list to store reversely along the way.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while stack1 and stack2: carry, r = divmod(stack1.pop() + stack2.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp stack = stack1 if stack1 else stack2 while stack: carry, r = divmod(stack.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp if carry != 0: temp = head head = ListNode(carry) head.next = temp return head # Time O(N) # Space O(1)  ","id":18,"section":"posts","summary":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists?","tags":["leetcode","linkedList"],"title":"445 Add Two Num II","uri":"https://foxisawesome.github.io/445-add-two-num-ii/","year":"2020"},{"content":"LC 295 Find Median From Data Stream   Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Solution 2020-09-01 Notes:\n  Follow 了花花酱的solu#1。 python the heapq implementation is a bit messy, while involving max heapq. python heapq library default heap is min-heap. filp all nums to -num to a heap, then it becomes a max-heap. Recover while pop.\n  Algo 想法挺简单但很巧: 分两堆：small (max-heap) 在左，large (min-heap)在右。\n Step1: add number to small heap while num \u0026lt;= small[0] Step2: balancing two heaps, 0\u0026lt;=len(small)-len(large)\u0026lt;2    class MedianFinder: import heapq def __init__(self): self.large = [] # min heap, right heap self.small = [] # max heap, left heap def addNum(self, num: int) -\u0026gt; None: if not self.small or num \u0026lt;= -self.small[0] : #default heapq is min heap, use -1*num will turn it as max heapq heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # balance two heaps if len(self.small) \u0026lt; len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) - len(self.large) == 2: heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -\u0026gt; float: if len(self.small) == len(self.large): return (-self.small[0] + self.large[0])/2 else: return -self.small[0] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() # Time O(nlogn) # Space O(N)  ","id":19,"section":"posts","summary":"LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow 了花花酱的so","tags":["leetcode"],"title":"295 Find Median From Data Stream","uri":"https://foxisawesome.github.io/295-find-median-from-data-stream/","year":"2020"},{"content":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head l_tail = slow = fast = head while fast and fast.next: l_tail = slow slow = slow.next fast = fast.next.next l_tail.next = None l = self.sortList(head) r = self.sortList(slow) return self.mergeTwoSorted(l,r) def mergeTwoSorted(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = dummy = ListNode(0) while l1 and l2: if l1.val \u0026lt; l2.val: head.next = l1 l1 = l1.next else: head.next = l2 l2 = l2.next head = head.next head.next = l1 if l1 else l2 return dummy.next # Time O(nlogn): merge sort # Space O(1): actually not O(1), since recursion is not O(1)  ","id":20,"section":"posts","summary":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.","tags":["leetcode","linkedList"],"title":"148 Sort List","uri":"https://foxisawesome.github.io/148-sort-list/","year":"2020"},{"content":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.   Solution 2020-09-01 Notes:\n classic DFS/backtracking problem. The biggest thing I\u0026rsquo;ve learnt from this: to return True/False instead of a list of retults. one needs to pass the true from bottom to top. Line 31-32 is doing this! Otherwise, if only line 23, on the the bottom DFS functions returns True, other lays return None.  class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: n = len(board) m = len(board[0]) directions = [[1,0], [-1,0], [0,1], [0,-1]] inits = [] for i in range(n): for j in range(m): if board[i][j] == word[0]: inits.append((i,j)) while inits: start = inits.pop() visited = set() visited.add(start) if self.dfs(board, word, directions, word[0], start, visited, m,n): return True return False def dfs(self, board, word, directions, path, point, visited,m,n): i, j = point[0], point[1] if path == word: return True for d in directions: x0, y0 = d[0], d[1] x1, y1 = x0+i, y0+j if 0\u0026lt;=x1\u0026lt;n and 0\u0026lt;=y1\u0026lt;m and (x1,y1) not in visited and board[x1][y1]==word[len(path)]: next_pt = (x1,y1) visited.add(next_pt) if self.dfs(board, word, directions, path+board[x1][y1],next_pt,visited,m,n): return True visited.remove(next_pt) # Time O(N*3^L), where L is the length of word # Space O(N)  ","id":21,"section":"posts","summary":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true.","tags":["leetcode","backtracking","DFS"],"title":"79 Word Search","uri":"https://foxisawesome.github.io/79-word-search/","year":"2020"},{"content":"LC 981 Time Based Key Value Store   Create a timebased key-value store class TimeMap, that supports two operations.\n set(string key, string value, int timestamp)   Stores the key and value, along with the given timestamp.  get(string key, int timestamp)   Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).   Solution 2020-09-01 Notes:\n 抄了一遍：这个reference  class TimeMap: def __init__(self): self.v_ = collections.defaultdict(list) self.t_ = collections.defaultdict(list) def set(self, key: str, value: str, timestamp: int) -\u0026gt; None: self.t_[key].append(timestamp) self.v_[key].append(value) def get(self, key: str, timestamp: int) -\u0026gt; str: if key not in self.t_: return \u0026quot;\u0026quot; # bisect is efficient algo to search key i = bisect.bisect_right(self.t_[key], timestamp) if i: return self.v_[key][i-1] return \u0026quot;\u0026quot; # Your TimeMap object will be instantiated and called as such: # obj = TimeMap() # obj.set(key,value,timestamp) # param_2 = obj.get(key,timestamp)  ","id":22,"section":"posts","summary":"LC 981 Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are","tags":["leetcode"],"title":"981 Time Based Key Value Store","uri":"https://foxisawesome.github.io/981-time-based-key-value-store/","year":"2020"},{"content":"LC 1041 Robot Bounded in Circle \n On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:\n \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n 2020-08-31 Notes:\n 没见过这种implementation。好经典的做法，二刷希望能刷出来。  class Solution: def isRobotBounded(self, instructions: str) -\u0026gt; bool: # north = 0, east = 1, south = 2, west = 3 directions = [[0,1],[1,0],[0,-1],[-1,0]] x = y = 0 idx = 0 for i in instructions: if i == 'L': idx = (idx + 3) % 4 elif i == 'R': idx = (idx + 1) % 4 else: x += directions[idx][0] y += directions[idx][1] return (x==0 and y==0) or idx != 0  ","id":23,"section":"posts","summary":"LC 1041 Robot Bounded in Circle On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in","tags":["leetcode"],"title":"1041 Robot Bounded in Circle","uri":"https://foxisawesome.github.io/1041-robot-bounded-in-circle/","year":"2020"},{"content":"LC 957 Prison Cells \n There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can\u0026rsquo;t have two adjacent neighbors.)\nWe describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\n 2020-08-31 Notes:\n  这题做了好久，好多corner case没过。最后才明白：\n  cycle = 14\n  two cases:\n​\ta. head in the cycle of 14; days %= 14\n​\tb. head not in the cycle of 14. in this case, days = (days-1)%14,\n    class Solution: def nextDay(self, cells): cells_nd = [0] for i in range(1,len(cells)-1): if cells[i-1] == cells[i+1]: cells_nd.append(1) else: cells_nd.append(0) cells_nd.append(0) return cells_nd def prisonAfterNDays(self, cells: List[int], N: int) -\u0026gt; List[int]: if not cells: return [] if N == 0: return cells memo = dict() memo[str(cells[:])] = 0 n = len(cells) for d in range(1,N+1): cells = self.nextDay(cells) print(d,cells) if str(cells) in memo: cycle = d - memo[str(cells)] break memo[str(cells[:])] = d # cycle is always 14. But two cases: 1. head is in the cycle; 2. head is not in the cycle. if d \u0026lt; N: if memo[str(cells)]==0: # head in the cycle case days = (N)%cycle else: # head not in the cycle case. days = (N-1)%cycle for d in range(days): cells = self.nextDay(cells) return cells  ","id":24,"section":"posts","summary":"LC 957 Prison Cells There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the","tags":["leetcode"],"title":"957 Prison Cells","uri":"https://foxisawesome.github.io/957-prison-cells/","year":"2020"},{"content":"LC 735 Aseroid Collision \n We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.  Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other.  Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.  Example 4:\nInput: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   2020-08-31 Notes:\n 一次就做对了如下。虽然不简洁，但能用上recursion，也算挺开心了。 一看官方解答，跟简洁，能combine 很多的case。而且最关键的：while+ continue+break的组合完美的绕开了recursion的做法。看了下时间比较差距不大。  class Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: stack = self.helper(stack, a) return stack def helper(self, stack, a): if not stack: stack.append(a) elif stack[-1] * a \u0026gt; 0 or stack[-1] \u0026lt; 0 and a \u0026gt; 0: stack.append(a) elif abs(stack[-1]) == abs(a): stack.pop() elif abs(stack[-1]) \u0026lt; abs(a): stack.pop() return self.helper(stack, a) return stack # Time O(N) # Space O(N)  官方解答：\nclass Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: while stack and a \u0026lt; 0 \u0026lt; stack[-1]: if stack[-1] \u0026lt; -a: stack.pop() continue elif stack[-1] == -a: stack.pop() break else: stack.append(a) return stack  ","id":25,"section":"posts","summary":"LC 735 Aseroid Collision We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size,","tags":["leetcode","recursion","stack"],"title":"735 Aseroid Collision","uri":"https://foxisawesome.github.io/735-aseroid-collision/","year":"2020"},{"content":"LC 141 Linked List Cycle \n Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.   08/29/2020 Notes:\n Fast two steps at a time, slow pointer one step a time. 一次也就过了。  class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if not head: return slow = fast = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False  ","id":26,"section":"posts","summary":"LC 141 Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There","tags":["leetcode","linkedList"],"title":"141 Linked List Cycle","uri":"https://foxisawesome.github.io/141-linked-list-cycle/","year":"2020"},{"content":"LC 328\n Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL   linked list 终于在周末刷出感觉了。这题也一遍就过了。\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return odd = p1 = ListNode(1) even = p2 = ListNode(0) count = 1 while head: if count % 2 == 1: odd.next = ListNode(head.val) odd = odd.next else: even.next = ListNode(head.val) even = even.next head = head.next count += 1 odd.next = p2.next return p1.next  ","id":27,"section":"posts","summary":"LC 328 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL linked list 终于在周末刷出感","tags":["leetcode","linkedList"],"title":"328 Odd Even Linked List","uri":"https://foxisawesome.github.io/328-odd-even-linked-list/","year":"2020"},{"content":"LC 1266\n On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.   一遍就过的题，没啥好说的。\nclass Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -\u0026gt; int: n = len(points) m = len(points[0]) time = 0 if not points or n == 0 or m == 0: return time for i in range(1, n): x1, y1 = points[i-1] x2, y2 = points[i] time += max(abs(x1-x2), abs(y1-y2)) return time  ","id":28,"section":"posts","summary":"LC 1266 On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points. You can move according to the next rules: In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to","tags":["leetcode"],"title":"1266 Minimum Time Visiting All Points","uri":"https://foxisawesome.github.io/1266-minimum-time-visiting-all-points/","year":"2020"},{"content":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:\n BST has a property that: if in-order traverse, the output is a sorted list. Time complex is O(N), if store everything, then space complexity is O(N). I can only maintain min_diff in each root step to reduce space complexity to O(1). recursion here is pretty easy: standard in-order traversal recursion.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getMinimumDifference(self, root: TreeNode) -\u0026gt; int: self.prev = None self.min_diff = float('inf') self.inorder(root) return self.min_diff def inorder(self, root): if not root: return self.inorder(root.left) if self.prev is not None: self.min_diff = min(self.min_diff, root.val - self.prev) self.prev = root.val self.inorder(root.right)  ","id":29,"section":"posts","summary":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:","tags":["leetcode","tree","BST"],"title":"530 Min Abs Dif BST","uri":"https://foxisawesome.github.io/530-min-abs-dif-bst/","year":"2020"},{"content":"LC 98 Valid BST\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  08/30/2020 Notes:\n two ways: 1. Check if a sorted list returned after in-order traversal. 2. check if alway root.right.val \u0026gt; root.val \u0026gt; root.left.val I used the first way. 这又是个很高级的recursion。  class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: self.prev = None return self.inorder(root) def inorder(self, root): if not root: return True if not self.inorder(root.left): return False if self.prev is not None and root.val \u0026lt;= self.prev: return False self.prev = root.val return self.inorder(root.right)  ","id":30,"section":"posts","summary":"LC 98 Valid BST Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example","tags":["leetcode","tree","BST"],"title":"98 Valid BST","uri":"https://foxisawesome.github.io/98-valid-bst/","year":"2020"},{"content":"LC 701\n Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5  You can return this binary search tree:\n 4 / \\ 2 7 / \\ / 1 3 5  This tree is also valid:\n 5 / \\ 2 7 / \\ 1 3 \\ 4   08/30/2020 Notes:\n 这个recursion 好高级，似懂非懂回头还得在刷。 一定要明确 resursion function return 的是什么。 这个return的是TreeNode。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def insertIntoBST(self, root: TreeNode, val: int) -\u0026gt; TreeNode: if not root: return TreeNode(val) if root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root  ","id":31,"section":"posts","summary":"LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST","tags":["leetcode","tree","BST"],"title":"701 Insert Into BST","uri":"https://foxisawesome.github.io/701-insert-into-bst/","year":"2020"},{"content":"滑动窗口算法的思路是这样：\n1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。\n2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。\n3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到right到达字符串S的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\nrefrence: wx:labuladong\nCode Template:\ndef slidingWindow(s: str, t: str) -\u0026gt; str: target, window = {}, {} for i in t: target[i] = target.get(i,0) + 1 left, right, valid = 0, 0, 0 while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] # move right index right += 1 # 进行窗口内数据的一系列更新 ... # /*** debug 输出的位置 ***/ print('s: '+s2[left:right]+' window' + str(window) + ' valid: ' + str(valid)) # see if needs to shrink window while (window shrinking condition): d = s[left] left += 1 # 进行窗口内数据的一系列更新 ... return ...  ","id":32,"section":"posts","summary":"滑动窗口算法的思路是这样： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)","tags":["template"],"title":"Sliding Window Note","uri":"https://foxisawesome.github.io/sliding-window-note/","year":"2020"},{"content":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post!\nIt takes a while for me to get how exactly Linked List works. I used following utility functions to keep my leetcode solutions and run codes locally.\nNote:\n say head = ListNode(0), then head = head.next is to iterate to next node on the Linked List. use head.next = a to point to next node.  # My liked list utility functions: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def list2ListNode(list): head = LinkedList = ListNode(0) for i in range(len(list)): LinkedList.next = ListNode(list[i]) LinkedList = LinkedList.next return head.next def printListNode(p): head = ListNode(0) head.next = p out = [] while p: out.append(p.val) p = p.next return out # e.g.: indata = [1,2,3,4,5,6] head = ListNode.list2ListNode(indata) ListNode.printListNode(head)  ","id":33,"section":"posts","summary":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post! It takes a while for me to get how exactly Linked List","tags":["template","linkedList"],"title":"Linked List Note (First Post)","uri":"https://foxisawesome.github.io/linked-list-note/","year":"2020"},{"content":"LC 42 Trapping Rain Water   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n Solution 2020-08-05 Notes:\n 短边原理，左右指针同时走，r_max 大时短边在left，所以计算left side。 每一格计算下相较于短边的容水量即可  左右指针的 while loop，设为 l\u0026lt;=r 或者 了l\u0026lt;r 都一样，因为l=r跳出时只可能r_max = l_max = height[r]=height[l], water=0.    class Solution: def trap(self, height: List[int]) -\u0026gt; int: if not height: return 0 l, r = 0, len(height)-1 l_max, r_max = height[0], height[-1] ans = 0 while l \u0026lt; r: l_max = max(l_max, height[l]) r_max = max(r_max, height[r]) if l_max \u0026lt; r_max: ans += l_max - height[l] l += 1 else: ans += r_max - height[r] r -= 1 return ans # Time O(N) # Space O(1)  ","id":34,"section":"posts","summary":"LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: 短边原理，左右指针同时走，r_max 大时短边在left，所以计算lef","tags":["leetcode"],"title":"42 Trapping Rain Water","uri":"https://foxisawesome.github.io/42-trapping-rain-water/","year":"2020"},{"content":"LC 206 Reverse Linked List   Reverse a singly linked list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   Solution 2020-09-01 Notes:\n 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 recursion的做法还是似懂非懂，还得再看看。感觉TreeNode, ListNode 的recursion 都是if not head/root: return head/root。 另外，recession 这里返回的是 以head.next为头reversed 的list，只需要再把head.next\t reverse 下就好了。  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: # iteration def reverseList_iter(self, head: ListNode) -\u0026gt; ListNode: if not head: return None prev = None curr = head while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev  # recursion def reverseList_rec(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p # Time O(N) for iteration # Space O(1)  ","id":35,"section":"posts","summary":"LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL Solution 2020-09-01 Notes: 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 recursion的做法还是似懂非懂，","tags":["leetcode","linkedList"],"title":"206 Reverse Linked List","uri":"https://foxisawesome.github.io/206-reverse-linked-list/","year":"2020"},{"content":"LC 2 Add Two Num   You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807.   Solution 2020-07-02 Notes:\n 比较简单，但是 don’t forget line 17 and 25。  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: head = out = ListNode(0) carry = 0 while l1 and l2: carry, m = divmod(l1.val + l2.val + carry, 10) out.next = ListNode(m) l1 = l1.next l2 = l2.next out = out.next l = l1 if l1 else l2 while l: carry, m = divmod(l.val + carry, 10) out.next = ListNode(m) out = out.next l = l.next if carry \u0026gt; 0: out.next = ListNode(carry) return head.next # Time O(N) # Space O(1)  ","id":36,"section":"posts","summary":"LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt;","tags":["leetcode","linkedList"],"title":"2 Add Two Num","uri":"https://foxisawesome.github.io/2-add-two-num/","year":"2020"},{"content":"LC 69 Sqrtx   Implement int sqrt(int x).\nSqrt(8) = 2\n Solution 2020-03-07 Notes:\n 标准的binary search 模版， right 从x//2开始。  class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x: return mid elif mid**2 \u0026gt; x: right = mid -1 elif mid**2 \u0026lt; x: left = mid + 1 # exit at [right, left], hence return right return right # Time O(logN) # Space O(1)  ","id":37,"section":"posts","summary":"LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: 标准的binary search 模版， right 从x//2开始。 class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x:","tags":["leetcode","binarySearch"],"title":"69 Sqrtx","uri":"https://foxisawesome.github.io/69-sqrtx/","year":"2020"},{"content":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","id":38,"section":"posts","summary":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","tags":["leetcode"],"title":"1 Two Sum","uri":"https://foxisawesome.github.io/1-two-sum/","year":"2020"}],"tags":[{"title":"backtracking","uri":"https://foxisawesome.github.io/tags/backtracking/"},{"title":"binarySearch","uri":"https://foxisawesome.github.io/tags/binarysearch/"},{"title":"BST","uri":"https://foxisawesome.github.io/tags/bst/"},{"title":"DFS","uri":"https://foxisawesome.github.io/tags/dfs/"},{"title":"dp","uri":"https://foxisawesome.github.io/tags/dp/"},{"title":"hashtable","uri":"https://foxisawesome.github.io/tags/hashtable/"},{"title":"leetcode","uri":"https://foxisawesome.github.io/tags/leetcode/"},{"title":"linkedList","uri":"https://foxisawesome.github.io/tags/linkedlist/"},{"title":"recursion","uri":"https://foxisawesome.github.io/tags/recursion/"},{"title":"stack","uri":"https://foxisawesome.github.io/tags/stack/"},{"title":"template","uri":"https://foxisawesome.github.io/tags/template/"},{"title":"tree","uri":"https://foxisawesome.github.io/tags/tree/"},{"title":"twopointers","uri":"https://foxisawesome.github.io/tags/twopointers/"}]}