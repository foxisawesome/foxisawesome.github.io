{"categories":[{"title":"algo","uri":"https://foxisawesome.github.io/categories/algo/"},{"title":"note","uri":"https://foxisawesome.github.io/categories/note/"},{"title":"sql","uri":"https://foxisawesome.github.io/categories/sql/"}],"posts":[{"content":"LC 227 Basic Calculator II   Implement a basic calculator to evaluate a simple expression string.\nThe expression string contains only non-negative integers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero.\nInput: \u0026quot;3+2*2\u0026quot; Output: 7   Solution 2020-09-30 Notes:   要使用运算符号得知道operator 左右两边的数。所以这里得用prev_op来进行计算。\nalgo里的 variable example： stack.pop() prev_op digit\n  只要 val 是 operator时操作完需要更新。这里有好多细节：for loop下是两个if; digit 的更新不要写成 +=; prev_op为 +\\- 时 只能append，不能写成 *, /的形式。\n  class Solution: def calculate(self, s: str) -\u0026gt; int: stack, digit, prev_op = [], 0, '+' n = len(s) for i, val in enumerate(s): if val.isdigit(): digit = digit*10 + int(val) if i==n-1 or val in ('+','-','*','/'): if prev_op == \u0026quot;+\u0026quot;: stack.append(digit) elif prev_op == '-': stack.append(-digit) elif prev_op == '*': temp = stack.pop() * digit stack.append(temp) elif prev_op == '/': temp = int(stack.pop() / digit) stack.append(temp) digit = 0 prev_op = val return sum(stack) # Time O(N) # Space O(N)  ","id":0,"section":"posts","summary":"LC 227 Basic Calculator II Implement a basic calculator to evaluate a simple expression string. The expression string contains only non-negative integers, +, -, *, / operators and empty spaces ``. The integer division should truncate toward zero. Input: \u0026quot;3+2*2\u0026quot; Output: 7 Solution 2020-09-30 Notes: 要使用运算符号得知道operator 左右两边的数。","tags":["leetcode","stack","dia"],"title":"227 Basic Calculator II","uri":"https://foxisawesome.github.io/posts/227-basic-calculator-ii/","year":"2020"},{"content":"LC 76 Minimum Window Substring   Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\nInput: S = \u0026quot;ADOBECODEBANC\u0026quot;, T = \u0026quot;ABC\u0026quot; Output: \u0026quot;BANC\u0026quot;   Solution 2020-09-30 Notes:  sliding window 的同时，需要online update minimum length，并用一个dict 记录下来。 这次二刷，简短了一些，但是运行时间上看没有improve。  class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n = len(s) window, target = collections.Counter(), collections.Counter() for i in t: target[i] += 1 l, valid = 0, 0 ans, mini = \u0026quot;\u0026quot;, float('inf') for r in range(n): window[s[r]] += 1 if window[s[r]] == target[s[r]]: valid += 1 while valid == len(target): if r-l+1 \u0026lt; mini: mini, ans = r-l+1, s[l:r+1] window[s[l]] -= 1 if window[s[l]] \u0026lt; target[s[l]]: valid -= 1 l += 1 return ans # Time O(N) # Space O(N)  2020-08-10 Notes: labuladong 提供的一个不错的模版版本。\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: tcount, window = {}, {} for i in t: tcount[i] = tcount.get(i,0) + 1 left, right = 0, 0 valid = 0 # ini para for minimium str start, len_sub = 0, float('inf') while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] right += 1 if c in tcount: window[c] = window.get(c,0) + 1 if window[c] == tcount[c]: valid += 1 # shrinking window left point while (valid == len(tcount)): if right - left \u0026lt; len_sub: start = left len_sub = right - left d = s[left] left += 1 if d in tcount: if window[d] == tcount[d]: valid -= 1 window[d] = window.get(d,0) - 1 return \u0026quot;\u0026quot; if len_sub==float('inf') else s[start:start+len_sub] # Time O(N) # Space O(N)  ","id":1,"section":"posts","summary":"LC 76 Minimum Window Substring Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Input: S = \u0026quot;ADOBECODEBANC\u0026quot;, T = \u0026quot;ABC\u0026quot; Output: \u0026quot;BANC\u0026quot; Solution 2020-09-30 Notes: sliding window 的同时，需要online update minimum length，并用一个d","tags":["leetcode","sliding_window"],"title":"76 Minimum Window Substring","uri":"https://foxisawesome.github.io/posts/76-minimum-window-substring/","year":"2020"},{"content":"LC 728 Self Dividing Numbers   A self-dividing number is a number that is divisible by every digit it contains.\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\nAlso, a self-dividing number is not allowed to contain the digit zero.\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\nInput: left = 1, right = 22 Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]   Solution 2020-09-29 Notes:  按照定义 打一遍就好了。  class Solution: def selfDividingNumbers(self, left: int, right: int) -\u0026gt; List[int]: ans = [] for i in range(left, right + 1): if self.helper(i): ans.append(i) return ans def helper(self, n): for i in str(n): if i == '0' or n % int(i) != 0: return False return True # Time O(N) # Space O(N)  ","id":2,"section":"posts","summary":"LC 728 Self Dividing Numbers A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. Also, a self-dividing number is not allowed to contain the digit zero. Given a lower and upper number bound, output a list of every possible self dividing","tags":["leetcode"],"title":"728 Self Dividing Numbers","uri":"https://foxisawesome.github.io/posts/728-self-dividing-numbers/","year":"2020"},{"content":"LC 793 Preimage Size of Factorial Zeroes Function   Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)\nFor example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K, find how many non-negative integers x have the property that f(x) = K.\n Solution 2020-09-29 Notes:  首先这题是 LC 172 衍生。下面的helper func fives() 就是172. 其次这题解其实就两种情况，0 或者 5。 因为要么 K 个零正好符合摸个数 m!，那么 (m+4)!, (m+3)!, (m+2)!, (m+1)!, m! 正好有同样多的trailing 0. 所以return 5. 要么就是给定的 K 个零无法满足任何 n!, return 0. 所以可以用 binary search 锁定这个m。up bound is 5K，就在 self.fives() 里，能保值 fives(5K) \u0026gt; K。 返回 l 时多个判断就好了。  class Solution: def preimageSizeFZF(self, K: int) -\u0026gt; int: l, r = 1, K*5 while l \u0026lt;= r: m = l + (r-l)//2 if self.fives(m) \u0026lt; K: l = m + 1 elif self.fives(m) \u0026gt;= K: r = m - 1 if self.fives(l) != K: return 0 return 5 def fives(self, n): c = 0 while n \u0026gt; 0: n //= 5 c += n return c # Time O(log(5K)*log(5K)) # Space O(1)  ","id":3,"section":"posts","summary":"LC 793 Preimage Size of Factorial Zeroes Function Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.) For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end. Given K,","tags":["leetcode","binary_search","dia"],"title":"793 Preimage Size of Factorial Zeroes Function","uri":"https://foxisawesome.github.io/posts/793-preimage-size-of-factorial-zeroes-function/","year":"2020"},{"content":"LC 172 Factorial Trailing Zeroes   Given an integer n, return the number of trailing zeroes in n!.\nFollow up: Could you write a solution that works in logarithmic time complexity?\n Solution 2020-09-29 Notes:  count N 中有几个5, 就一定有几个0. 这个写法很高级。相当于 5 分法，所以time complexity是 $\\mathcal{O}(\\log_5 N)$.  class Solution: def trailingZeroes(self, n: int) -\u0026gt; int: zero_count = 0 while n \u0026gt; 0: n //= 5 zero_count += n return zero_count # Time O(logN) # Space O(1)  ","id":4,"section":"posts","summary":"LC 172 Factorial Trailing Zeroes Given an integer n, return the number of trailing zeroes in n!. Follow up: Could you write a solution that works in logarithmic time complexity? Solution 2020-09-29 Notes: count N 中有几个5, 就一定有几个0. 这个写法很高级。相当于 5 分法，所以time","tags":["leetcode","dia"],"title":"172 Factorial Trailing Zeroes","uri":"https://foxisawesome.github.io/posts/172-factorial-trailing-zeroes/","year":"2020"},{"content":"LC 1288 Remove Covered Intervals   Given a list of intervals, remove all intervals that are covered by another interval in the list. Interval [a,b) is covered by interval [c,d) if and only if c \u0026lt;= a and b \u0026lt;= d.\nAfter doing so, return the number of remaining intervals.\nInput: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.   Solution 2020-09-29 Notes:  排序后有两种可能，列出来就好了。第二种情况删的是 i-th interval，所以下次比较时 i+1 要与 i-1 比较，所以 swap 了一下。  class Solution: def removeCoveredIntervals(self, intervals: List[List[int]]) -\u0026gt; int: n = len(intervals) c = 0 intervals.sort(key = lambda x: (x[0],x[1])) for i in range(1,n): if intervals[i-1][0] == intervals[i][0]: c += 1 elif intervals[i-1][1] \u0026gt;= intervals[i][1]: intervals[i-1], intervals[i] = intervals[i], intervals[i-1] c += 1 return n-c # Time O(NlogN) # Space O(1)  ","id":5,"section":"posts","summary":"LC 1288 Remove Covered Intervals Given a list of intervals, remove all intervals that are covered by another interval in the list. Interval [a,b) is covered by interval [c,d) if and only if c \u0026lt;= a and b \u0026lt;= d. After doing so, return the number of remaining intervals. Input: intervals = [[1,4],[3,6],[2,8]] Output: 2 Explanation: Interval [3,6] is covered by [2,8], therefore it is removed. Solution 2020-09-29 Notes: 排","tags":["leetcode","array"],"title":"1288 Remove Covered Intervals","uri":"https://foxisawesome.github.io/posts/1288-remove-covered-intervals/","year":"2020"},{"content":"LC 567 Permutation in String   Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\u0026rsquo;s permutations is the substring of the second string.\nInput: s1 = \u0026quot;ab\u0026quot; s2 = \u0026quot;eidbaooo\u0026quot; Output: True Explanation: s2 contains one permutation of s1 (\u0026quot;ba\u0026quot;).   Solution 2020-09-29 Notes:  这题用了sliding window的思想，就是s2中的subarray的length 和 s1一致，然后字母的count一致。那么s1的permutation一定在s2中。 剩下的就是很简单的sliding window的标准模版了。  class Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: d, target = collections.Counter(), collections.Counter() l, valid = 0, 0 n1, n2 = len(s1), len(s2) for i in s1: target[i] += 1 for r in range(n2): d[s2[r]] += 1 if d[s2[r]] == target[s2[r]]: valid += 1 while valid == len(target): if r-l+1 == n1: return True d[s2[l]] -= 1 if d[s2[l]] \u0026lt; target[s2[l]]: valid -= 1 l += 1 return False # Time O(N) # Space O(N)  2020-08-10 Notes: 看了labuladong的解：\nclass Solution: def checkInclusion(self, s1: str, s2: str) -\u0026gt; bool: left, right = 0, 0 ns1, ns2 = len(s1), len(s2) target, window = {}, {} for i in s1: target[i] = target.get(i,0) + 1 valid, len_sub = 0, float('inf') while right \u0026lt; ns2: c = s2[right] right += 1 if c in target: window[c] = window.get(c,0) + 1 if window[c] == target[c]: valid += 1 while (right - left \u0026gt;= ns1): if (valid == len(target)): return True d = s2[left] left += 1 if d in target: if window[d] == target[d]: valid -= 1 window[d] = window.get(d,0) - 1 return False  ","id":6,"section":"posts","summary":"LC 567 Permutation in String Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string\u0026rsquo;s permutations is the substring of the second string. Input: s1 = \u0026quot;ab\u0026quot; s2 = \u0026quot;eidbaooo\u0026quot; Output: True Explanation: s2 contains one permutation of s1 (\u0026quot;ba\u0026quot;). Solution 2020-09-29 Notes: 这题用了slidin","tags":["leetcode","sliding_window"],"title":"567 Permutation in String","uri":"https://foxisawesome.github.io/posts/567-permutation-in-string/","year":"2020"},{"content":"LC 930 Binary Subarrays With Sum   In an array A of 0s and 1s, how many non-empty subarrays have sum S?\nInput: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1]   Solution 2020-09-29 Notes:  第一刷时按topic来刷的，这一些列题都几乎一摸一样。 别忘了 if S \u0026lt; 0: return 0 这个条件。  class Solution: def numSubarraysWithSum(self, A: List[int], S: int) -\u0026gt; int: if not A: return 0 return self.atMost(A,S) - self.atMost(A, S-1) def atMost(self, A, S): if S \u0026lt; 0: return 0 n = len(A) l, c = 0, 0 ans = 0 for r in range(n): c += A[r] while l \u0026lt; n and c \u0026gt; S: c -= A[l] l += 1 ans += r-l+1 return ans # Time O(N) # Space O(1)  ","id":7,"section":"posts","summary":"LC 930 Binary Subarrays With Sum In an array A of 0s and 1s, how many non-empty subarrays have sum S? Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Solution 2020-09-29 Notes: 第一刷时按topic来刷的，这一些列题都几乎一摸一样","tags":["leetcode","sliding_window"],"title":"930 Binary Subarrays With Sum","uri":"https://foxisawesome.github.io/posts/930-binary-subarrays-with-sum/","year":"2020"},{"content":"LC 1004 Max Consecutive Ones III   Given an array A of 0s and 1s, we may change up to K values from 0 to 1.\nReturn the length of the longest (contiguous) subarray that contains only 1s.\nInput: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.   Solution 2020-09-28 Notes:   这其实是倒挺简单的sliding window题，但是corner case太恶心了。\ne.g. [1,1,1,0,0,0,1,1,1,1] 0， 可能这种极端情况。\n[0,0,0,1] 4 可能flips 不需要用满\n  最后的solution就是把 sliding window的while 改成 if。 每次只shrink一步。就能统一各种情况解。\n  class Solution: def longestOnes(self, A: List[int], K: int) -\u0026gt; int: l, c = 0, 0 n = len(A) for r in range(n): if A[r] == 0: c += 1 if c \u0026gt; K: if A[l] == 0: c -= 1 l += 1 return r-l+1 # Time O(N) # Space O(1)  ","id":8,"section":"posts","summary":"LC 1004 Max Consecutive Ones III Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s. Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Solution 2020-09-28 Notes: 这其实是倒挺","tags":["leetcode","sliding_window"],"title":"1004 Max Consecutive Ones III","uri":"https://foxisawesome.github.io/posts/1004-max-consecutive-ones-iii/","year":"2020"},{"content":"LC 1248 Count Number of Nice Subarrays   Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.\nReturn the number of nice sub-arrays.\nInput: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].   Solution 2020-09-28 Notes:  这是与LC 992 一摸一样的题。其实临界点应该是 K+1. 其次 sliding window解决 at most 或者 minimum 的问题。 Again ans += r-l+1 returns the total number of contiguous subarray under nums[l:r+1]  class Solution: def numberOfSubarrays(self, nums: List[int], k: int) -\u0026gt; int: return self.atMost(nums, k) - self.atMost(nums, k-1) def atMost(self, nums, k): n = len(nums) l, c = 0, 0 ans = 0 for r in range(n): if nums[r]%2==1: c+=1 while c \u0026gt; k: if nums[l] % 2 == 1: c -= 1 l += 1 ans += r-l+1 return ans # Time O(N) # Space O(1)  ","id":9,"section":"posts","summary":"LC 1248 Count Number of Nice Subarrays Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it. Return the number of nice sub-arrays. Input: nums = [1,1,2,1,1], k = 3 Output: 2 Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1]. Solution 2020-09-28 Notes: 这是与LC 992 一摸一","tags":["leetcode","sliding_window"],"title":"1248 Count Number of Nice Subarrays","uri":"https://foxisawesome.github.io/posts/1248-count-number-of-nice-subarrays/","year":"2020"},{"content":"LC 1358 Number of Substrings Containing All Three Characters   Given a string s consisting only of characters a, b and c.\nReturn the number of substrings containing at least one occurrence of all these characters a, b and c.\nInput: s = \u0026quot;abcabc\u0026quot; Output: 10 Explanation: The substrings containing at least one occurrence of the characters a, b and c are \u0026quot;abc\u0026quot;, \u0026quot;abca\u0026quot;, \u0026quot;abcab\u0026quot;, \u0026quot;abcabc\u0026quot;, \u0026quot;bca\u0026quot;, \u0026quot;bcab\u0026quot;, \u0026quot;bcabc\u0026quot;, \u0026quot;cab\u0026quot;, \u0026quot;cabc\u0026quot; and \u0026quot;abc\u0026quot; (again).   Solution 2020-09-28 Notes:  Sliding window 只能处理at most的问题，那怎么转换到 at least 呢。很简单，但只要找到满足条件的子序列后，后面的所有字母加上都legit。所以ans += n-r这样就转成了 at least的解了  class Solution: def numberOfSubstrings(self, s: str) -\u0026gt; int: n = len(s) d = collections.Counter() l = 0 valid = 0 ans = 0 for r in range(n): if d[s[r]] == 0: valid += 1 d[s[r]] += 1 while valid == 3: ans += n - r d[s[l]] -= 1 if d[s[l]] == 0: valid -= 1 l += 1 return ans # Time O(N) # Space O(1)  ","id":10,"section":"posts","summary":"LC 1358 Number of Substrings Containing All Three Characters Given a string s consisting only of characters a, b and c. Return the number of substrings containing at least one occurrence of all these characters a, b and c. Input: s = \u0026quot;abcabc\u0026quot; Output: 10 Explanation: The substrings containing at least one occurrence of the characters a, b and c are \u0026quot;abc\u0026quot;, \u0026quot;abca\u0026quot;, \u0026quot;abcab\u0026quot;, \u0026quot;abcabc\u0026quot;, \u0026quot;bca\u0026quot;, \u0026quot;bcab\u0026quot;, \u0026quot;bcabc\u0026quot;, \u0026quot;cab\u0026quot;, \u0026quot;cabc\u0026quot;","tags":["leetcode","sliding_window"],"title":"1358 Number of Substrings Containing All Three Characters","uri":"https://foxisawesome.github.io/posts/1358-number-of-substrings-containing-all-three-characters/","year":"2020"},{"content":"LC 992 Subarrays With K Different Integers   Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.\nInput: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].   Solution 2020-09-28 Notes:   看了论坛里的最高分解答。对我来说最难理解的两点：\n  sliding window只能解最多/最短的sub-array的问题，如何转换。这里他建了一个helper function，做at most K distinct number\n  c += r-l+1 why? 这其实是个summation: $\\sum_{l=0}^{r} (r-l+1)$ 意思是长度为(r-l+1)的array下所有contiguous subarray 的个数\ne.g.: [1,2,1,2] will produce a total of 10 different contiguous subarrays:\n [1,2,1,2] (1 different contiguous subarrays with length 4) [1,2,1], [2,1,2] (2 different contiguous subarrays with length 3) [1, 2], [1,2], [2,1](3 different contiguous subarrays with length 2) [1], [2], [1], [2] (4 different contiguous subarrays with length 1)    当 shriking 的 while loop启动时，计算的是 新的subarray的个数，不计入之前出现过的subarray。\n     class Solution: def subarraysWithKDistinct(self, A: List[int], K: int) -\u0026gt; int: return self.atMost(A,K) - self.atMost(A,K-1) def atMost(self, A, K): n = len(A) c, l = 0, 0 d = collections.Counter() for r in range(n): if d[A[r]] == 0: K -= 1 d[A[r]] += 1 while K \u0026lt; 0: d[A[l]] -= 1 if d[A[l]] == 0: K += 1 l += 1 c += r - l + 1 return c # Time O(N) # Space O(1)  ","id":11,"section":"posts","summary":"LC 992 Subarrays With K Different Integers Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K. Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]. Solution 2020-09-28 Notes: 看了论坛里的最","tags":["leetcode","sliding_window","dia"],"title":"992 Subarrays With K Different Integers","uri":"https://foxisawesome.github.io/posts/992-subarrays-with-k-different-integers/","year":"2020"},{"content":"LC 977 Squares of a Sorted Array   Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.\nInput: [-4,-1,0,3,10] Output: [0,1,9,16,100]   Solution 2020-09-28 Notes:  先找到零的位置再向两边走。  class Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: p, n = 0, len(A) while p \u0026lt; n and A[p] \u0026lt; 0: p += 1 ans = [] l, r = p-1, p while l\u0026gt;=0 and r\u0026lt;n: if abs(A[l]) \u0026gt;= abs(A[r]): ans.append(A[r]**2) r += 1 else: ans.append(A[l]**2) l -= 1 r = A[r:] if l\u0026lt;0 else A[:l+1][::-1] [ans.append(i**2) for i in r] return ans # Time O(N) # Space O(N)  one liner\nclass Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: return sorted(x**2 for x in A)  ","id":12,"section":"posts","summary":"LC 977 Squares of a Sorted Array Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Solution 2020-09-28 Notes: 先找到零的位置再向两边走。 class Solution: def sortedSquares(self, A: List[int]) -\u0026gt; List[int]: p, n = 0, len(A) while p \u0026lt; n and A[p]","tags":["leetcode","two_pointers"],"title":"977 Squares of a Sorted Array","uri":"https://foxisawesome.github.io/posts/977-squares-of-a-sorted-array/","year":"2020"},{"content":"LC 16 3sum Closest   Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.\n Solution 2020-09-28 Notes:  这题其实只能穷举，用了sort之后可以prun 一些枝。  class Solution: def threeSumClosest(self, nums: List[int], target: int) -\u0026gt; int: d = dict() mini = float('inf') n = len(nums) nums.sort() for i, val in enumerate(nums): l, r = i+1, n-1 while l \u0026lt; r: sum_ = nums[i] + nums[l] + nums[r] diff = abs(sum_ - target) if diff == 0: return target if diff \u0026lt; mini: mini = min(mini, diff) d[diff]=sum_ if sum_ \u0026lt; target: l += 1 else: r -= 1 return d[mini] # Time O(N^2 + NlogN) # Space O(N)  ","id":13,"section":"posts","summary":"LC 16 3sum Closest Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Solution 2020-09-28 Notes: 这题其实只能穷举，用了sort之后可以pr","tags":["leetcode","two_pointers","dia"],"title":"16 3sum Closest","uri":"https://foxisawesome.github.io/posts/16-3sum-closest/","year":"2020"},{"content":"LC 15 3sum   Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n Solution 2020-09-28 Notes:  这题最困难的地方时不能有dups。用这个条件很多次了 if i==0 or nums[i]!=nums[i-1]: 还得多刷几遍。  class Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: self.ans = [] n = len(nums) if n \u0026lt; 3: return self.ans nums.sort() for i, val in enumerate(nums): if val \u0026gt; 0: break if i==0 or nums[i]!=nums[i-1]: self.twoSum(nums, -val, i) return self.ans def twoSum(self, nums, target, i): l, r = i+1, len(nums)-1 while l \u0026lt; r: if target == 1: print(l,r) sum_ = nums[l] + nums[r] if sum_ \u0026lt; target: l += 1 elif sum_ \u0026gt; target: r -= 1 else: self.ans.append([nums[i], nums[l], nums[r]]) l += 1 r -= 1 while l \u0026lt; r and nums[l] == nums[l-1]: l += 1 # Time O(N) # Space O(N)  ","id":14,"section":"posts","summary":"LC 15 3sum Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Solution 2020-09-28 Notes: 这题最困难的地方时不能有dups。用这个条件很多次了 if","tags":["leetcode","two_pointers","dia"],"title":"15 3sum","uri":"https://foxisawesome.github.io/posts/15-3sum/","year":"2020"},{"content":"LC 881 Boats to Save People   The i-th person has weight people[i], and each boat can carry a maximum weight of limit.\nEach boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.\nReturn the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.)\nInput: people = [1,2], limit = 3 Output: 1 Explanation: 1 boat (1, 2)   Solution 2020-09-28 Notes:  这题只允许最多carry two poeple 就使得整个问题简化了，可以有two pointers做。  class Solution: def numRescueBoats(self, people: List[int], limit: int) -\u0026gt; int: people.sort(reverse=True) l, r = 0, len(people)-1 while l \u0026lt;= r: if people[l] + people[r] \u0026gt; limit: l += 1 elif people[l] + people[r] \u0026lt;= limit: l += 1 r -= 1 return l # Time O(NlogN) # Space O(1)  ","id":15,"section":"posts","summary":"LC 881 Boats to Save People The i-th person has weight people[i], and each boat can carry a maximum weight of limit. Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit. Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.) Input: people","tags":["leetcode","two_pointers","DIA"],"title":"881 Boats to Save People","uri":"https://foxisawesome.github.io/posts/881-boats-to-save-people/","year":"2020"},{"content":"LC 986 Interval List Intersections   Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.\nReturn the intersection of these two interval lists.\n(Formally, a closed interval [a, b] (with a \u0026lt;= b) denotes the set of real numbers x with a \u0026lt;= x \u0026lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval. For example, the intersection of [1, 3] and [2, 4] is [2, 3].)\n\nInput: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]] Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]   Solution 2020-09-27 Notes:  很简单的题，按照所有可能的情况一一列举就好了。  class Solution: def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -\u0026gt; List[List[int]]: ans = [] na, nb = len(A), len(B) pa, pb = 0, 0 while pa \u0026lt; na and pb \u0026lt; nb: if B[pb][0] \u0026lt; A[pa][0]: if B[pb][1] \u0026lt; A[pa][0]: pb += 1 elif A[pa][0] \u0026lt;= B[pb][1] \u0026lt;= A[pa][1]: ans.append([A[pa][0],B[pb][1]]) pb += 1 elif B[pb][1] \u0026gt; A[pa][1]: ans.append(A[pa]) pa += 1 elif A[pa][0] \u0026lt;= B[pb][0] \u0026lt;= A[pa][1]: if B[pb][1] \u0026lt;= A[pa][1]: ans.append(B[pb]) pb += 1 elif B[pb][1] \u0026gt; A[pa][1]: ans.append([B[pb][0], A[pa][1]]) pa += 1 elif B[pb][0] \u0026gt; A[pa][1]: pa += 1 return ans # Time O(M+N) # Space O(N)  ","id":16,"section":"posts","summary":"LC 986 Interval List Intersections Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a \u0026lt;= b) denotes the set of real numbers x with a \u0026lt;= x \u0026lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or","tags":["leetcode","two_pointers"],"title":"986 Interval List Intersections","uri":"https://foxisawesome.github.io/posts/986-interval-list-intersections/","year":"2020"},{"content":"LC 925 Long Pressed Name   Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.\nYou examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.\n Solution 2020-09-27 Notes:  这题好多坑，我第一次做很官方的two-pointers solution几乎一样， 但是打了很多次布丁才过。得多练练。  class Solution: def isLongPressedName(self, name: str, typed: str) -\u0026gt; bool: t = len(typed) n = len(name) if name[0] != typed[0]: return False pT, pN = 1, 1 while pT \u0026lt; t and pN \u0026lt; n: if typed[pT] == name[pN]: pT += 1 pN += 1 elif typed[pT] == typed[pT-1]: pT += 1 else: return False while pT \u0026lt; t: if typed[pT] != name[-1]: return False pT += 1 return pN == n # Time O(N+T) # Space O(1)  这个别人的答案很简洁。\nclass Solution: def isLongPressedName(self, name: str, typed: str) -\u0026gt; bool: i = 0 for j in range(len(typed)): if i \u0026lt; len(name) and name[i] == typed[j]: i += 1 elif j == 0 or typed[j] != typed[j-1]: return False return i == len(name)  ","id":17,"section":"posts","summary":"LC 925 Long Pressed Name Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Solution 2020-09-27 Notes: 这题好","tags":["leetcode","two_pointers","dia"],"title":"925 Long Pressed Name","uri":"https://foxisawesome.github.io/posts/925-long-pressed-name/","year":"2020"},{"content":"LC 455 Assign Cookies   Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj \u0026gt;= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n Solution 2020-09-27 Notes:  分配cookies时尽可能物尽其用，所以将s, g先排序再比较。  class Solution: def findContentChildren(self, g: List[int], s: List[int]) -\u0026gt; int: if not s or not g: return 0 g.sort(reverse=True) s.sort(reverse=True) c, p = 0, 0 for i in s: while p \u0026lt; len(g): if i \u0026gt;= g[p]: c += 1 p += 1 break p += 1 return c # Time O(MlogM + NlogN) # Space O(1)  ","id":18,"section":"posts","summary":"LC 455 Assign Cookies Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj \u0026gt;= gi, we can assign the cookie j to","tags":["leetcode","two_pointers"],"title":"455 Assign Cookies","uri":"https://foxisawesome.github.io/posts/455-assign-cookies/","year":"2020"},{"content":"LC 152 Valid Palindrome   Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.\nNote: For the purpose of this problem, we define empty string as valid palindrome.\ne.g. “0P”, “.,”\n Solution 2020-09-27 Notes:  题目本身很简单，但是two notes：1. while套while时，得把上层的while condition写进下层。其次这题得用 isalnum() 而不是 alpha(). 不然 “0P”的case 不能过。  class Solution: def isPalindrome(self, s: str) -\u0026gt; bool: if not s: return True l, r = 0, len(s)-1 while l \u0026lt; r: while l\u0026lt;r and not s[l].isalnum(): l += 1 while l\u0026lt;r and not s[r].isalnum(): r -= 1 if l\u0026lt;r and s[l].lower() != s[r].lower(): return False l += 1 r -= 1 return True # Time O(N) # Space O(1)  ","id":19,"section":"posts","summary":"LC 152 Valid Palindrome Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. Note: For the purpose of this problem, we define empty string as valid palindrome. e.g. “0P”, “.,” Solution 2020-09-27 Notes: 题目本身很简单，但是two notes：1. wh","tags":["leetcode","two_pointers"],"title":"152 Valid Palindrome","uri":"https://foxisawesome.github.io/posts/152-valid-palindrome/","year":"2020"},{"content":"LC 11 Container With Most Water   Given n non-negative integers a1, a2, \u0026hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.\n Solution 2020-09-27 Notes:  左右pointers同时相向，较小的移动，online update 水容量。  class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: l, r = 0, len(height)-1 ans = 0 while l \u0026lt; r: l_bar, r_bar = height[l], height[r] ans = max(ans, min(l_bar, r_bar)*(r-l)) if l_bar \u0026gt; r_bar: r -= 1 else: l += 1 return ans # Time O(N) # Space O(1)  ","id":20,"section":"posts","summary":"LC 11 Container With Most Water Given n non-negative integers a1, a2, \u0026hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Solution 2020-09-27 Notes: 左右poi","tags":["leetcode","two_pointers"],"title":"11 Container With Most Water","uri":"https://foxisawesome.github.io/posts/11-container-with-most-water/","year":"2020"},{"content":"LC 74 Search a 2d Matrix   Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.   Solution 2020-09-25 Notes:  Right bound binary search returns the closest left bound, e.g. binarySearch([1,3,5,7], 4). 两次binary search 搞定。 其他做法还有从 左下，右上遍历。 reshape了用 in。  class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: if not matrix or len(matrix)== 0 or len(matrix[0]) == 0: return 0 nr, nc = len(matrix), len(matrix[0]) nums = [] for i in range(nr): nums.append(matrix[i][0]) row = self.binarySearch(nums, target) col = self.binarySearch(matrix[row], target) print(row, col) return matrix[row][col] == target def binarySearch(self, nums, target): l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r-l)//2 if nums[m] \u0026lt;= target: l = m + 1 elif nums[m] \u0026gt; target: r = m - 1 return r # Time O(NR + logNC) # Space O(NR)  ","id":21,"section":"posts","summary":"LC 74 Search a 2d Matrix Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Solution 2020-09-25 Notes: Right bound binary search returns the closest left bound, e.g. binarySearch([1,3,5,7], 4). 两次","tags":["leetcode","binary_search"],"title":"74 Search a 2d Matrix","uri":"https://foxisawesome.github.io/posts/74-search-a-2d-matrix/","year":"2020"},{"content":" [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip(['a','b'],['c','d'])]: [[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;c\u0026rsquo;], [\u0026lsquo;b\u0026rsquo;, \u0026rsquo;d\u0026rsquo;]] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]  ","id":22,"section":"posts","summary":" [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]] [[x,y] for x, y in zip(['a','b'],['c','d'])]: [[\u0026lsquo;a\u0026rsquo;, \u0026lsquo;c\u0026rsquo;], [\u0026lsquo;b\u0026rsquo;, \u0026rsquo;d\u0026rsquo;]] one liner to create dictionary:lookup = {val: i for i, val in enumerate(order)} this reverse check dict and return max val count in dict  max_val = max(dict.values()) max_freq = max(dict, key=dict.get) for key, val in dict.items(): if val == max_val: return key sorted_dict = sorted(dict, key = lambda x: (-dict[x]) ) sorted_dict[0]  ","tags":null,"title":"Cheatsheet","uri":"https://foxisawesome.github.io/posts/cheatsheet/","year":"2020"},{"content":"LC 36 Valid Sudoku   Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.  A partially filled sudoku which is valid.\n Solution 2020-09-25 Notes:  按着题目要求实现就好了。 [[x,y] for x in [0,3] for y in [6,9]]: generate pairs [[0, 6], [0, 9], [3, 6], [3, 9]].  class Solution: def isValidSudoku(self, board: List[List[str]]) -\u0026gt; bool: return self.boxValid(board) and self.colValid(board) and self.rowValid(board) def rowValid(self, board): for i in range(9): t = [str(x) for x in range(1,10)] for j in range(9): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True def colValid(self, board): for j in range(9): t = [str(x) for x in range(1,10)] for i in range(9): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True def boxValid(self, board): points = [[x,y] for x in [0,3,6] for y in [0,3,6]] for p in points: t = [str(x) for x in range(1,10)] for i in range(p[0], p[0]+3): for j in range(p[1],p[1]+3): if board[i][j] != '.' and board[i][j] not in t: return False elif board[i][j] != '.': t.remove(board[i][j]) return True # Time O(N^2) # Space O(1)  ","id":23,"section":"posts","summary":"LC 36 Valid Sudoku Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid. Solution 2020-09-25 Notes: 按","tags":["leetcode","matrix"],"title":"36 Valid Sudoku","uri":"https://foxisawesome.github.io/posts/36-valid-sudoku/","year":"2020"},{"content":"LC 771 Jewels and Stones   You\u0026rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \u0026quot;a\u0026quot; is considered a different type of stone from \u0026quot;A\u0026quot;.\nInput: J = \u0026quot;aA\u0026quot;, S = \u0026quot;aAAbbbb\u0026quot; Output: 3   Solution 2020-09-25 Notes:  这应该放第一道题啊。  class Solution: def numJewelsInStones(self, J: str, S: str) -\u0026gt; int: if not J or not S: return 0 j = set(J) c = 0 for s in S: if s in j: c += 1 return c # Time O(N) # Space O(1)  ","id":24,"section":"posts","summary":"LC 771 Jewels and Stones You\u0026rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so","tags":["leetcode","hashtable"],"title":"771 Jewels and Stones","uri":"https://foxisawesome.github.io/posts/771-jewels-and-stones/","year":"2020"},{"content":"LC 62 Unique Paths   A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below).\nThe robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below).\nHow many possible unique paths are there?\n Solution 2020-09-25 Notes:  像climb stair的dp，robot只可能向右或者向下运动。所以路径只可能来自于dp[i][j-1] + dp[i-1][j]。在topmost 和 leftmost处恒为1.  class Solution: def uniquePaths(self, m: int, n: int) -\u0026gt; int: dp = [[0]*n for _ in range(m)] dp[0][0] = 1 if m==1 and n==1: return dp[-1][-1] for i in range(0,m): for j in range(0,n): if i == 0 and j != 0: dp[i][j] = 1 elif i != 0 and j == 0: dp[i][j] = 1 else: dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[-1][-1] # Time O(MN) # Space O(MN)  ","id":25,"section":"posts","summary":"LC 62 Unique Paths A robot is located at the top-left corner of a m x n grid (marked \u0026lsquo;Start\u0026rsquo; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked \u0026lsquo;Finish\u0026rsquo; in the diagram below). How many possible unique paths are there? Solution 2020-09-25 Notes: 像cli","tags":["leetcode","dp"],"title":"62 Unique Paths","uri":"https://foxisawesome.github.io/posts/62-unique-paths/","year":"2020"},{"content":"LC 819 Most Common Word   Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn\u0026rsquo;t banned, and that the answer is unique.\nWords in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.\nInput: paragraph = \u0026quot;Bob hit a ball, the hit BALL flew far after it was hit.\u0026quot; banned = [\u0026quot;hit\u0026quot;] Output: \u0026quot;ball\u0026quot;   Solution 2020-09-25 Notes:  API: lower(), split() default反而好用，要是specified split(‘ ’)就会出现连着两个空格分割有问题的情况。 replace() 那些特殊符号。 max() 还有key 这个argument，很好用啊。  class Solution: def mostCommonWord(self, paragraph: str, banned: List[str]) -\u0026gt; str: d = dict() b = set(banned) for c in \u0026quot;!?',;.\u0026quot;: paragraph = paragraph.replace(c, ' ') words = paragraph.lower().split() for w in words: if w not in b: d[w] = d.get(w,0) + 1 return max(d, key=d.get) # Time O(N) # Space O(N)  ","id":26,"section":"posts","summary":"LC 819 Most Common Word Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn\u0026rsquo;t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The","tags":["leetcode","string"],"title":"819 Most Common Word","uri":"https://foxisawesome.github.io/posts/819-most-common-word/","year":"2020"},{"content":"LC 1137 N Th Tribonacci Number   The Tribonacci sequence Tn is defined as follows:\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u0026gt;= 0.\nGiven n, return the value of Tn.\n Solution 2020-09-25 Notes:  加个memo在 def __init__(self): 能把整个recursion写在一个函数签名里。  class Solution: def __init__(self): self.memo = dict() self.memo[0] = 0 self.memo[1] = 1 self.memo[2] = 1 def tribonacci(self, n: int) -\u0026gt; int: if n in self.memo: return self.memo[n] self.memo[n] = self.tribonacci(n-1) + self.tribonacci(n-2) + self.tribonacci(n-3) return self.memo[n] # Time O(N) # Space O(N)  ","id":27,"section":"posts","summary":"LC 1137 N Th Tribonacci Number The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n \u0026gt;= 0. Given n, return the value of Tn. Solution 2020-09-25 Notes: 加个memo在 def __init__(self): 能把整个recursion写在一","tags":["leetcode","recursion"],"title":"1137 N Th Tribonacci Number","uri":"https://foxisawesome.github.io/posts/1137-n-th-tribonacci-number/","year":"2020"},{"content":"LC 303 Range Sum Query Immutable   Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.\nGiven nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3   Solution 2020-09-25 Notes:  这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求和的故事。 还有就是对 python class写法的考察，记得把 cum_sum 写在__init_里。  class NumArray: def __init__(self, nums: List[int]): if not nums: return n = len(nums) self.cum_sum = [0] * n self.cum_sum[0] = nums[0] for k in range(1,n): self.cum_sum[k] = self.cum_sum[k-1] + nums[k] def sumRange(self, i: int, j: int) -\u0026gt; int: return self.cum_sum[j] - self.cum_sum[i-1] if i!=0 else self.cum_sum[j] # Your NumArray object will be instantiated and called as such: # obj = NumArray(nums) # param_1 = obj.sumRange(i,j) # Time O(N) # Space O(N)  ","id":28,"section":"posts","summary":"LC 303 Range Sum Query Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -\u0026gt; 1 sumRange(2, 5) -\u0026gt; -1 sumRange(0, 5) -\u0026gt; -3 Solution 2020-09-25 Notes: 这题要说的就是用 pre sum (cumulative sum) 来避免重复计算求","tags":["leetcode","array"],"title":"303 Range Sum Query Immutable","uri":"https://foxisawesome.github.io/posts/303-range-sum-query-immutable/","year":"2020"},{"content":"LC 209 Minimum Size Subarray Sum   Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn\u0026rsquo;t one, return 0 instead.\nInput: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint   Solution 2020-09-25 Notes:  这题 O(N)的解法，很快就想到了sliding window。第一次盲code sliding window，发现好多implementation的细节。最后提交了好几次才完成。 比如在sum_ \u0026lt; s 时，不需要 额外的while loop。其次， 在shrinking left pointer，且不满足while condition时 不需要重制 sum_ 以及 l。 多做几遍需要！  class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -\u0026gt; int: if not nums: return 0 l, r = 0, 0 sum_ = 0 ans = float('inf') while r \u0026lt; n: sum_ += nums[r] r += 1 while sum_ \u0026gt;= s: sum_ -= nums[l] l += 1 ans = min(ans, r-l+1) return ans if ans != float('inf') else 0 # Time O(N) # Space O(1)  题目还提到了 O(NlogN)的做法，那就自然想到了 binary search。昨天刚好做了很多binary search的难题。 想要不超时的话，就必须pre-process cum_sum。爽！\n binary search的是一个length，所以范围在[1, len(nums)] 我们需要比较的是 len== mid 时的max sum vs s. 而且我们寻找的是 minimum len，所以在search时要保存一个ans=min(ans,m)  class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) l, r = 1, n ans = float('inf') cum_sum = [0] * n cum_sum[0] = nums[0] for i in range(1,n): cum_sum[i] = cum_sum[i-1] + nums[i] while l \u0026lt;= r: m = l + (r-l)//2 sum_ = cum_sum[m-1] for i in range(m,n): sum_ = max(sum_, cum_sum[i]-cum_sum[i-m]) if sum_ \u0026lt; s: l = m + 1 elif sum_ \u0026gt;= s: ans = min(ans,m) r = m - 1 return ans if ans != float('inf') else 0 # Time O(NlogN) # Space O(N)  ","id":29,"section":"posts","summary":"LC 209 Minimum Size Subarray Sum Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn\u0026rsquo;t one, return 0 instead. Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint Solution 2020-09-25 Notes: 这题 O(N)的","tags":["leetcode","sliding_window","binary_search","dia"],"title":"209 Minimum Size Subarray Sum","uri":"https://foxisawesome.github.io/posts/209-minimum-size-subarray-sum/","year":"2020"},{"content":"LC 167 Two Sum II Input Array Is Sorted   Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\nInput: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.   Solution 2020-09-25 Notes:  最简单的一类 two pointers。左右相向，每次走一步。看起来很像，但不是binary search。  class Solution: def twoSum(self, numbers: List[int], target: int) -\u0026gt; List[int]: if not numbers: return [-1,-1] left = 0 right = len(numbers)-1 while left \u0026lt;= right: if numbers[left] + numbers[right] == target: return [left+1, right+1] elif numbers[left] + numbers[right] \u0026lt; target: left += 1 elif numbers[left] + numbers[right] \u0026gt; target: right -= 1 return [-1,-1] # Time O(N) # Space O(1)  ","id":30,"section":"posts","summary":"LC 167 Two Sum II Input Array Is Sorted Given an array of integers that is already *sorted in ascending order*, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The","tags":["leetcode","two_pointers"],"title":"167 Two Sum II Input Array Is Sorted","uri":"https://foxisawesome.github.io/posts/167-two-sum-ii-input-array-is-sorted/","year":"2020"},{"content":"LC 75 Sort Colors   Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\nFollow up:\n Could you solve this problem without using the library\u0026rsquo;s sort function? Could you come up with a one-pass algorithm using only O(1) constant space?  Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2]   Solution 2020-09-25 Notes:  最简单 two-pass，space O(N)的算法。就是先count一遍，然后写入nums 高级的做法如下，两块隔板(l, r)的做法，l 隔开 0，1； r 隔开 1，2。然后一根指针游走于nums间。  class Solution: def sortColors(self, nums: List[int]) -\u0026gt; None: n = len(nums) l, r = 0, n-1 i = 0 while i \u0026lt;= r: if nums[i] == 0: nums[i], nums[l] = nums[l], nums[i] i += 1 l += 1 elif nums[i] == 1: i += 1 elif nums[i] == 2: nums[i], nums[r] = nums[r], nums[i] r -= 1 return nums # Time O(N) # Space O(1)  ","id":31,"section":"posts","summary":"LC 75 Sort Colors Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Follow up: Could you solve this problem without using the library\u0026rsquo;s sort function?","tags":["leetcode","two_pointers","sort"],"title":"75 Sort Colors","uri":"https://foxisawesome.github.io/posts/75-sort-colors/","year":"2020"},{"content":"LC 875 Koko Eating Bananas   Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours.\nKoko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won\u0026rsquo;t eat any more bananas during this hour.\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.\nReturn the minimum integer K such that she can eat all the bananas within H hours.\nInput: piles = [3,6,7,11], H = 8 Output: 4   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def minEatingSpeed(self, piles: List[int], H: int) -\u0026gt; int: l, r = 1, max(piles) while l \u0026lt;= r: m = l + (r-l)//2 if self.speedBalancer(piles, m) \u0026gt; H: l = m + 1 elif self.speedBalancer(piles, m) \u0026lt;= H: r = m - 1 return l def speedBalancer(self, piles, target): h = 0 for i in piles: h += i // target if i % target != 0: h += 1 return h # Time O(Nlog max_pile) # Space O(1)  ","id":32,"section":"posts","summary":"LC 875 Koko Eating Bananas Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them","tags":["leetcode","binary_search"],"title":"875 Koko Eating Bananas","uri":"https://foxisawesome.github.io/posts/875-koko-eating-bananas/","year":"2020"},{"content":"LC 774 Minimize Max Distance to Gas Station   On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length.\nNow, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D.\nInput: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283. 这题binary search 写法有点怪的原因是，因为要寻找一个continuous number。l+1e06 \u0026lt; r是为了快速收敛。寻找的是max D，所以是 right bound。  class Solution: def minmaxGasDist(self, stations: List[int], K: int) -\u0026gt; float: n = len(stations) dis = [0]*(n-1) for i in range(1,n): dis[i-1] = stations[i]-stations[i-1] l, r = 1e-6, max(dis) while l+1e-6 \u0026lt; r: m = l + (r-l)/2 c = 0 for i in range(n-1): c += (dis[i])//m if c \u0026gt; K: l = m elif c \u0026lt;= K: r = m return r # Time O(Nlog(max_dis)) # Space O(1)  ","id":33,"section":"posts","summary":"LC 774 Minimize Max Distance to Gas Station On a horizontal number line, we have gas stations at positions stations[0], stations[1], ..., stations[N-1], where N = stations.length. Now, we add K more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.Return the smallest possible value of D. Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9 Output: 0.500000","tags":["leetcode","binary_search"],"title":"774 Minimize Max Distance to Gas Station","uri":"https://foxisawesome.github.io/posts/774-minimize-max-distance-to-gas-station/","year":"2020"},{"content":"LC 410 Split Array Largest Sum   Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\nWrite an algorithm to minimize the largest sum among these m subarrays.\nInput: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def splitArray(self, nums: List[int], m: int) -\u0026gt; int: l, r = max(nums), sum(nums) ans = r while l \u0026lt;= r: mid = l + (r-l)//2 if self.divide(nums, mid) \u0026lt;= m: ans = min(ans, mid) r = mid - 1 elif self.divide(nums, mid) \u0026gt; m: l = mid + 1 return ans def divide(self, nums, target): count, sum_ = 1, 0 for i in nums: if sum_+i \u0026gt; target: count += 1 sum_ = 0 sum_ += i return count # Time O(Nlog(sum of array)) # Space O(N)  ","id":34,"section":"posts","summary":"LC 410 Split Array Largest Sum Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Input: nums = [7,2,5,10,8], m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5]","tags":["leetcode","binary_search"],"title":"410 Split Array Largest Sum","uri":"https://foxisawesome.github.io/posts/410-split-array-largest-sum/","year":"2020"},{"content":"LC 1011 Capacity to Ship Packages Within D Days   conveyor belt has packages that must be shipped from one port to another within D days.\nThe i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within D days.\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5 Output: 15 Explanation: A ship capacity of 15 is the minimum to ship all the packages in 5 days like this: 1st day: 1, 2, 3, 4, 5 2nd day: 6, 7 3rd day: 8 4th day: 9 5th day: 10 Note that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed.   Solution 2020-09-24 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def shipWithinDays(self, weights: List[int], D: int) -\u0026gt; int: l, r = max(weights), sum(weights) while l \u0026lt;= r: m = l + (r-l)//2 if self.loadBalancer(weights, m) \u0026gt; D: l = m + 1 elif self.loadBalancer(weights, m) \u0026lt;= D: r = m - 1 return l def loadBalancer(self, weights, target): c, sum_ = 1, 0 for i in weights: if sum_+i \u0026gt; target: c += 1 sum_ = 0 sum_ += i return c # Time O() # Space O()  ","id":35,"section":"posts","summary":"LC 1011 Capacity to Ship Packages Within D Days conveyor belt has packages that must be shipped from one port to another within D days. The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship. Return","tags":["leetcode","binary_search"],"title":"1011 Capacity to Ship Packages Within D Days","uri":"https://foxisawesome.github.io/posts/1011-capacity-to-ship-packages-within-d-days/","year":"2020"},{"content":"LC 21 Merge Two Sorted Lists   Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.\nInput: 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4   Solution 2020-09-24 Notes:  不要create 新的 ListNode along the way, making algo much faster.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: if not l1: return l2 if not l2: return l1 head = p = ListNode(0) while l1 and l2: if l1.val \u0026lt;= l2.val: p.next = l1 l1 = l1.next else: p.next = l2 l2 = l2.next p = p.next l = l1 if l1 else l2 p.next = l return head.next # Time O(M+N) # Space O(1)  ","id":36,"section":"posts","summary":"LC 21 Merge Two Sorted Lists Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists. Input: 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 Output: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 Solution 2020-09-24 Notes: 不要create 新的 ListNode along the way, making algo much faster. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"21 Merge Two Sorted Lists","uri":"https://foxisawesome.github.io/posts/21-merge-two-sorted-lists/","year":"2020"},{"content":"LC 14 Longest Common Prefix   Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026quot;\u0026quot;.\nInput: [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot;   Solution 2020-09-24 Notes:  第三刷了，当年做的很痛苦的一道题。其实很简单。  class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if not strs: return \u0026quot;\u0026quot; strs.sort() for i in range(len(strs[0])): for j in strs[1:]: if strs[0][i] != j[i]: return strs[0][:i] return strs[0] # Time O(S*N), S: len of min word # Space O(1)  ","id":37,"section":"posts","summary":"LC 14 Longest Common Prefix Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \u0026quot;\u0026quot;. Input: [\u0026quot;flower\u0026quot;,\u0026quot;flow\u0026quot;,\u0026quot;flight\u0026quot;] Output: \u0026quot;fl\u0026quot; Solution 2020-09-24 Notes: 第三刷了，当年做的很痛苦的一道题。其实很简单。 class Solution: def longestCommonPrefix(self, strs: List[str]) -\u0026gt; str: if","tags":["leetcode","string"],"title":"14 Longest Common Prefix","uri":"https://foxisawesome.github.io/posts/14-longest-common-prefix/","year":"2020"},{"content":"LC 38 Count and Say   The count-and-say sequence is the sequence of integers with the first five terms as following:\n1. 1 2. 11 3. 21 4. 1211 5. 111221   Solution 2020-09-24 Notes:  algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有点复杂。。。  class Solution: def countAndSay(self, n: int) -\u0026gt; str: ans = '1' if n == 1: return ans for _ in range(2,n+1): c, indata = 1, ans n = len(indata) stack, p = [indata[0]], 0 ans = '' while p \u0026lt; n-1: if indata[p] == indata[p+1]: c += 1 else: ans += str(c) + stack.pop() c= 1 stack.append(indata[p+1]) p += 1 ans += str(c) + stack.pop() return ans # Time O() # Space O(1)  ","id":38,"section":"posts","summary":"LC 38 Count and Say The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 Solution 2020-09-24 Notes: algo就顺着读法写出来就好了。锻炼loop写法的好题。 主要是time complexity 有","tags":["leetcode","string"],"title":"38 Count and Say","uri":"https://foxisawesome.github.io/posts/38-count-and-say/","year":"2020"},{"content":"LC 1231 Divide Chocolate   You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness.\nYou want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks.\nBeing generous, you will eat the piece with the minimum total sweetness and give the other pieces to your friends.\nFind the maximum total sweetness of the piece you can get by cutting the chocolate bar optimally.\nInput: sweetness = [1,2,3,4,5,6,7,8,9], K = 5 Output: 6 Explanation: You can divide the chocolate to [1,2,3], [4,5], [6], [7], [8], [9]   Solution 2020-09-23 Notes:  题意就是 find max of minium sub-array sum。那么binary search的就是right bound of min sum. 在code中就是那个target variable。 cut时，要是给定target 只要sub-array的sum LE target就会来一刀。最后返回与given的K+1比较。 同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283.  class Solution: def maximizeSweetness(self, sweetness: List[int], K: int) -\u0026gt; int: l, r = min(sweetness), sum(sweetness)//(K+1) while l \u0026lt;= r: target = l + (r-l)//2 if self.cutChocolate(target, sweetness) \u0026lt; K+1: r = target - 1 elif self.cutChocolate(target, sweetness) \u0026gt;= K+1: l = target + 1 return r def cutChocolate(self, target, sweetness): cut, sum_ = 0, 0 for i in sweetness: sum_ += i if sum_ \u0026gt;= target: cut += 1 sum_ = 0 return cut # Time O(logN) # Space O(1)  ","id":39,"section":"posts","summary":"LC 1231 Divide Chocolate You have one chocolate bar that consists of some chunks. Each chunk has its own sweetness given by the array sweetness. You want to share the chocolate with your K friends so you start cutting the chocolate bar into K+1 pieces using K cuts, each piece consists of some consecutive chunks. Being generous, you will eat the piece with the minimum total sweetness and give the","tags":["leetcode","binary_search"],"title":"1231 Divide Chocolate","uri":"https://foxisawesome.github.io/posts/1231-divide-chocolate/","year":"2020"},{"content":"LC 27 Remove Element   Given an array nums and a value val, remove all instances of that value in-place and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nThe order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length.\n Solution 2020-09-23 Notes:  开始做时，想着一部先让r找到非value的数(while)，但是这样有些corner cases不能过。还是用这个比较好。  class Solution: def removeElement(self, nums: List[int], val: int) -\u0026gt; int: if not nums: return 0 l, r = 0, len(nums)-1 while l \u0026lt;= r: if nums[l] == val and nums[r] == val: r -= 1 elif nums[l] == val and nums[r] != val: nums[l], nums[r] = nums[r], nums[l] l += 1 r -= 1 elif nums[l] != val and nums[r] == val: l += 1 r -= 1 else: l += 1 return l # Time O(N) # Space O(1)  ","id":40,"section":"posts","summary":"LC 27 Remove Element Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn\u0026rsquo;t matter what you leave beyond the new length. Solution 2020-09-23 Notes: 开始做时","tags":["leetcode","two_pointers"],"title":"27 Remove Element","uri":"https://foxisawesome.github.io/posts/27-remove-element/","year":"2020"},{"content":"LC 28 Implement Strstr   Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nInput: haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot; Output: 2   Solution 2020-09-23 Notes:  官方解答里有中 $\\mathcal{O}(N)$ 的解哦！  class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen] == needle: return i return -1 # Time O((N-L)*L), where N is a length of haystack and L is a length of needle. We compute a substring of length L in a loop, which is executed (N - L) times. # Space O(1)  ","id":41,"section":"posts","summary":"LC 28 Implement Strstr Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Input: haystack = \u0026quot;hello\u0026quot;, needle = \u0026quot;ll\u0026quot; Output: 2 Solution 2020-09-23 Notes: 官方解答里有中 $\\mathcal{O}(N)$ 的解哦！ class Solution: def strStr(self, haystack: str, needle: str) -\u0026gt; int: hLen = len(haystack) nLen = len(needle) for i in range(hLen-nLen+1): if haystack[i:i+nLen]","tags":["leetcode","string"],"title":"28 Implement Strstr","uri":"https://foxisawesome.github.io/posts/28-implement-strstr/","year":"2020"},{"content":"LC 349 Intersection of Two Arrays   Given two arrays, write a function to compute their intersection.\n Each element in the result must be unique. The result can be in any order.   Solution 2020-09-23 Notes:  很多做法，set本身有intersection()的method。  class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] s1 = set(nums1) s2 = set(nums2) return s1.intersection(s2) # Time O(n1 + n2) # Space O(n1 + n2)  ","id":42,"section":"posts","summary":"LC 349 Intersection of Two Arrays Given two arrays, write a function to compute their intersection. Each element in the result must be unique. The result can be in any order. Solution 2020-09-23 Notes: 很多做法，set本身有intersection()的method。 class Solution: def","tags":["leetcode","hashtable"],"title":"349 Intersection of Two Arrays","uri":"https://foxisawesome.github.io/posts/349-intersection-of-two-arrays/","year":"2020"},{"content":"LC 350 Intersection of Two Arrays II   Given two arrays, write a function to compute their intersection.\nInput: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2]   Solution 2020-09-23 Notes:  简单题两种高效做法。   hashtable  class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1) ans = [] c1 = collections.Counter(nums1) c2 = collections.Counter(nums2) for k, val in c1.items(): if k in c2: ans += [k] * min(val, c2[k]) return ans # Time O(N) # Space O(N)  Sorted + two pointers  class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1) ans = [] nums1.sort() nums2.sort() p1, p2 = 0, 0 while p1 \u0026lt; n1 and p2 \u0026lt; n2: if nums1[p1] == nums2[p2]: ans.append(nums1[p1]) p1 += 1 p2 += 1 elif nums1[p1] \u0026gt; nums2[p2]: p2 += 1 elif nums1[p1] \u0026lt; nums2[p2]: p1 += 1 return ans # Time O(NlogN) # Space O(NlogN)  ","id":43,"section":"posts","summary":"LC 350 Intersection of Two Arrays II Given two arrays, write a function to compute their intersection. Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Solution 2020-09-23 Notes: 简单题两种高效做法。 hashtable class Solution: def intersect(self, nums1: List[int], nums2: List[int]) -\u0026gt; List[int]: if not nums1 or not nums2: return [] n1, n2 = len(nums1), len(nums2) if n2 \u0026gt; n1: return self.intersect(nums2, nums1)","tags":["leetcode","hashtable","two_pointers"],"title":"350 Intersection of Two Arrays II","uri":"https://foxisawesome.github.io/posts/350-intersection-of-two-arrays-ii/","year":"2020"},{"content":"LC 202 Happy Number   Write an algorithm to determine if a number n is \u0026ldquo;happy\u0026rdquo;.\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\nReturn True if n is a happy number, and False if not.\nInput: 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1   Solution 2020-09-23 Notes:  第二刷了，一次就过了。 不过time/space complexity 有点复杂。。。  class Solution: def isHappy(self, n: int) -\u0026gt; bool: d = set() ans = n while True: n = ans ans = 0 while n \u0026gt; 0: n, r = divmod(n,10) ans += r**2 if ans not in d: d.add(ans) else: break return ans == 1 # Time O() # Space O()  ","id":44,"section":"posts","summary":"LC 202 Happy Number Write an algorithm to determine if a number n is \u0026ldquo;happy\u0026rdquo;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers","tags":["leetcode",""],"title":"202 Happy Number","uri":"https://foxisawesome.github.io/posts/202-happy-number/","year":"2020"},{"content":"LC 278 First Bad Version   You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n Solution 2020-09-23 Notes:  要找的是lower bound of those True cases.  class Solution: def firstBadVersion(self, n): l, r = 1, n while l \u0026lt;= r: m = l + (r-l)//2 if isBadVersion(m) == False: l = m+1 elif isBadVersion(m) == True: r = m-1 return l # Time O(logN) # Space O(1)  ","id":45,"section":"posts","summary":"LC 278 First Bad Version You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,","tags":["leetcode","binary_search"],"title":"278 First Bad Version","uri":"https://foxisawesome.github.io/posts/278-first-bad-version/","year":"2020"},{"content":"LC 35 Search Insert Position   Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n Solution 2020-09-23 Notes:  标准的left bound 的binary search 写法。 初秋的夜晚很舒服。  class Solution: def searchInsert(self, nums: List[int], target: int) -\u0026gt; int: l, r = 0, len(nums)-1 while l \u0026lt;= r: m = l + (r-l)//2 if nums[m] \u0026lt; target: l = m+1 elif nums[m] \u0026gt;= target: r = m-1 return l # Time O(logN) # Space O(1)  ","id":46,"section":"posts","summary":"LC 35 Search Insert Position Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. Solution 2020-09-23 Notes: 标准的left bound 的binary search 写法。 初秋的夜晚很舒服。 class Solution: def","tags":["leetcode","binary_search"],"title":"35 Search Insert Position","uri":"https://foxisawesome.github.io/posts/35-search-insert-position/","year":"2020"},{"content":"LC 134 Gas Station   There are N gas stations along a circular route, where the amount of gas at station i is gas[i].\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.\nReturn the starting gas station\u0026rsquo;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.\n Solution 2020-09-23 Notes:  一道有趣的巧题。 暴力的想法就是在每个gas station都按照题目描述的check一遍，这样需要$\\mathcal{O}(N^2)$的time 但是答案巧就巧在check了这些condition后能one pass。存两个变量：total_tank 和 curr_tank。然后每站check curr_tank ? 0。  class Solution: def canCompleteCircuit(self, gas: List[int], cost: List[int]) -\u0026gt; int: n = len(gas) total_tank, curr_tank = 0, 0 ans = 0 for i in range(n): total_tank += gas[i] - cost[i] curr_tank += gas[i] - cost[i] if curr_tank \u0026lt; 0: ans = i + 1 curr_tank = 0 ans = -1 if total_tank \u0026lt; 0 else ans return ans # Time O(N) # Space O(1)  ","id":47,"section":"posts","summary":"LC 134 Gas Station There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station\u0026rsquo;s index if you","tags":["leetcode"],"title":"134 Gas Station","uri":"https://foxisawesome.github.io/posts/134-gas-station/","year":"2020"},{"content":"LC 103 Binary Tree Zigzag Level Order Traversal   Given a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).\nFor example: Given binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return its zigzag level order traversal as:\n[ [3], [20,9], [15,7] ]   Solution 2020-09-23 Notes:  一个简单的post_order print，store在dict里 感觉对dictionary的API还有loop，sort的操作还得多练练。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def zigzagLevelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] d = collections.defaultdict(list) h = 0 self.post_order(root, h, d) ans = [] H = max([i for i,val in d.items()]) for i in range(H): if i%2 == 0: ans.append(d[i+1]) else: ans.append(d[i+1][::-1]) return ans def post_order(self, root, h, d): if not root: return h += 1 l = self.post_order(root.left, h, d) r = self.post_order(root.right, h, d) d[h].append(root.val) return # Time O(N) # Space O(H)  ","id":48,"section":"posts","summary":"LC 103 Binary Tree Zigzag Level Order Traversal Given a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution 2020-09-23 Notes: 一个","tags":["leetcode","tree"],"title":"103 Binary Tree Zigzag Level Order Traversal","uri":"https://foxisawesome.github.io/posts/103-binary-tree-zigzag-level-order-traversal/","year":"2020"},{"content":"LC 1283 Find the Smallest Divisor Given a Threshold   a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nInput: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).   Solution 2020-09-23 Notes:  同类题: LC 1011, LC 1231, LC 410, LC 774, LC 875, LC 1283. 题目有点难懂，题意是找最小的divisor，使得sum( ceiling(division) ) LE threshold。 用binary search，因为求min 所以是left bound。 取ceiling的方式：(i-1)//m +1  class Solution: def smallestDivisor(self, nums: List[int], threshold: int) -\u0026gt; int: l, r = 1, max(nums) while l \u0026lt;= r: m = l + (r-l)//2 sum_ = sum([(i+m-1)//m for i in nums ]) if sum_ \u0026gt; threshold: l = m + 1 else: r = m - 1 return l # Time O(NlogM): M=max(nums) # Space O(1)  ","id":49,"section":"posts","summary":"LC 1283 Find the Smallest Divisor Given a Threshold a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold. Input: nums = [1,2,5,9], threshold = 6 Output: 5 Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. If the divisor","tags":["leetcode","binary_search"],"title":"1283 Find the Smallest Divisor Given a Threshold","uri":"https://foxisawesome.github.io/posts/1283-find-the-smallest-divisor-given-a-threshold/","year":"2020"},{"content":"LC 179 Largest Number   Given a list of non negative integers, arrange them such that they form the largest number.\nInput: [3,30,34,5,9] Output: \u0026quot;9534330\u0026quot;   Solution 2020-09-23 Notes:  开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 \u0026amp; 54, 下一位要与较短书的前一位比较。 看了答案就太简单啦。但是有几个API不知道。看了python doc: The sort routines are guaranteed to use __lt__() (lt: less than) when making comparisons between two objects. So, it is easy to add a standard sort order to a class by defining an __lt__() method: refrence 其次是map(), 不知道efficiency和 loop through怎么样。 Python 3 中，sort() removed, cmp argument.  class LargerNumKey(str): def __lt__(x, y): return x+y \u0026gt; y+x class Solution: def largestNumber(self, nums): largest_num = ''.join(sorted(map(str, nums), key=LargerNumKey)) return '0' if largest_num[0] == '0' else largest_num # Time O(N) # Space O(1)  ","id":50,"section":"posts","summary":"LC 179 Largest Number Given a list of non negative integers, arrange them such that they form the largest number. Input: [3,30,34,5,9] Output: \u0026quot;9534330\u0026quot; Solution 2020-09-23 Notes: 开始的时候想复杂了，想着先比较第一位，要是第一位相同，再比较第二位，e.g. 5 \u0026amp; 54, 下一","tags":["leetcode","string"],"title":"179 Largest Number","uri":"https://foxisawesome.github.io/posts/179-largest-number/","year":"2020"},{"content":"LC 518 Coin Change 2   You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.\nInput: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1   Solution 2020-09-23 Notes:  这题给我的第一感觉和爬楼梯是一个意思。dp[i] = \\sum dp[i-coin] 有个细节就是每个path一定要仅使用coins[0:j]，否则就会出现重复的combo。这和给定一组数求所有的subsets类似。 比如 i=3, [1,2] 和 [2,1]就是一种方法。为了避免重复，算法就必须第一次仅使用 coin =1，第二次使用 coin =1 and coin=2。 秋意浓了，2020还剩99天。加油刷！  class Solution: def change(self, amount: int, coins: List[int]) -\u0026gt; int: dp = [0] * (amount + 1) dp[0] = 1 for coin in coins: for i in range(1, amount+1): if coin \u0026lt;= i: dp[i] += dp[i-coin] return dp[amount] # Time O(NC) # Space O(N)  ","id":51,"section":"posts","summary":"LC 518 Coin Change 2 You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1","tags":["leetcode","dp"],"title":"518 Coin Change 2","uri":"https://foxisawesome.github.io/posts/518-coin-change-2/","year":"2020"},{"content":"LC 64 Minimum Path Sum   Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.\nInput:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum.   Solution 2020-09-23 Notes:   做这题时发现了好几个python 2d-array和我原先以为不一样的点：\n 不能用 a[:] 或者 a[:][:] 来deep copy 2d array。目前发现只能用copy module a[:][0] 不是选中 0th column。而是a[:]选中all sub list，然后其中的第一个。所以和 np.array 很不一样。    dp[i][j] := the minimun distance from grid[i][j] to grid[-1][-1]\n  dp 从 bottom rightmost开始，向上向左走，last column 和 last row要单独处理下。transition equation：dp[i][j] = grid[i][j] + min(dp[i][j+1], dp[i+1][j])。\n  可以继续压缩空间。\n  class Solution: def minPathSum(self, grid: List[List[int]]) -\u0026gt; int: if not grid or len(grid) == 0 or len(grid[0]) == 0: return 0 nr, nc = len(grid), len(grid[0]) dp = copy.deepcopy(grid) for i in range(nr-1,-1,-1): for j in range(nc-1, -1, -1): if j == nc-1 and i != nr-1: # deal with last col dp[i][j] = grid[i][j] + dp[i+1][j] elif i == nr-1 and j != nc-1: # deal with last row dp[i][j] = grid[i][j] + dp[i][j+1] elif i != nr -1 and j != nc -1: dp[i][j] = grid[i][j] + min(dp[i][j+1], dp[i+1][j]) return dp[0][0] # Time O(NM) # Space O(NM)  ","id":52,"section":"posts","summary":"LC 64 Minimum Path Sum Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Input:[[1,3,9],[1,5,2],[4,2,1]] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Solution 2020-09-23 Notes: 做这题时发现了好几个pyth","tags":["leetcode","dp"],"title":"64 Minimum Path Sum","uri":"https://foxisawesome.github.io/posts/64-minimum-path-sum/","year":"2020"},{"content":"LC 802 Find Eventual Safe States   In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.\nNow, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.\nWhich nodes are eventually safe? Return them as an array in sorted order.\nThe directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6] Here is a diagram of the above graph.   Solution 2020-09-22 Notes:  意思就是在有向图里找出不在cycle里的节点。写法和LC 207，LC 210完全一致。  class Solution: def eventualSafeNodes(self, graph: List[List[int]]) -\u0026gt; List[int]: n = len(graph) ans = [] visited = [0]*n for i in range(n): if self.dfs(graph, ans, visited, i): ans.append(i) return ans def dfs(self, graph, ans, visited, i): # visited: 0: unvisited, 1: visiting, 2: visited if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, ans, visited, j): return False visited[i] = 2 return True # Time O(N^2) # Space O(N)  ","id":53,"section":"posts","summary":"LC 802 Find Eventual Safe States In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural","tags":["leetcode","GRAPH","DFS"],"title":"802 Find Eventual Safe States","uri":"https://foxisawesome.github.io/posts/802-find-eventual-safe-states/","year":"2020"},{"content":"LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.\n Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -\u0026gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  ","id":54,"section":"posts","summary":"LC 1118 Number of Days in a Month   Given a year Y and a month M, return how many days there are in that month.\n Solution 2020-09-22 Notes: class Solution: def numberOfDays(self, Y: int, M: int) -\u0026gt; int: up = [1,3,5,7,8,10,12] if M == 2: if Y % 100 == 0: if Y % 400 == 0: return 29 else: return 28 else: if Y % 4 == 0: return 29 else: return 28 return 31 if M in up else 30 # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"1118 Number of Days in a Month","uri":"https://foxisawesome.github.io/posts/1118-number-of-days-in-a-month/","year":"2020"},{"content":"LC 210 Course Schedule II   There are a total of n courses you have to take labelled from 0 to n - 1.\nSome courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai.\nGiven the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to finish all courses.\n Solution 2020-09-22 Notes:  首先build graph时，是有指向性的，所以一定是graph[pre].append(cur)这么写的。 其实最先出栈的节点是最深的，所以应该输出ans[::-1]。 最后 time/space complexity应该是$\\mathcal{O}(V+E) \\sim \\mathcal{O}(N^2)$. V: vertex, E:edge. topoligical sorting algo. same questions as LC 207.  class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; List[int]: n = numCourses graph = collections.defaultdict(list) visited = [0] * n ans = [] for cur, pre in prerequisites: graph[pre].append(cur) for i in range(n): if not self.dfs(graph, i, visited,ans): return [] return ans[::-1] def dfs(self, graph, i, visited, ans): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, j, visited, ans): return False visited[i] = 2 ans.append(i) return True # Time O(N^2) # Space O(N)  BFS 的做法：\n top sort 一般都用DFS，BFS just for completeness. 把入度为0的节点放入queue中， 每次访问他的邻节点，将邻节点的入度\u0026ndash;, 直至全部走完。  class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; List[int]: n = numCourses graph = collections.defaultdict(list) indegrees = [0] * n queue = [] ans = [] for cur, pre in prerequisites: indegrees[cur] += 1 graph[pre].append(cur) for i in range(n): if indegrees[i] == 0: queue.append(i) ans.append(i) while queue: pre = queue.pop(0) # n -= 1 for j in graph[pre]: indegrees[j] -= 1 if indegrees[j] == 0: queue.append(j) ans.append(j) return ans if len(ans) == n else [] # Time O(N^2) # Space O(N)  ","id":55,"section":"posts","summary":"LC 210 Course Schedule II There are a total of n courses you have to take labelled from 0 to n - 1. Some courses may have prerequisites, for example, if prerequisites[i] = [ai, bi] this means you must take the course bi before the course ai. Given the total number of courses numCourses and a list of the prerequisite pairs, return the ordering of courses you should take to","tags":["leetcode","Graph","DFS","BFS"],"title":"210 Course Schedule II","uri":"https://foxisawesome.github.io/posts/210-course-schedule-ii/","year":"2020"},{"content":"LC 207 Course Schedule   There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\nInput: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.    Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. ```\nSolution 2020-09-21 Notes:   第一天刷Graph的题。看了 花花酱 和 负雪明烛 的答案和解释。准备这一周好好看看 Tim Roughgarden 的lecture。\n  和 LC210 是完全一样的题。\n  这题只有有向图里有cycle就return False。可以用topological sorting, using DFS.\n  拓扑排序，DFS\n同样是拓扑排序，但是换了个做法，使用DFS。这个方法是，我们每次找到一个新的点，判断从这个点出发是否有环。具体做法是使用一个visited数组，当visited[i]值为0，说明还没判断这个点；当visited[i]值为1，说明当前的循环正在判断这个点；当visited[i]值为2，说明已经判断过这个点，含义是从这个点往后的所有路径都没有环，认为这个点是安全的。\n那么，我们对每个点出发都做这个判断，检查这个点出发的所有路径上是否有环，如果判断过程中找到了当前的正在判断的路径，说明有环；找到了已经判断正常的点，说明往后都不可能存在环，所以认为当前的节点也是安全的。如果当前点是未知状态，那么先把当前点标记成正在访问状态，然后找后续的节点，直到找到安全的节点为止。最后如果到达了无路可走的状态，说明当前节点是安全的。\ndfs函数中的for循环是怎么回事呢？这个和BFS循环次数不是同一个概念，这里的循环就是看从第i个节点开始能否到达合理结果。这个节点可能没有出度了，那就把它直接放到path里；也可能有出度，那么就把它后面的节点都进行一次遍历，如果满足条件的节点都放到path里，同时把这次遍历的所有节点都标记成了已经遍历；如果一个节点已经被安全的访问过，那么就放过它，继续遍历下个节点。\n最后 time/space complexity应该是$\\mathcal{O}(V+E) \\sim \\mathcal{O}(N^2)$. V: vertex, E:edge.\n  class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -\u0026gt; bool: n = numCourses graph = collections.defaultdict(list) for cur, pre in prerequisites: graph[pre].append(cur) # 0: unknown, 1: visiting, 2: visited visited = [0]*n for i in range(n): if not self.dfs(graph, visited, i): return False return True def dfs(self, graph, visited, i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in graph[i]: if not self.dfs(graph, visited, j): return False visited[i] = 2 return True # Time O(N^2) # Space O(N^2)  ","id":56,"section":"posts","summary":"LC 207 Course Schedule There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Input: numCourses = 2,","tags":["leetcode","Graph","DFS"],"title":"207 Course Schedule","uri":"https://foxisawesome.github.io/posts/207-course-schedule/","year":"2020"},{"content":"LC 542 01 Matrix   Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.\nInput: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]]   Solution 2020-09-21 Notes:  很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水立马跳出BFS。没找到水就继续下一层BFS。 第二遍刷出来的解更快。  class Solution: def updateMatrix(self, matrix: List[List[int]]) -\u0026gt; List[List[int]]: nrow, ncol = len(matrix), len(matrix[0]) out = [ [0]*ncol for _ in range(nrow) ] directions = [[-1,0], [1,0], [0,1], [0,-1]] for i in range(nrow): for j in range(ncol): if matrix[i][j] == 1: self.bfs(matrix, nrow, ncol, directions, (i,j), out) return out def bfs(self, matrix, nrow, ncol, directions, point, out): visited = set() queue = [] queue.append(point) visited.add(point) count = 0 while queue: l = len(queue) count += 1 for x in range(l): p = queue.pop(0) for d in directions: r, c = p[0]+d[0], p[1]+d[1] new_p = (r,c) if 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and matrix[r][c]==0: out[point[0]][point[1]] = count return elif 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and matrix[r][c]==1 and new_p not in visited: queue.append(new_p) visited.add(new_p) return # Time O(r*c) # Space O(r*c)  2020-8-13 Notes:  默写了一遍模版基本做出来了。  class Solution: def updateMatrix(self, matrix: List[List[int]]) -\u0026gt; List[List[int]]: nrow, ncol = len(matrix), len(matrix[0]) out = [ [0]*ncol for _ in range(nrow) ] direction = [[-1,0], [1,0], [0,1], [0,-1]] for i in range(nrow): for j in range(ncol): if matrix[i][j] == 1: out[i][j] = self.BFS(i,j,matrix,direction,nrow, ncol, out) return out def BFS(self, r, c, matrix, direction, nrow, ncol, out): queue = [] queue.append([r,c,0]) visited = set() while queue: x0, y0, step = queue.pop(0) if matrix[x0][y0]==0: return step step += 1 visited.add((x0,y0)) for d in direction: x1, y1 = x0 + d[0], y0 + d[1] if 0\u0026lt;= x1 \u0026lt;nrow and 0\u0026lt;= y1 \u0026lt;ncol and (x1,y1) not in visited: queue.append([x1,y1,step]) visited.add((x1,y1)) return step # Time O(r*c) # Space O(r*c)  ","id":57,"section":"posts","summary":"LC 542 01 Matrix Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell. Input: [[0,0,0],[0,1,0],[1,1,1]] Output:[[0,0,0],[0,1,0],[1,2,1]] Solution 2020-09-21 Notes: 很经典的BFS题。这题的关键是BFS每一个step中所有的点都向四周找0，如果找到水","tags":["leetcode","BFS"],"title":"542 01 Matrix","uri":"https://foxisawesome.github.io/posts/542-01-matrix/","year":"2020"},{"content":"LC 200 Number of Islands   Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nInput: grid = [ [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;] ] Output: 3   Solution 2020-09-21 Notes:  很经典的BFS 或者 DFS的题。这次已经是第三刷了，终于很完整的刷出来了。 刷到今天感觉 BFS一定是用queue的写法，能保证最短路径但此题无关最短。所以用DFS也可以做。 DFS可以用stack 类似BFS的写法，但貌似大家默认更常规的写法是用backtracking的写法。  class Solution: def numIslands(self, grid: List[List[str]]) -\u0026gt; int: if not grid or len(grid)==0 or len(grid[0])==0: return 0 nrow, ncol = len(grid), len(grid[0]) directions = [[-1,0], [1,0], [0,1], [0,-1]] count = 0 for i in range(nrow): for j in range(ncol): if grid[i][j] == '1': point = (i,j) grid[i][j] = '0' self.bfs(grid, nrow, ncol, directions, point) count += 1 return count def bfs(self, grid, nrow, ncol, directions, point): queue = [] queue.append(point) while queue: p = queue.pop(0) x, y = p[0], p[1] for d in directions: r, c = x+d[0], y+d[1] if 0\u0026lt;=r\u0026lt;nrow and 0\u0026lt;=c\u0026lt;ncol and grid[r][c]=='1': queue.append((r,c)) grid[r][c] = '0' return # Time O(N) # Space O(N)  ","id":58,"section":"posts","summary":"LC 200 Number of Islands Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Input: grid = [ [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;], [\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;] ] Output: 3 Solution 2020-09-21 Notes: 很经典的B","tags":["leetcode","BFS","DFS"],"title":"200 Number of Islands","uri":"https://foxisawesome.github.io/posts/200-number-of-islands/","year":"2020"},{"content":"LC 133 Clone Graph   Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\n Solution 2020-09-21 Notes:  刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只需要保存是否遍历过这个节点即可，但是由于这个题需要把neighboors对应复制过来。那么需要进行改进，改进的方式是把set改成dict，保存每个老节点对应的新节点是多少。在Python中，字典直接保存对象（指针）之间的映射。所以，我们直接把遍历过的对象和复制出来的对象一一对应即可。当我们遍历到一个新的节点的时候，需要判断这个节点是否在字典中出现过，如果出现过就把它对应的复制出来的对象放到其neighboors里，若没有出现过，那么就重新构造该节点，并把原节点和该节点放到字典中保存。  \u0026quot;\u0026quot;\u0026quot; # Definition for a Node. class Node: def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else [] \u0026quot;\u0026quot;\u0026quot; class Solution: def cloneGraph(self, node: 'Node') -\u0026gt; 'Node': if not node: return node_copy = self.bfs(node, dict()) return node_copy def dfs(self, node, visited): if not node: return None if node in visited: return visited[node] node_copy = Node(node.val,[]) visited[node] = node_copy for n in node.neighbors: ngb = self.dfs(n,visited) if ngb: node_copy.neighbors.append(ngb) return node_copy # Time O(N) # Space O(N)  BFS solution:\nclass Solution: def cloneGraph(self, node: 'Node') -\u0026gt; 'Node': if not node: return visited = dict() queue = [node] visited[node] = Node(node.val, []) while queue: n = queue.pop(0) for neighbor in n.neighbors: if neighbor not in visited: visited[neighbor] = Node(neighbor.val, []) queue.append(neighbor) visited[n].neighbors.append(visited[neighbor]) return visited[node] # Time O(N) # Space O(N)  ","id":59,"section":"posts","summary":"LC 133 Clone Graph Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Solution 2020-09-21 Notes: 刷graph第一题，对这种数据结构还不是很懂，抄了一遍 负雪明烛 的还得体会下。一般的遍历只","tags":["leetcode","GRAPH","DFS"],"title":"133 Clone Graph","uri":"https://foxisawesome.github.io/posts/133-clone-graph/","year":"2020"},{"content":"LC 1323 Maximum 69 Number   Given a positive integer num consisting only of digits 6 and 9.\nReturn the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6).\n Solution 2020-09-21 Notes:  开始时我想着转成str()后，用binary search出最左边的6，这样不对，因为not sorted。 String.replace(old, new, counts): replace once from left to right.  class Solution: def maximum69Number (self, num: int) -\u0026gt; int: return int(str(num).replace('6','9',1)) # Time O(N) # Space O(1)  ","id":60,"section":"posts","summary":"LC 1323 Maximum 69 Number Given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). Solution 2020-09-21 Notes: 开始时我想着转成str()后，用binary search出最","tags":["leetcode","string"],"title":"1323 Maximum 69 Number","uri":"https://foxisawesome.github.io/posts/1323-maximum-69-number/","year":"2020"},{"content":"LC 47 Permutations II   Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n Solution 2020-09-21 Notes:  LC 46 的升级版。这题添加了nums里有duplicates的case。 为了保证输出时 distinct out 的条件，可以用 sort() + if i == n-1 or nums[i]!=nums[i+1]: Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums[i+1:]以避免dups。  class Solution: def permuteUnique(self, nums: List[int]) -\u0026gt; List[List[int]]: out = [] if nums: nums.sort() n = len(nums) self.dfs(nums,n,[],out) return out def dfs(self, nums, n, path, out): if len(path) == n: out.append(path[:]) return l = len(nums) for i in range(l): if i == l-1 or nums[i]!=nums[i+1]: path.append(nums[i]) self.dfs(nums[:i]+nums[i+1:], n, path, out) path.pop() # Time O() # Space O()  ","id":61,"section":"posts","summary":"LC 47 Permutations II Given a collection of numbers that might contain duplicates, return all possible unique permutations. Solution 2020-09-21 Notes: LC 46 的升级版。这题添加了nums里有duplicates的case。 为了保证输出时 distinct out 的条件，可以","tags":["leetcode","dfs"],"title":"47 Permutations II","uri":"https://foxisawesome.github.io/posts/47-permutations-ii/","year":"2020"},{"content":"LC 78 Subsets   Given a set of distinct integers, nums, return all possible subsets (the power set).\nInput: nums = [1,2,3] Output:[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]   Solution 2020-09-21 Notes:  简单的dfs题，有个新奇的点就是在dfs外面有个控制length的loop。刚开始我以为要放入dfs()，试了两层loop，或者又两个变量控制长度和nums输入，都没成. 这说明 DFS的模版应该是不变的。以后遇到，不用怀疑模版，往DFS以外想想就好了。  class Solution: def subsets(self, nums: List[int]) -\u0026gt; List[List[int]]: out = [] if nums: n = len(nums) for i in range(n+1): self.dfs(nums,out,[],i) return out def dfs(self, nums, out, path, n): if len(path) == n: out.append(path[:]) return for i in range(len(nums)): path.append(nums[i]) self.dfs(nums[i+1:],out,path,n) path.pop() # Time O() # Space O()  ","id":62,"section":"posts","summary":"LC 78 Subsets Given a set of distinct integers, nums, return all possible subsets (the power set). Input: nums = [1,2,3] Output:[[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]] Solution 2020-09-21 Notes: 简单的dfs题，有个新奇的点就是在dfs外面有个控制length的loop。刚开始我以为要","tags":["leetcode","DFS"],"title":"78 Subsets","uri":"https://foxisawesome.github.io/posts/78-subsets/","year":"2020"},{"content":"LC 77 Combinations   Given two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n.\n Solution 2020-09-21 Notes:  Dfs 模版搞一下。没啥特别的。  class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: out = [] nums = [i for i in range(1,n+1)] self.dfs(n,k,nums,[],out) return out def dfs(self, n, k, nums, path, out): if len(path)==k: out.append(path[:]) return for i in range(len(nums)): path.append(nums[i]) self.dfs(n,k,nums[i+1:],path,out) path.pop() # Time O() # Space O()  ","id":63,"section":"posts","summary":"LC 77 Combinations Given two integers n and k, return all possible combinations of k numbers out of 1 \u0026hellip; n. Solution 2020-09-21 Notes: Dfs 模版搞一下。没啥特别的。 class Solution: def combine(self, n: int, k: int) -\u0026gt; List[List[int]]: out = [] nums = [i for i in range(1,n+1)] self.dfs(n,k,nums,[],out) return out def dfs(self, n, k, nums, path, out): if len(path)==k: out.append(path[:])","tags":["leetcode","dfs"],"title":"77 Combinations","uri":"https://foxisawesome.github.io/posts/77-combinations/","year":"2020"},{"content":"LC 40 Combination Sum Ii   Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nEach number in candidates may only be used once in the combination.\nInput: candidates = [10,1,2,7,6,1,5], target = 8,\nA solution set is:[[1, 7], [1, 2, 5], [2, 6],[1, 1, 6]]\n Solution 2020-09-21 Notes:  这题与39题的唯一区别是candidates里会有dups，这样如果直接使用LC39的code会出现results里有duplicates。解决这个问题的经典方法就是，先sort，然后用i \u0026gt; index and candidates[i] == candidates[i-1]跳过可能的重复candidates complexity analysis 参见官方解答，比较复杂。  class Solution: def combinationSum2(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: out = [] candidates.sort() self.dfs(candidates, target, [], out, 0) return out def dfs(self, candidates, target, path, out, index): n = len(candidates) if sum(path) \u0026gt; target: return if sum(path) == target: out.append(path[:]) return for i in range(index,n): if i \u0026gt; index and candidates[i] == candidates[i-1]: continue path.append(candidates[i]) self.dfs(candidates, target, path, out, i+1) path.pop() # Time O() # Space O()  ","id":64,"section":"posts","summary":"LC 40 Combination Sum Ii Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is:[[1, 7], [1, 2, 5], [2, 6],[1, 1, 6]] Solution 2020-09-21 Notes: 这题与39题","tags":["leetcode","dfs"],"title":"40 Combination Sum Ii","uri":"https://foxisawesome.github.io/posts/40-combination-sum-ii/","year":"2020"},{"content":"LC 39 Combination Sum   Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\nInput: candidates = [2,3,6,7], target = 7, A solution set is: [[7],[2,2,3]]   Solution 2020-09-21 Notes:  简单的DFS题，注意：path要是list(), 就只能 append then pop 这么操作，放到dfs里时会出错。 但是计算time/Space complexity有点难。参见官方解答  class Solution: def combinationSum(self, candidates: List[int], target: int) -\u0026gt; List[List[int]]: out = [] if candidates: self.dfs(out, [], 0, candidates, target) return out def dfs(self, out, path, index, candidates, target): if sum(path) \u0026gt; target: return if sum(path) == target: out.append(path[:]) return for i in range(index,len(candidates)): path.append(candidates[i]) self.dfs(out, path, i , candidates, target) path.pop() # Time O() # Space O()  ","id":65,"section":"posts","summary":"LC 39 Combination Sum Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Input: candidates = [2,3,6,7], target = 7, A solution set is: [[7],[2,2,3]] Solution 2020-09-21 Notes: 简单的DFS题，注意：path要是list(),","tags":["leetcode","DFS"],"title":"39 Combination Sum","uri":"https://foxisawesome.github.io/posts/39-combination-sum/","year":"2020"},{"content":"LC 17 Letter Combinations of a Phone Number   Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.\n Solution 2020-09-21 Notes:  很简单的一道backtracking题套模版就可以了。为了避免dups，每次传入recursion的digits要递减。 Time complexity : $\\mathcal{O}(3^N \\times 4^M)O(3^N×4^M)$ where N is the number of digits in the input that maps to 3 letters (e.g. 2, 3, 4, 5, 6, 8) and M is the number of digits in the input that maps to 4 letters (e.g. 7, 9), and N+M is the total number digits in the input. Space complexity same as time complexity.  class Solution: def letterCombinations(self, digits: str): dict = { '2':['a','b','c'], '3':['d','e','f'], '4':['g','h','i'], '5':['j','k','l'], '6':['m','n','o'], '7':['p','q','r','s'], '8':['t','u','v'], '9':['w','x','y','z'] } out = [] if digits: l = len(digits) self.dfs(dict, digits, out, '',l) return out def dfs(self, dict, digits, out, path,l): n = len(digits) if n == 0 and len(path)==l: out.append(path[:]) return for i in range(n): for j in dict[digits[i]]: self.dfs(dict, digits[i+1:], out, path+j,l)  ","id":66,"section":"posts","summary":"LC 17 Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Solution 2020-09-21 Notes: 很简单的一道backtracking题套模版就可以了。为了避免dups，每次传入r","tags":["leetcode","DFS"],"title":"17 Letter Combinations of a Phone Number","uri":"https://foxisawesome.github.io/posts/17-letter-combinations-of-a-phone-number/","year":"2020"},{"content":"LC 921 Minimum Add to Make Parentheses Valid   Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid.\n Solution 2020-09-20 Notes:  一遍就过的题没啥好说的。  class Solution: def minAddToMakeValid(self, S: str) -\u0026gt; int: if not S: return 0 stack = [] ans = 0 for i, val in enumerate(S): if val == '(': stack.append(i) elif val == ')' and stack: stack.pop() else: ans += 1 return ans + len(stack) # Time O() # Space O()  ","id":67,"section":"posts","summary":"LC 921 Minimum Add to Make Parentheses Valid Given a string S of '(' and ')' parentheses, we add the minimum number of parentheses ( '(' or ')', and in any positions ) so that the resulting parentheses string is valid. Solution 2020-09-20 Notes: 一遍就过的题没啥好说的。 class Solution: def minAddToMakeValid(self, S: str) -\u0026gt; int: if not S: return 0 stack","tags":["leetcode","stack"],"title":"921 Minimum Add to Make Parentheses Valid","uri":"https://foxisawesome.github.io/posts/921-minimum-add-to-make-parentheses-valid/","year":"2020"},{"content":"LC 22 Generate Parentheses   Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\nFor example, given n = 3, a solution set is:\n[ \u0026quot;((()))\u0026quot;, \u0026quot;(()())\u0026quot;, \u0026quot;(())()\u0026quot;, \u0026quot;()(())\u0026quot;, \u0026quot;()()()\u0026quot; ]   Solution 2020-09-20 Notes:  可以直接套用backtracking的模版，主要是l\u0026lt;n 以及r\u0026lt;l这两个条件并列使用。  class Solution: def generateParenthesis(self, n: int) -\u0026gt; List[str]: ans = [] self.dfs(0,0,'',ans,n) return ans def dfs(self, l, r, path, ans, n): if len(path) == n*2: ans.append(path[:]) return if l \u0026lt; n: self.dfs(l+1,r,path+'(',ans,n) if r \u0026lt; l: self.dfs(l,r+1,path+')',ans,n) # Time O(N) # Space O(N)  ","id":68,"section":"posts","summary":"LC 22 Generate Parentheses Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ \u0026quot;((()))\u0026quot;, \u0026quot;(()())\u0026quot;, \u0026quot;(())()\u0026quot;, \u0026quot;()(())\u0026quot;, \u0026quot;()()()\u0026quot; ] Solution 2020-09-20 Notes: 可以直接套用backtracking的模版，主要是l\u0026lt;n","tags":["leetcode","backtracking"],"title":"22 Generate Parentheses","uri":"https://foxisawesome.github.io/posts/22-generate-parentheses/","year":"2020"},{"content":"LC 253 Meeting Rooms II   Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required.\nInput: [[0, 30],[5, 10],[15, 20]] Output: 2   Solution 2020-09-20 Notes:  核心是用 存 ending time to a min-heap, 用starting time与heap比较。 但本题最大的困惑是：line#11，为什么用h_room.pop(0)就是不能全过。  class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -\u0026gt; int: if not intervals: return 0 h_room = [] intervals.sort(key = lambda i: i[0]) heapq.heappush(h_room, intervals[0][1]) for i in intervals[1:]: if i[0] \u0026gt;= h_room[0]: heapq.heappop(h_room) heapq.heappush(h_room, i[1]) return len(h_room) # Time O() # Space O()  ","id":69,"section":"posts","summary":"LC 253 Meeting Rooms II Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si \u0026lt; ei), find the minimum number of conference rooms required. Input: [[0, 30],[5, 10],[15, 20]] Output: 2 Solution 2020-09-20 Notes: 核心是用 存 ending time to a min-heap, 用starting time与heap比较","tags":["leetcode","heap"],"title":"253 Meeting Rooms II","uri":"https://foxisawesome.github.io/posts/253-meeting-rooms-ii/","year":"2020"},{"content":"LC 46 Permutations   Given a collection of distinct integers, return all possible permutations.\nInput: [1,2,3] Output: [ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]   Solution 2020-09-20 Notes:  Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums[i+1:]以避免dups。 经典的DFS，backtracking题。LC 47 保证distinct的条件是 sort + if i == n-1 or nums[i]!=nums[i+1]: 另外容易出错的地方是 append path时要使用 deep copy ans.append(path[:])，shallow copy不能正确返回。  class Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: if not nums: return [] ans = [] n = len(nums) self.backtracking(nums,ans,[]) return ans def backtracking(self, nums, ans, path): n = len(nums) if n == 0: ans.append(path[:]) return for i in range(n): path.append(nums[i]) self.backtracking(nums[:i]+nums[i+1:], ans, path) path.pop() # Time O(NlogN) # Space O(N)  ","id":70,"section":"posts","summary":"LC 46 Permutations Given a collection of distinct integers, return all possible permutations. Input: [1,2,3] Output: [ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Solution 2020-09-20 Notes: Permutation 一般是传入nums[:i]+nums[i+1:] ，而combination的题一般是传入nums","tags":["leetcode","DFS"],"title":"46 Permutations","uri":"https://foxisawesome.github.io/posts/46-permutations/","year":"2020"},{"content":"LC 994 Rotting Oranges   In a given grid, each cell can have one of three values:\n the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange.  Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.\n Solution 2020-09-20 Notes:  这题只能用BFS，因为是每分钟只有相邻的橘子被腐败。 这题先得走一遍grid把 =2的cell都加到queue里去，然后在走BFS，不能边走gird边做BFS。因为多处的rotten orange会同时开始腐败周围的橘子。 其他都是BFS的模版。  class Solution: def orangesRotting(self, grid: List[List[int]]) -\u0026gt; int: directions = [[0,1],[1,0],[0,-1],[-1,0]] queue = [] nr = len(grid) nc = len(grid[0]) t = 0 for i in range(nr): for j in range(nc): if grid[i][j] == 2: queue.append((i,j,t)) while queue: n = len(queue) for q in range(n): p = queue.pop(0) i, j, t = p[0], p[1], p[2] for d in directions: x, y = i+d[0], j+d[1] if 0\u0026lt;=x\u0026lt;nr and 0\u0026lt;=y\u0026lt;nc and grid[x][y]==1: queue.append((x,y,t+1)) grid[x][y] = 2 for i in range(nr): for j in range(nc): if grid[i][j] == 1: return -1 return t # Time O(N) # Space O(N)  ","id":71,"section":"posts","summary":"LC 994 Rotting Oranges In a given grid, each cell can have one of three values: the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this","tags":["leetcode","BFS"],"title":"994 Rotting Oranges","uri":"https://foxisawesome.github.io/posts/994-rotting-oranges/","year":"2020"},{"content":"LC 221 Maximal Square   Given a 2D binary matrix filled with 0\u0026rsquo;s and 1\u0026rsquo;s, find the largest square containing only 1\u0026rsquo;s and return its area.\nInput: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4   Solution 2020-09-20 Notes:    dp[i][j]: represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix. dp[0][j] = matrix[0][j] dp[i][0] = matrix[i][0] dp[i][j] = if matrix[i][j]==0 then 0, else min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1    class Solution: def maximalSquare(self, matrix: List[List[str]]) -\u0026gt; int: if not matrix: return 0 nrow = len(matrix) ncol = len(matrix[0]) dp = [ [0]*ncol for i in range(nrow)] for i in range(ncol): dp[0][i] = int(matrix[0][i]) for i in range(nrow): dp[i][0] = int(matrix[i][0]) for i in range(1,nrow): for j in range(1,ncol): if matrix[i][j]=='0': dp[i][j] = 0 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 return max(map(max, dp)) ** 2 # Time O() # Space O()  ","id":72,"section":"posts","summary":"LC 221 Maximal Square   Given a 2D binary matrix filled with 0\u0026rsquo;s and 1\u0026rsquo;s, find the largest square containing only 1\u0026rsquo;s and return its area.\nInput: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4   Solution 2020-09-20 Notes:    dp[i][j]: represents the side length of the maximum square whose bottom right corner is the cell with index (i,j) in the original matrix.","tags":["leetcode","dp"],"title":"221 Maximal Square","uri":"https://foxisawesome.github.io/posts/221-maximal-square/","year":"2020"},{"content":"LC 7 Reverse Integer   Given a 32-bit signed integer, reverse digits of an integer.\nInput: -120 Output: -21   Solution 2020-09-20 Notes:  很简单的题，要记得overflow的处理。  class Solution: def reverse(self, x: int) -\u0026gt; int: if x == 0: return x sign = -1 if x \u0026lt; 0 else 1 x = abs(x) ans = 0 while x \u0026gt; 0: x, m = divmod(x,10) ans = ans*10 + m ans = ans * sign if ans not in range(-2**31,2**31-1): return 0 return ans # Time O(N) # Space O(1)  ","id":73,"section":"posts","summary":"LC 7 Reverse Integer Given a 32-bit signed integer, reverse digits of an integer. Input: -120 Output: -21 Solution 2020-09-20 Notes: 很简单的题，要记得overflow的处理。 class Solution: def reverse(self, x: int) -\u0026gt; int: if x == 0: return x sign = -1 if x \u0026lt; 0 else 1 x = abs(x) ans =","tags":["leetcode"],"title":"7 Reverse Integer","uri":"https://foxisawesome.github.io/posts/7-reverse-integer/","year":"2020"},{"content":"LC 394 Decode String   Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nInput: s = \u0026quot;3[a2[c]]\u0026quot; Output: \u0026quot;accaccacc\u0026quot;   Solution 2020-09-20 Notes:  比较简单的一道stack的题。类似于calculator，遇到 [,] 就将前面的string还有数字临时存入stack。  class Solution: def decodeString(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; stack = [] d = 0 ans = \u0026quot;\u0026quot; for i in s: if i.isdigit(): d = d*10 + int(i) elif i.isalpha(): ans += i elif i == '[': stack.append(d) stack.append(ans) ans = '' d = 0 elif i == ']': ans = stack.pop() + ans*stack.pop() return ans # Time O(N) # Space O(1)  ","id":74,"section":"posts","summary":"LC 394 Decode String Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. Input: s = \u0026quot;3[a2[c]]\u0026quot; Output: \u0026quot;accaccacc\u0026quot; Solution 2020-09-20 Notes: 比较简单的一道stack的题。类似于cal","tags":["leetcode","stack"],"title":"394 Decode String","uri":"https://foxisawesome.github.io/posts/394-decode-string/","year":"2020"},{"content":"LC 31 Next Permutation   Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\nThe replacement must be in-place and use only constant extra memory.\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\n1,2,3` → `1,3,2` `3,2,1` → `1,2,3` `1,1,5` → `1,5,1   Solution 2020-09-20 Notes: 很多小技巧的小题。大致的algo是这样的，需要 two-pass：\n 先找到从右往左第一个递减序列，1321 中的 321就是，标记 i=0。 然后在递减序列中找到第一个 i=0 大的数。2就是，标记 j=2。 swap nums[i], nums[j], 此时2311。 再翻转一下311 为 113.就是next greater permutation。和单调堆的思路很像。  class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: n = len(nums) i = n-2 while i \u0026gt;= 0 and nums[i+1] \u0026lt;= nums[i]: i -= 1 if i \u0026lt; 0: nums[:] = nums[::-1] return j = n-1 while j \u0026gt;= 0 and nums[i] \u0026gt;= nums[j]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i+1:] = nums[i+1:][::-1] return # Time O(N) # Space O(1)  ","id":75,"section":"posts","summary":"LC 31 Next Permutation Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3` →","tags":["leetcode","array"],"title":"31 Next Permutation","uri":"https://foxisawesome.github.io/posts/31-next-permutation/","year":"2020"},{"content":"LC 983 Minimum Cost for Tickets    Solution 2020-09-19 Notes:    # Time O() # Space O()  ","id":76,"section":"posts","summary":"LC 983 Minimum Cost for Tickets    Solution 2020-09-19 Notes:    # Time O() # Space O()  ","tags":["leetcode","dp"],"title":"983 Minimum Cost for Tickets","uri":"https://foxisawesome.github.io/posts/983-minimum-cost-for-tickets/","year":"2020"},{"content":"LC 322 Coin Change   You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nInput: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1   Solution 2020-09-19 Notes:  其实这题被 labuladong 解决的特别简单，只要一维dp。看每个amount能在 dp[amount-coin]上加一就好了。 完美。  class Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # dp[i]: min coins to get i amount dp = [float('inf')] * (amount + 1) dp[0] = 0 for i in range(amount+1): for coin in coins: if i - coin \u0026gt;= 0 and dp[i-coin] != -1: dp[i] = min(dp[i], dp[i - coin]+1) return -1 if dp[amount] == float('inf') else dp[amount] # Time O(NM) # Space O(N)  ","id":77,"section":"posts","summary":"LC 322 Coin Change You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5","tags":["leetcode","dp"],"title":"322 Coin Change","uri":"https://foxisawesome.github.io/posts/322-coin-change/","year":"2020"},{"content":"LC 692 Top K Frequent Words   Given a non-empty list of words, return the k most frequent elements.\nYour answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.\n Solution 2020-09-19 Notes:   重要的来了，一般，我们认为找出k个最大最小的问题都是一个使用堆来做的。这个题中，学习了python的堆的用法。\n  heapq.heapify(heap)能在线性时间内，把一个列表转成堆。\n  heapq.heappop(heap)能直接弹出堆的堆顶。\n  heappush(heap,5)向堆中添加元素。\n  注意，heap是个list，哪怕使用了上述函数之后，这个仍然是list.\n  python中的堆默认是小根堆，如果想使用大根堆，在添加元素的时候使用负号即可。\n  class Solution: def topKFrequent(self, words: List[str], k: int) -\u0026gt; List[str]: count = collections.Counter(words) heap = [(-freq, word) for word, freq in count.items()] heapq.heapify(heap) return [heapq.heappop(heap)[1] for _ in range(k)] # Time O(N) # Space O(N)  ","id":78,"section":"posts","summary":"LC 692 Top K Frequent Words Given a non-empty list of words, return the k most frequent elements. Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first. Solution 2020-09-19 Notes: 重要的来了，一般，我们认为找出k个最大最小","tags":["leetcode","sort","hashtable","heap"],"title":"692 Top K Frequent Words","uri":"https://foxisawesome.github.io/posts/692-top-k-frequent-words/","year":"2020"},{"content":"LC 973 K Closest Points to Origin   We have a list of points on the plane. Find the K closest points to the origin (0, 0).\nInput: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u0026lt; sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].   Solution 2020-09-19 Notes:  Sort by Euclidean distance. O(nlogN) 用quicksort 可以减到 O(N). 还得再学习下quicksort的精妙。  class Solution: def kClosest(self, points: List[List[int]], K: int) -\u0026gt; List[List[int]]: points.sort(key = lambda x: x[0]**2+x[1]**2) return points[:K] # Time O(NlogN) # Space O(1)  ","id":79,"section":"posts","summary":"LC 973 K Closest Points to Origin We have a list of points on the plane. Find the K closest points to the origin (0, 0). Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) \u0026lt; sqrt(10), (-2, 2) is closer to the origin. We only want","tags":["leetcode","sort"],"title":"973 K Closest Points to Origin","uri":"https://foxisawesome.github.io/posts/973-k-closest-points-to-origin/","year":"2020"},{"content":"LC 20 Valid Parentheses   Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\nAn input string is valid if:\n Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.   Solution 2020-09-19 Notes:  好经典的题。 思路如解。  class Solution: def isValid(self, s: str) -\u0026gt; bool: d = {'(': ')', '[':']', '{':'}'} stack = [] for i in s: if i in d: stack.append(d[i]) elif len(stack)==0 or i != stack[-1]: return False elif i == stack[-1]: stack.pop() return len(stack) == 0 # Time O(N) # Space O(N)  ","id":80,"section":"posts","summary":"LC 20 Valid Parentheses Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Solution 2020-09-19 Notes: 好经典的题。 思路如解。 class Solution: def isValid(self,","tags":["leetcode","hashtable"],"title":"20 Valid Parentheses","uri":"https://foxisawesome.github.io/posts/20-valid-parentheses/","year":"2020"},{"content":"LC 953 Verifying an Alien Dictionary   In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.\nInput: words = [\u0026quot;word\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;row\u0026quot;], order = \u0026quot;worldabcefghijkmnpqstuvxyz\u0026quot; Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] \u0026gt; words[1], hence the sequence is unsorted.   Solution 2020-09-19 Notes:  algo：从第一个word开始往后扫，遇到false的case立马return False。 遇到相同符合order的case 就update下idx，然后remove这个word。一定要先update下 index 否则会出错。 遇到字母顺序完全一致的就保留到下一轮。 当第一个word扫完依然还有，remove掉这个word，从剩余的words重新再来一次。 看答案用了hash table，感觉time complexity也没有更优。  class Solution: def isAlienSorted(self, words: List[str], order: str) -\u0026gt; bool: stack = [] order_ = list(order) start = 0 while words: for i in range(start,len(words[0])): idx = order_.index(words[0][i]) for word in words[1:]: if i \u0026lt; len(word): if idx \u0026gt; order_.index(word[i]): return False elif idx \u0026lt; order_.index(word[i]): idx = order_.index(word[i]) words.remove(word) else: return False words.remove(words[0]) start = i+1 return True # Time O(NM): N: words length, M: max length of a signle word # Space O(1)  ","id":81,"section":"posts","summary":"LC 953 Verifying an Alien Dictionary In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language. Input: words = [\u0026quot;word\u0026quot;,\u0026quot;world\u0026quot;,\u0026quot;row\u0026quot;],","tags":["leetcode","array","hashtable"],"title":"953 Verifying an Alien Dictionary","uri":"https://foxisawesome.github.io/posts/953-verifying-an-alien-dictionary/","year":"2020"},{"content":"LC 70 Climbing Stairs   You are climbing a stair case. It takes n steps to reach to the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n Solution 2020-09-15 Notes:  最经典的dp题了。dp[i] = dp[i-1] + dp[i-2], 主要是dp[i] 和 dp[i-1]直接差了一步，多走一步但毅然还是那条path。同理 dp[i] 与 dp[i-2]差了两步，但依然是同一条path，所以是之和。还可以继续优化sapce to O(1). 与 LC 91 一样。  class Solution: def climbStairs(self, n: int) -\u0026gt; int: dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 for i in range(2,n+1): dp[i] = dp[i-1] + dp[i-2] return dp[n] # Time O(N) # Space O(N)  recursion with memo\nclass Solution: def __init__(self): self.memo = dict() self.memo[0] = 1 self.memo[1] = 1 def climbStairs(self, n: int) -\u0026gt; int: if n in self.memo: return self.memo[n] self.memo[n] = self.climbStairs(n-1) + self.climbStairs(n-2) return self.memo[n] # Time O(N) # Space O(N)  ","id":82,"section":"posts","summary":"LC 70 Climbing Stairs You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Solution 2020-09-15 Notes: 最经典的dp题了。dp[i] = dp[i-1] + dp[i-2], 主要是dp[i] 和","tags":["leetcode","dp"],"title":"70 Climbing Stairs","uri":"https://foxisawesome.github.io/posts/70-climbing-stairs/","year":"2020"},{"content":"LC 91 Decode Ways   A message containing letters from A-Z is being encoded to numbers using the following mapping:\n'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26  Given a non-empty string containing only digits, determine the total number of ways to decode it.\nInput: \u0026ldquo;226\u0026rdquo; Output: 3 Explanation: It could be decoded as \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), or \u0026ldquo;BBF\u0026rdquo; (2 2 6).\n Solution 2020-09-15 Notes:  开始用了backtracking 复杂度太高不能过。 只能用dp，思想和 LC 70完全一样： dp[i]: ways of decode string s[:i]. dp[i] = dp[i-1] if s[i] != '0' + dp[i-2] if '10' \u0026lt;= s[i-2:i] \u0026lt;= '26' dp[0] = 1这个起始条件要注意，和stair一样。  class Solution: def numDecodings(self, s: str) -\u0026gt; int: if not s: return 0 n = len(s) dp = [0] * (n+1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2,n+1): path_1digit = dp[i-1] if s[i-1]!='0' else 0 path_2digit = dp[i-2] if '10' \u0026lt;= s[i-2:i] \u0026lt;= '26' else 0 dp[i] = path_1digit + path_2digit return dp[n] # Time O(N) # Space O(N)  ","id":83,"section":"posts","summary":"LC 91 Decode Ways A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Input: \u0026ldquo;226\u0026rdquo; Output: 3 Explanation: It could be decoded as \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), or \u0026ldquo;BBF\u0026rdquo; (2 2 6). Solution 2020-09-15 Notes: 开","tags":["leetcode","dp"],"title":"91 Decode Ways","uri":"https://foxisawesome.github.io/posts/91-decode-ways/","year":"2020"},{"content":"LC 238 Product of Array Except Self   Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\nInput: [1,2,3,4] Output: [24,12,8,6]   Solution 2020-09-15 Notes:  3-pass, space O(N) solution. L[i] = cumulative product of nums[:i], R[i] = cumulative product of nums[:i:-1]  class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) L = [1]*n R = [1]*n ans = [] for i in range(1, n): L[i] = L[i-1] * nums[i-1] for j in range(n-2,-1,-1): R[j] = R[j+1] * nums[j+1] for k in range(n): ans.append(L[k]*R[k]) return ans # Time O(N) # Space O(N)   optimal solution, 2-pass, space O(N). 和楼上的思想一致。 先从左到右算一遍up to 前一位的连乘积，再从右到左算一遍连乘积。ans 不算入 space complexity。  class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) ans = [] prod = 1 for i in range(n): ans.append(prod) prod *= nums[i] prod = 1 for j in range(n-1,-1,-1): ans[j] *= prod prod *= nums[j] return ans  ","id":84,"section":"posts","summary":"LC 238 Product of Array Except Self Given an array nums of n integers where n \u0026gt; 1, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Input: [1,2,3,4] Output: [24,12,8,6] Solution 2020-09-15 Notes: 3-pass, space O(N) solution. L[i] = cumulative product of nums[:i], R[i] = cumulative product of nums[:i:-1] class Solution: def productExceptSelf(self, nums: List[int]) -\u0026gt; List[int]: n","tags":["leetcode","array"],"title":"238 Product of Array Except Self","uri":"https://foxisawesome.github.io/posts/238-product-of-array-except-self/","year":"2020"},{"content":"LC 56 Merge Intervals   Given a collection of intervals, merge all overlapping intervals.\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].   Solution 2020-09-15 Notes:  先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。  class Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: if not intervals: return [] intervals.sort(key = lambda x: (x[0],x[1])) ans = [intervals[0]] for i in intervals[1:]: if i[0] \u0026lt;= ans[-1][1]: if i[1] \u0026gt;= ans[-1][1]: ans[-1][1] = i[1] else: ans.append(i) return ans # Time O(NlogN) # Space O(N)  ","id":85,"section":"posts","summary":"LC 56 Merge Intervals Given a collection of intervals, merge all overlapping intervals. Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Solution 2020-09-15 Notes: 先sort一遍 by x[0], x[1] 比较 ans[-1][1] 与 x[0]的关系， 很简单。 class Solution: def merge(self, intervals: List[List[int]]) -\u0026gt; List[List[int]]: if not intervals:","tags":["leetcode","sort"],"title":"56 Merge Intervals","uri":"https://foxisawesome.github.io/posts/56-merge-intervals/","year":"2020"},{"content":"LC 23 Merge K Sorted Lists   You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\nInput: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] merging them into one sorted list: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6   Solution 2020-09-14 Notes:  最简单暴力，最挫的方法。  class Solution: def mergeKLists_1(self, lists: List[ListNode]) -\u0026gt; ListNode: nodes = [] head = cur = ListNode(0) for l in lists: while l: nodes.append(l.val) l = l.next nodes.sort() for i in nodes: cur.next = ListNode(i) cur = cur.next return head.next # Time O(NlogN) # Space O(N)   merge sort方法：要记一下这种merge sort的写法  class Solution: def mergeKLists(self, lists: List[ListNode]) -\u0026gt; ListNode: if not lists: return n = len(lists) interval = 1 head = cur = ListNode(0) while interval \u0026lt; n: for i in range(0, n-interval, interval*2): lists[i] = self.merge2ls(lists[i],lists[i+interval]) interval *= 2 return lists[0] def merge2ls(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = p = ListNode(0) while l1 and l2: if l1.val \u0026gt; l2.val: p.next = l2 l2 = l2.next else: p.next = l1 l1 = l1.next p = p.next l = l1 if l1 else l2 p.next = l return head.next # Time O(NlogK): N:# of nodes, K:# of list # Space O(1)   Heapq 方法: python 3 中无法比较tuple中的ListNode，于是只要是node.val 相等，就比较tuple的第二位，which is a proxy: x to work around this issue.  class Solution(object): def mergeKLists(self, lists): import heapq result = ListNode(-1) cur = result p = list() x = 0 for i in lists: while i: heapq.heappush(p, (i.val, x, i)) i = i.next x += 1 while p: cur.next = heapq.heappop(p)[2] cur = cur.next return result.next  ","id":86,"section":"posts","summary":"LC 23 Merge K Sorted Lists You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it. Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-\u0026gt;4-\u0026gt;5, 1-\u0026gt;3-\u0026gt;4, 2-\u0026gt;6 ] merging them into one sorted list: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 Solution 2020-09-14 Notes: 最简单暴力，最挫的方法。","tags":["leetcode","linkedlist"],"title":"23 Merge K Sorted Lists","uri":"https://foxisawesome.github.io/posts/23-merge-k-sorted-lists/","year":"2020"},{"content":"LC 3 Longest Substring Without Repeating Characters   Given a string s, find the length of the longest substring without repeating characters.\n Solution 2020-09-14 Notes:\n 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding window的 template 参见 labuladong 的文章，归纳的巨好。其实一个月前刚学会，今天又忘了。。。这个故事告诉我们，按主题刷完 按频率刷看啥题都brute force一样做。。。三刷得搞出来！  class Solution: def lengthOfLongestSubstring(self, s: str) -\u0026gt; int: if not s: return 0 l, r, ans = 0, 0, 0 n = len(s) window = dict() while r \u0026lt; n: tail = s[r] window[tail] = window.get(tail,0)+1 r += 1 while window[tail] \u0026gt; 1: head = s[l] window[head] = window.get(head, 0) - 1 l += 1 ans = max(ans, r-l) return ans # Time O(N) # Space O(N)  ","id":87,"section":"posts","summary":"LC 3 Longest Substring Without Repeating Characters Given a string s, find the length of the longest substring without repeating characters. Solution 2020-09-14 Notes: 经典题，要类似 LC5 longest palindrome 那么做，就得O(N^2) ，不能通过。应该用sliding window one pass 完成。 sliding w","tags":["leetcode","sliding_window"],"title":"3 Longest Substring Without Repeating Characters","uri":"https://foxisawesome.github.io/posts/3-longest-substring-without-repeating-characters/","year":"2020"},{"content":"LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence\u0026rsquo;s length in s. You may assume that the maximum length of s is 1000.\n Solution 2020-09-14 Notes:\n   class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] != s[j]: dp[i][j] = max(dp[i-1][j], dp[i][j+1]) # init: dp[i][i] = 1 dp = [[0]*n for _ in range(n)] for i in range(n,0,-1): dp[i-1][i-1] = 1 for j in range(i-1,n-1): if s[i-1] == s[j+1]: dp[i-1][j+1] = dp[i][j] + 2 else: dp[i-1][j+1] = max(dp[i-1][j], dp[i][j+1]) return dp[0][n-1] # Time O(N^2) # Space O(N^2)  ","id":88,"section":"posts","summary":"LC 516 Longest Palindromic Subsequence   Given a string s, find the longest palindromic subsequence\u0026rsquo;s length in s. You may assume that the maximum length of s is 1000.\n Solution 2020-09-14 Notes:\n   class Solution: def longestPalindromeSubseq(self, s: str) -\u0026gt; int: n = len(s) # dp[i][j]: max palindromic length of s[i:j+1] # assume: dp[i+1][j-1] has max length # then: if s[i]==s[j]: dp[i][j] = dp[i+1][j-1]+2 # if s[i] !","tags":["leetcode"],"title":"516 Longest Palindromic Subsequence","uri":"https://foxisawesome.github.io/posts/516-longest-palindromic-subsequence/","year":"2020"},{"content":"LC 5 Longest Palindromic Substring   Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\nInput: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer.   Solution 2020-09-14 Notes:\n 本质是dp，与LC 516相同  class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; n = len(s) for i in range(n): for j in range(n-1,i-1,-1): if j-i+1 \u0026lt; len(ans): break elif s[i:j+1] == s[i:j+1][::-1]: ans = s[i:j+1] return ans # Time O(N^2) # Space O(1)  ","id":89,"section":"posts","summary":"LC 5 Longest Palindromic Substring Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Input: \u0026quot;babad\u0026quot; Output: \u0026quot;bab\u0026quot; Note: \u0026quot;aba\u0026quot; is also a valid answer. Solution 2020-09-14 Notes: 本质是dp，与LC 516相同 class Solution: def longestPalindrome(self, s: str) -\u0026gt; str: if not s: return \u0026quot;\u0026quot; n =","tags":["leetcode"],"title":"5 Longest Palindromic Substring","uri":"https://foxisawesome.github.io/posts/5-longest-palindromic-substring/","year":"2020"},{"content":"LC 937 Reorder Data in Log Files   You have an array of logs. Each log is a space delimited string of words.\nFor each log, the first word in each log is an alphanumeric identifier. Then, either:\n Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits.  We will call these two varieties of logs letter-logs and digit-logs. It is guaranteed that each log has at least one word after its identifier.\nReorder the logs so that all of the letter-logs come before any digit-log. The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties. The digit-logs should be put in their original order.\nReturn the final order of the logs.\n Solution 2020-09-14 Notes:\n 题目写的特别复杂，估计主要考查string的各种method。 sort的 lambda function还得多练练  class Solution: def reorderLogFiles(self, logs: List[str]) -\u0026gt; List[str]: if not logs: return [] digit = [] letter = [] for log in logs: l = log.split(' ') if l[1].isdigit(): digit.append(log) else: letter.append(l) letter.sort(key=lambda x: (x[1:], x[0])) l = [ ' '.join(i) for i in letter ] return l + digit # Time O(MNlogN) # Space O(N)  ","id":90,"section":"posts","summary":"LC 937 Reorder Data in Log Files You have an array of logs. Each log is a space delimited string of words. For each log, the first word in each log is an alphanumeric identifier. Then, either: Each word after the identifier will consist only of lowercase letters, or; Each word after the identifier will consist only of digits. We will call these two varieties of logs letter-logs and digit-logs.","tags":["leetcode","string"],"title":"937 Reorder Data in Log Files","uri":"https://foxisawesome.github.io/posts/937-reorder-data-in-log-files/","year":"2020"},{"content":"LC 53 Maximum Subarray   Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6.   Solution 2020-09-13 Notes:\n 这是一道看似很简单的dp啊！首先我想到的是先算一遍cumulative sum，再double loop做一遍。$\\mathcal{O}(N^2)$. 然后看了答案惊叹哇好天才的做法。好受打击。 最后看了 负雪明烛 才明白原来这是道 dp。原来答案是优化了space后的dp。怪不得高级。 dp[i] = max(nums[i], dp[i-1]+nums[i])  class Solution: def maxSubArray_dp(self, nums: List[int]) -\u0026gt; int: pre_sum, dp = nums[0], nums for i in range(1,len(nums)): dp[i] = max(nums[i], dp[i-1]+nums[i]) return max(dp) def maxSubArray(self, nums: List[int]) -\u0026gt; int: pre_sum, gb_max = nums[0], nums[0] for i in nums[1:]: pre_sum = max(i, i+pre_sum) gb_max = max(gb_max, pre_sum) return gb_max # Time O(N) # Space O(N)  ","id":91,"section":"posts","summary":"LC 53 Maximum Subarray Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Solution 2020-09-13 Notes: 这是","tags":["leetcode","dp"],"title":"53 Maximum Subarray","uri":"https://foxisawesome.github.io/posts/53-maximum-subarray/","year":"2020"},{"content":"LC 146 LRU Cache   Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\nThe cache is initialized with a positive capacity.\nFollow up: Could you do both operations in O(1) time complexity?\n Solution 2020-09-13 Notes:\n 抄了一遍答案。多看几遍。  class ListNode: def __init__(self, key, value): self.key = key self.value = value self.prev = self self.next = self class LRUCache: def __init__(self, capacity: int): self.dict = dict() self.cap = capacity self.size = 0 self.root = ListNode(0, 0) def get(self, key: int) -\u0026gt; int: if key in self.dict: node = self.dict[key] self.removeFromList(node) self.insertIntoHead(node) return node.value else: return -1 def put(self, key: int, value: int) -\u0026gt; None: if key in self.dict: node = self.dict[key] self.removeFromList(node) self.insertIntoHead(node) node.value = value else: if self.size == self.cap: self.removeFromTail() self.size -= 1 node = ListNode(key, value) self.insertIntoHead(node) self.dict[key] = node self.size += 1 def removeFromList(self, node): if node == self.root: return prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node node.prev = node.next = None def insertIntoHead(self, node): head_node = self.root.next head_node.prev = node node.prev = self.root self.root.next = node node.next = head_node def removeFromTail(self): if self.size == 0: return tail_node = self.root.prev del self.dict[tail_node.key] self.removeFromList(tail_node) # Your LRUCache object will be instantiated and called as such: # obj = LRUCache(capacity) # param_1 = obj.get(key) # obj.put(key,value)  ","id":92,"section":"posts","summary":"LC 146 LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should","tags":["leetcode","linkedlist"],"title":"146 LRU Cache","uri":"https://foxisawesome.github.io/posts/146-lru-cache/","year":"2020"},{"content":"LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nInput: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:\n    ","id":93,"section":"posts","summary":"LC 99 Recover Binary Search Tree   Two elements of a binary search tree (BST) are swapped by mistake.\nRecover the tree without changing its structure.\nInput: [1,3,null,null,2] Output: [3,1,null,null,2]   Solution 2020-09-13 Notes:\n    ","tags":["leetcode","tree"],"title":"99 Recover Binary Search Tree","uri":"https://foxisawesome.github.io/posts/99-recover-binary-search-tree/","year":"2020"},{"content":"LC 92 Reverse Linked List ii   Reverse a linked list from position m to n. Do it in one-pass.\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL   Solution 2020-09-13 Notes:\n 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的utility function才测试方便。做出来还是很开心的！ algo:  准备一个 head 的copy， curr。初始时，curr得比head晚一步，否值 m==1时会有问题。 开始先跳过m步，此时head时reverse link的起点，curr在head之前一步 line#18 reverse 步骤完全和LC 206一致 完成reverse后，curr 要point到receved list的头 line#26 然后走完一遍curr，最后point回剩下的head。    # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseBetween(self, head: ListNode, m: int, n: int) -\u0026gt; ListNode: if not head: return curr = ListNode(0) curr.next = head dummy = curr c = 1 while head and c \u0026lt; m: curr = curr.next head = head.next c += 1 # now head at the starting point of reverse, curr.next = head pre = None while head and c \u0026lt; n+1: _next = head.next head.next = pre pre = head head = _next c += 1 # now reverse finished, head of reversed list is pre curr.next = pre while curr and curr.next: curr = curr.next curr.next = head return dummy.next # Time O(N) # Space O(1)  ","id":94,"section":"posts","summary":"LC 92 Reverse Linked List ii Reverse a linked list from position m to n. Do it in one-pass. Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 Output: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL Solution 2020-09-13 Notes: 搞了一个多小时终于做出来了，主要Linked list 不好测试，用了自己写的util","tags":["leetcode","linkedlist"],"title":"92 Reverse Linked List ii","uri":"https://foxisawesome.github.io/posts/92-reverse-linked-list-ii/","year":"2020"},{"content":"LC 102 Binary Tree Level Order Traversal   Given a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7  return [[3],[9,20],[15,7]]\n Solution 2020-09-13 Notes:\n  与LC 109 一样\nRecursion 解法：\n  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.postOrder(root,0) out = [val for i, val in self.d.items()] return out def postOrder(self, root, h): if not root: return h += 1 self.d[h].append(root.val) self.postOrder(root.left,h) self.postOrder(root.right,h) return # Time O(N) # Space O(H)  iteration:\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrder(self, root: TreeNode) -\u0026gt; List[List[int]]: ans = [] if not root: return ans queue = [root] while queue: sub = [] for i in range(len(queue)): node = queue.pop(0) sub.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) ans.append(sub) return ans # Time O(N) # Space O(N)  ","id":95,"section":"posts","summary":"LC 102 Binary Tree Level Order Traversal Given a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (ie, from left to right, level by level). Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 return [[3],[9,20],[15,7]] Solution 2020-09-13 Notes: 与LC 109 一样 Recursion 解法： # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0,","tags":["leetcode","tree"],"title":"102 Binary Tree Level Order Traversal","uri":"https://foxisawesome.github.io/posts/102-binary-tree-level-order-traversal/","year":"2020"},{"content":"LC 199 Binary Tree Right Side View   Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample:\nInput: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 \u0026lt;--- / \\ 2 3 \u0026lt;--- \\ \\ 5 4 \u0026lt;---   Solution 2020-09-13 Notes:  一刷虽然做出来了 但是在输出的时候总感觉很冗余。algo就是post-order 走一遍，每一层都用一个dict记录下来，然后取每层的最后一个值。 与LC 102 一样  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def rightSideView(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.postOrder(root,0) out = [0] * max([i for i,val in self.d.items()]) for k, val in self.d.items(): out[k-1] = val[-1] return out def postOrder(self, root, h): if not root: return h += 1 self.postOrder(root.left,h) self.postOrder(root.right,h) self.d[h].append(root.val) return # Time O(N) # Space O(H)  结果看了下负雪明烛，只要pre-order用dict记录root.val就能保证字典里的顺序是in-order的。\nclass Solution: def rightSideView(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] out = [] self.d = collections.defaultdict(list) self.preOrder(root,0) out = [val[-1] for i, val in self.d.items()] return out def preOrder(self, root, h): if not root: return h += 1 self.d[h].append(root.val) self.preOrder(root.left,h) self.preOrder(root.right,h) return # Time O(N) # Space O(H)  ","id":96,"section":"posts","summary":"LC 199 Binary Tree Right Side View Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 \u0026lt;--- / \\ 2 3 \u0026lt;--- \\ \\ 5 4 \u0026lt;--- Solution 2020-09-13 Notes: 一刷虽然做出来了 但是在输出","tags":["leetcode","tree"],"title":"199 Binary Tree Right Side View","uri":"https://foxisawesome.github.io/posts/199-binary-tree-right-side-view/","year":"2020"},{"content":"LC 987 Vertical Order Traversal of a Binary Tree   Given a binary tree, return the vertical order traversal of its nodes values.\nFor each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).\nRunning a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).\nIf two nodes have the same position, then the value of the node that is reported first is the value that is smaller.\nReturn an list of non-empty reports in order of X coordinate. Every report will have a list of values of nodes.\nInput: [3,9,20,null,null,15,7] Output: [[9],[3,15],[20],[7]] Explanation: Without loss of generality, we can assume the root node is at position (0, 0): Then, the node with value 9 occurs at position (-1, -1); The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2); The node with value 20 occurs at position (1, -1); The node with value 7 occurs at position (2, -2).   Solution 2020-09-09 Notes:  这题最难的部分不是recursion， 而是需要经过三层sort得到题目要求的排序结果。。。题目要求：首先需要根据 x坐标排序，然后根据y坐标排序，最后若y相同再从小到大排序。。。于是line13-20都在茫茫的排序中。。。排了我美好Sunday的一个小时。。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def verticalTraversal(self, root: TreeNode) -\u0026gt; List[List[int]]: if not root: return None ans = [] d = collections.defaultdict(list) self.preOrder(root,d,0,0) temp = [val for i, val in sorted(d.items(), key=lambda item: item[0])] for i in temp: t = [] i = sorted(i, key = lambda x: (x[0], x[1])) for j in i: t.append(j[1]) ans.append(t) return ans def preOrder(self, root, d, x, y): if not root: return None d[x].append((y,root.val)) self.preOrder(root.left, d, x-1, y+1) self.preOrder(root.right,d, x+1, y+1) return # Time O(N) # Space O(H)  ","id":97,"section":"posts","summary":"LC 987 Vertical Order Traversal of a Binary Tree Given a binary tree, return the vertical order traversal of its nodes values. For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1). Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes","tags":["leetcode","tree","sort"],"title":"987 Vertical Order Traversal of a Binary Tree","uri":"https://foxisawesome.github.io/posts/987-vertical-order-traversal-of-a-binary-tree/","year":"2020"},{"content":"LC 501 Find Mode in Binary Search Tree   Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.\nAssume a BST is defined as follows:\n  The left subtree of a node contains only nodes with keys less than or equal to the node\u0026rsquo;s key.\n  The right subtree of a node contains only nodes with keys greater than or equal to the node\u0026rsquo;s key.\n  Both the left and right subtrees must also be binary search trees.\nexample: Given BST [1,null,2,2],\n   1 \\ 2 / 2  return [2].\n Solution 2020-09-12 Notes:  BST肯定用in-order, space O(N)是就用个counter dict来记录mode。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def findMode(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] self.count = collections.Counter() self.inorder(root) ans = [] freq = self.count.most_common()[0][1] for k, val in self.count.items(): if val == freq: ans.append(k) return ans def inorder(self, root): if not root: return self.inorder(root.left) self.count[root.val] += 1 self.inorder(root.right) # Time O(N) # Space O(N)  Space O(1) 的解，走两次in-order。一次计算freq，两一次\n","id":98,"section":"posts","summary":"LC 501 Find Mode in Binary Search Tree Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST. Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than or equal to the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than or equal","tags":["leetcode","tree"],"title":"501 Find Mode in Binary Search Tree","uri":"https://foxisawesome.github.io/posts/501-find-mode-in-binary-search-tree/","year":"2020"},{"content":"LC 621 Task Scheduler   Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.\nHowever, there is a non-negative integer n that represents the cooldown period between two same tasks (the same letter in the array), that is that there must be at least n units of time between any two same tasks.\nReturn the least number of units of times that the CPU will take to finish all the given tasks.\nInput: tasks = [\u0026quot;A\u0026quot;,\u0026quot;A\u0026quot;,\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;B\u0026quot;], n = 2 Output: 8 Explanation: A -\u0026gt; B -\u0026gt; idle -\u0026gt; A -\u0026gt; B -\u0026gt; idle -\u0026gt; A -\u0026gt; B There is at least 2 units of time between any two same tasks.   Solution 2020-09-12 Notes:\n 有个计算公式：$(\\text{most_freq}-1)*(n+1)+\\text{top_tasks}$ 因为最优就是尽可能利用间隔 n 的idle 时间，把他们填满了还有多余的tasks那就是len(tasks)了。所以频率最高的字母先排好，然后往idle时间里插入余下的不同种tasks。有$(\\text{most_freq}-1)$间隙，每个间隙duration是（n+1）。最后加上所有最高频率出现的distinct tasks. 最后要取max().  class Solution: def leastInterval(self, tasks: List[str], n: int) -\u0026gt; int: if not tasks: return 0 count = collections.Counter(tasks) most_freq = count.most_common()[0][1] top_tasks = len([k for k, val in count.items() if val == most_freq]) ans = max(len(tasks), (most_freq-1)*(n+1)+top_tasks) return ans # Time O(N) # Space O(N)  ","id":99,"section":"posts","summary":"LC 621 Task Scheduler Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle. However, there is a non-negative integer n that represents the cooldown period between two","tags":["leetcode","string","math"],"title":"621 Task Scheduler","uri":"https://foxisawesome.github.io/posts/621-task-scheduler/","year":"2020"},{"content":"LC 300 Longest Increasing Subsequence   Given an unsorted array of integers, find the length of longest increasing subsequence.\nExample:\nInput: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.   Solution 2020-09-12 Notes:\n  $\\mathcal{O}(N^2)$的解，25%通过了。经典的dp算法题，算法如下：\n 每个位置dp[i]:表示是nums中[0, i]中最长递增子序列length。nums[i+1]与之前每个num比较，要是更大，就能与其组成更长的数列，dp[i+1] = max(1, dp[j] | j \u0026lt; i+1 and num[j] \u0026lt; num[i+1]) 在top ranking的解里看到了用binary search的高级方法，二刷的时候在试试吧。    class Solution: def lengthOfLIS(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) dp = [1]*n for i in range(1,n): for j in range(i): if nums[j] \u0026lt; nums[i]: dp[i] = max(dp[i], dp[j]+1) return max(dp) # Time O(N^2) # Space O(N)  ","id":100,"section":"posts","summary":"LC 300 Longest Increasing Subsequence Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Solution 2020-09-12 Notes: $\\mathcal{O}(N^2)$的解，25%通过了。经典的d","tags":["leetcode","dp"],"title":"300 Longest Increasing Subsequence","uri":"https://foxisawesome.github.io/posts/300-longest-increasing-subsequence/","year":"2020"},{"content":"LC 767 Reorganize String   Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.\nIf possible, output any possible result. If not possible, return the empty string.\nInput: S = \u0026quot;aab\u0026quot; Output: \u0026quot;aba\u0026quot;   Solution 2020-09-12 Notes:\n 这题的思路来自这：  有个dynamic的counter dictionary 每次按频率出现次数最多的顺序加入ans，如果频率一样取与ans[-1]不同的字母加入，直至取完或者无法满足条件。 每加入一个字母， 字典频率 -1，需要回到while loop, 重新load counter.most_common()    class Solution: def reorganizeString(self, S: str) -\u0026gt; str: counter = collections.Counter(S) ans = \u0026quot;@\u0026quot; while counter: stop = True for s, freq in counter.most_common(): if ans[-1] != s and freq != 0: stop = False ans += s counter[s] -= 1 if counter[s] == 0: del counter[s] break if stop: break return ans[1:] if len(ans[1:]) == len(S) else '' # Time O(N) # Space O(N)  ","id":101,"section":"posts","summary":"LC 767 Reorganize String Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any possible result. If not possible, return the empty string. Input: S = \u0026quot;aab\u0026quot; Output: \u0026quot;aba\u0026quot; Solution 2020-09-12 Notes: 这题的思路来自这： 有个dynamic的","tags":["leetcode","string","hashtable"],"title":"767 Reorganize String","uri":"https://foxisawesome.github.io/posts/767-reorganize-string/","year":"2020"},{"content":"双指针技巧总结 我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。\n一、快慢指针的常见算法 快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。\n1、判定链表中是否含有环\n这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。\n单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。\n如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。\nboolean hasCycle(ListNode head) { while (head != null) head = head.next; return false; }  但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。\n经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。\nboolean hasCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) return true; } return false; }  2、已知链表中含有环，返回这个环的起始位置\n这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码：\nListNode detectCycle(ListNode head) { ListNode fast, slow; fast = slow = head; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) break; } // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) { fast = fast.next; slow = slow.next; } return slow; }  可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？\n第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（环长度的倍数）。\n设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。\n巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。\n所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。\n3、寻找链表的中点\n类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。\nwhile (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } // slow 就在中间位置 return slow;  当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：\n寻找链表中点的一个重要作用是对链表进行归并排序。\n回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。\n但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。\n4、寻找链表的倒数第 k 个元素\n我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）：\nListNode slow, fast; slow = fast = head; while (k-- \u0026gt; 0) fast = fast.next; while (fast != null) { slow = slow.next; fast = fast.next; } return slow;  二、左右指针的常用算法 左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。\n1、二分查找\n前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：\nint binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left \u0026lt;= right) { int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; else if (nums[mid] \u0026gt; target) right = mid - 1; } return -1; }  2、两数之和\n直接看一道 LeetCode 题目吧：\n只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小：\nint[] twoSum(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt; right) { int sum = nums[left] + nums[right]; if (sum == target) { // 题目要求的索引是从 1 开始的 return new int[]{left + 1, right + 1}; } else if (sum \u0026lt; target) { left++; // 让 sum 大一点 } else if (sum \u0026gt; target) { right--; // 让 sum 小一点 } } return new int[]{-1, -1}; }  3、反转数组\nvoid reverse(int[] nums) { int left = 0; int right = nums.length - 1; while (left \u0026lt; right) { // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; } }  4、滑动窗口算法\n这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。\n幸运的是，这类算法是有框架模板的，而且这篇文章就讲解了「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。\n致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\n","id":102,"section":"posts","summary":"双指针技巧总结 我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环","tags":[""],"title":"双指针技巧总结","uri":"https://foxisawesome.github.io/posts/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/","year":"2020"},{"content":"团灭 LeetCode 股票买卖问题 很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。\n这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\nPS：本文参考自英文版 LeetCode 的一篇题解。\n先随便抽出一道题，看看别人的解法：\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i\u0026lt;prices.size();++i) { s1 = max(s1, -prices[i]); s2 = max(s2, s1+prices[i]); s3 = max(s3, s2-prices[i]); s4 = max(s4, s3+prices[i]); } return max(0,s4); }  能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。\n本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\n这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：\n第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。\n如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。\n一、穷举框架\n首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。\n递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。\n而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。\nfor 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...)  比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k \u0026gt; 0 的前提下操作。\n很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：\ndp[i][k][0 or 1] 0 \u0026lt;= i \u0026lt;= n-1, 1 \u0026lt;= k \u0026lt;= K n 为天数，大 K 为最多交易数 此问题共 n × K × 2 种状态，全部穷举就能搞定。 for 0 \u0026lt;= i \u0026lt; n: for 1 \u0026lt;= k \u0026lt;= K: for s in {0, 1}: dp[i][k][s] = max(buy, sell, rest)  而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？\n我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。\n记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。\n二、状态转移框架\n现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。\n通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell ) 解释：今天我没有持有股票，有两种可能： 要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有； 要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy ) 解释：今天我持有着股票，有两种可能： 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票； 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。  这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。\n现在，我们已经完成了动态规划中最困难的一步：状态转移方程。**如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。**不过还差最后一点点，就是定义 base case，即最简单的情况。\ndp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。 dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。  把上面的状态转移方程总结一下：\nbase case： dp[-1][k][0] = dp[i][0][0] = 0 dp[-1][k][1] = dp[i][0][1] = -infinity 状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])  读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。\n三、秒杀题目\n第一题，k = 1\n直接套状态转移方程，根据 base case，可以做一些化简：\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。 可以进行进一步化简去掉所有 k： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i])  直接写出代码：\nint n = prices.length; int[][] dp = new int[n][2]; for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0];  显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：\nfor (int i = 0; i \u0026lt; n; i++) { if (i - 1 == -1) { dp[i][0] = 0; // 解释： // dp[i][0] // = max(dp[-1][0], dp[-1][1] + prices[i]) // = max(0, -infinity + prices[i]) = 0 dp[i][1] = -prices[i]; //解释： // dp[i][1] // = max(dp[-1][1], dp[-1][0] - prices[i]) // = max(-infinity, 0 - prices[i]) // = -prices[i] continue; } dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]); dp[i][1] = Math.max(dp[i-1][1], -prices[i]); } return dp[n - 1][0];  第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):\n// k == 1 int maxProfit_k_1(int[] prices) { int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); // dp[i][1] = max(dp[i-1][1], -prices[i]) dp_i_1 = Math.max(dp_i_1, -prices[i]); } return dp_i_0; }  两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。\n第二题，k = +infinity\n如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  直接翻译成代码：\nint maxProfit_k_inf(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i]); } return dp_i_0; }  第三题，k = +infinity with cooldown\n每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。  翻译成代码：\nint maxProfit_with_cool(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]); dp_pre_0 = temp; } return dp_i_0; }  第四题，k = +infinity with fee\n每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) 解释：相当于买入股票的价格升高了。 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。  直接翻译成代码：\nint maxProfit_with_fee(int[] prices, int fee) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i \u0026lt; n; i++) { int temp = dp_i_0; dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]); dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee); } return dp_i_0; }  第五题，k = 2\nk = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。\n这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。\n原始的动态转移方程，没有可化简的地方 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])  按照之前的代码，我们可能想当然这样写代码（错误的）：\nint k = 2; int[][][] dp = new int[n][k + 1][2]; for (int i = 0; i \u0026lt; n; i++) if (i - 1 == -1) { /* 处理一下 base case*/ } dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][k][0];  为什么错误？我这不是照着状态转移方程写的吗？\n还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1：\n「代码截图」\n这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：\nint max_k = 2; int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i \u0026lt; n; i++) { for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { /*处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } } // 穷举了 n × max_k × 2 个状态，正确。 return dp[n - 1][max_k][0];  如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。\n这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]) dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) int maxProfit_k_2(int[] prices) { int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) { dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); } return dp_i20; }  有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。\n第六题，k = any integer\n有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？\n一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。\n直接把之前的代码重用：\nint maxProfit_k_any(int max_k, int[] prices) { int n = prices.length; if (max_k \u0026gt; n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i \u0026lt; n; i++) for (int k = max_k; k \u0026gt;= 1; k--) { if (i - 1 == -1) { /* 处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][max_k][0]; }  至此，6 道题目通过一个状态转移方程全部解决。\n四、最后总结\n本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。\n关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？\n具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。\nHanmin 提供 Python3 代码:\n第一题，k = 1\ndef maxProfit(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, -price) return dp_i_0  第二题，k = +infinity\ndef maxProfit_k_inf(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, temp - price) return dp_i_0  第三题，k = +infinity with cooldown\ndef maxProfit_with_cool(self, prices: List[int]) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') dp_pre_0 = 0 ##代表 dp[i-2][0] for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, dp_pre_0 - price) dp_pre_0 = temp return dp_i_0  第四题，k = +infinity with fee\ndef maxProfit_with_fee(self, prices: List[int], fee: int) -\u0026gt; int: dp_i_0,dp_i_1 = 0,float('-inf') for price in prices: temp = dp_i_0 dp_i_0 = max(dp_i_0, dp_i_1 + price) dp_i_1 = max(dp_i_1, temp - price -fee) return dp_i_0  第五题，k = 2\ndef maxProfit_k_2(self, prices: List[int]) -\u0026gt; int: dp_i10,dp_i11 = 0,float('-inf') dp_i20,dp_i21 = 0,float('-inf') for price in prices: dp_i20 = max(dp_i20, dp_i21 + price) dp_i21 = max(dp_i21, dp_i10 - price) dp_i10 = max(dp_i10, dp_i11 + price) dp_i11 = max(dp_i11, -price) return dp_i20  第六题，k = any integer\ndef maxProfit_k_any(self, max_k: int, prices: List[int]) -\u0026gt; int: n = len(prices) if max_k \u0026gt; n // 2: return self.maxProfit_k_inf(prices) else: dp = [[[None, None] for _ in range(max_k + 1)] for _ in range(n)] for i in range(0,n): for k in range(max_k,0,-1): if i-1 == -1:## 处理 base case dp[i][k][0] = 0 ## 解释： ## dp[i][k][0] = max(dp[-1][k][0], dp[-1][k][1] + prices[i]) ## = max(0, -infinity + prices[i]) = 0 dp[i][k][1] = -prices[i] ## 解释： ## dp[i][1] = max(dp[-1][k][1], dp[-1][k][0] - prices[i]) ## = max(-infinity, 0 - prices[i]) = -prices[i] continue dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) return dp[n - 1][max_k][0];  z2z23n0 提供 C++ 代码:\n第一题，k = 1\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = max(dp_i_1, -prices[i - 1]); } return dp_i_0; }  第二题，k = +infinity\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = std::max(dp_i_1, temp - prices[i - 1]); } return dp_i_0; }  第三题，k = +infinity with cooldown\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); // base case // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 int dp_i_0 = 0, dp_i_1 = INT_MIN; // 表示第(i-2)天的最大利润，并且未持有股票 int prev_dp_i_0 = 0; for (int i = 1; i \u0026lt;= n; i++) { // temp和prev_dp_i_0用来记录第(i-2)天(前天)的最大利润 int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 dp_i_1 = std::max(dp_i_1, prev_dp_i_0 - prices[i - 1]); prev_dp_i_0 = temp; } return dp_i_0; }  第四题，k = +infinity with fee\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices, int fee) { int n = prices.size(); // base case int dp_i_0 = 0, dp_i_1 = INT_MIN; // dp_i_0: 第i天的最大利润, 0表示不持有股票 // dp_i_1: 第i天的最大利润, 1表示持有股票 for (int i = 1; i \u0026lt;= n; i++) { int temp = dp_i_0; // 如果今天不持有股票，表示昨天也不持有股票或是今天卖掉了股票 dp_i_0 = std::max(dp_i_0, dp_i_1 + prices[i - 1]); // 如果今天持有股票，表示昨天就持有股票或是今天买了股票 //tips:为什么不在卖股票的时候减掉transaction fee？因为在base case中， dp_i_1 == INT_MIN, INT_MIN + prices[i] - fee 可能会造成整型溢出 dp_i_1 = std::max(dp_i_1, temp - prices[i - 1] - fee); } return dp_i_0; }  第五题，k = 2\nint maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int size = prices.size(); int max_k = 2; // i从1开始而不是0，这样可以使base case是 dp[0][0][0] 和 dp[0][0][1] 而不是 dp[-1][0][0] 或者 dp[-1][0] int dp[size + 1][max_k + 1][2]; // 初始化 for (int k = max_k; k \u0026gt;= 0; k--) { dp[0][k][0] = 0; dp[0][k][1] = INT_MIN; } for (int i = 1; i \u0026lt;= size; i++) { dp[i][0][0] = 0; dp[i][0][1] = INT_MIN; for (int k = max_k; k \u0026gt;= 1; k--) { dp[i][k][0] = std::max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i - 1]); dp[i][k][1] = std::max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i - 1]); } } return dp[size][max_k][0]; }  第六题，k = any integer\nint maxProfit(int k, vector\u0026lt;int\u0026gt; \u0026amp;prices) { int size = prices.size(); if (k \u0026gt; size / 2) { return maxProfitLimitless(prices); } // i从1开始而不是0，这样可以使base case是 dp[0][0][0] 和 dp[0][0][1] 而不是 dp[-1][0][0] 或者 dp[-1][0][1] int dp[size + 1][k + 1][2]; // 初始化 for (int j = k; j \u0026gt;= 0; j--) { dp[0][j][0] = 0; dp[0][j][1] = INT_MIN; } for (int i = 1; i \u0026lt;= size; i++) { dp[i][0][0] = 0; dp[i][0][1] = INT_MIN; for (int j = k; j \u0026gt;= 1; j--) { dp[i][j][0] = std::max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i - 1]); dp[i][j][1] = std::max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i - 1]); } } return dp[size][k][0]; }  上一篇：动态规划之KMP字符匹配算法\n下一篇：团灭 LeetCode 打家劫舍问题\n目录\n","id":103,"section":"posts","summary":"团灭 LeetCode 股票买卖问题 很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫","tags":["dp"],"title":"团灭LC股票问题","uri":"https://foxisawesome.github.io/posts/%E5%9B%A2%E7%81%ADlc%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/","year":"2020"},{"content":"LC 142 Linked List Cycle ii   Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n Solution 2020-09-11 Notes:\n 这题的algo就是：  slow 和 fast同时head起走，fast走两步，slow一步一回合。 要么fast走完return None，要么有环和slow相遇。 要是相遇，此时第三个指针从head，fast从相遇地点同时一步一回合，相遇点就是环的起点。   用到 fast.next.next时一定记住while condition里要有 fast.next  # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def detectCycle(self, head: ListNode) -\u0026gt; ListNode: if not head: return None slow = fast = head count = 0 while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break if not fast or not fast.next: return None while head != fast: count += 1 head = head.next fast = fast.next return head # Time O(N) # Space O(1)  ","id":104,"section":"posts","summary":"LC 142 Linked List Cycle ii Given a linked list, return the node where the cycle begins. If there is no cycle, return null. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Solution 2020-09-11 Notes: 这题的","tags":["leetcode","linkedlist"],"title":"142 Linked List Cycle ii","uri":"https://foxisawesome.github.io/posts/142-linked-list-cycle-ii/","year":"2020"},{"content":"LC 4 Median of Two Sorted Arrays   Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n Solution 2020-09-11 Notes:\n山景城一姐的做法一目了然！第一种用了merge sort，第二种做法是binary search较短的array，time log(M)\n漂亮！漂亮！\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u0026gt; float: n1 = len(nums1) n2 = len(nums2) if n1 \u0026gt; n2: return self.findMedianSortedArrays(nums2, nums1) n = n1 + n2 l, r = 0, n1 while l \u0026lt;= r: m1 = l + (r-l)//2 m2 = (n+1)//2 - m1 l1 = -float('inf') if m1==0 else nums1[m1-1] l2 = -float('inf') if m2==0 else nums2[m2-1] r1 = float('inf') if m1==n1 else nums1[m1] r2 = float('inf') if m2==n2 else nums2[m2] if l1 \u0026gt; r2: r = m1-1 elif l2 \u0026gt; r1: l = m1+1 elif n % 2 == 0: return (max(l1,l2) + min(r1, r2))/2 elif n % 2 == 1: return max(l1,l2) return -1 # Time(logM) # Space(1)  2020-08-19 Notes:\n根据花花酱的做法写的。。。实在是被说的太复杂了，估计面试时根本hold不住\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u0026gt; float: n1 = len(nums1) n2 = len(nums2) if n1 \u0026gt; n2: return self.findMedianSortedArrays(nums2, nums1) k = (n1+n2+1) // 2 #left median l, r = 0, n1-1 while l \u0026lt;= r: m1 = l + (r-l)//2 m2 = k- m1 if nums1[m1] \u0026lt; nums2[m2-1]: l = m1 + 1 elif nums1[m1] \u0026gt;= nums2[m2-1]: r = m1 - 1 m1 = l m2 = k - m1 print(m1,m2) c1 = max(-float('inf') if m1\u0026lt;=0 else nums1[m1-1], -float('inf') if m2 \u0026lt;=0 else nums2[m2-1]) if (n1 + n2) % 2 == 1: return c1 c2 = min(float('inf') if m1 \u0026gt;= n1 else nums1[m1], float('inf') if m2 \u0026gt;= n2 else nums2[m2]) if (n1 + n2) % 2 == 0: return (c1+c2)/2 # Time O(log(M+N)) # Space O(1)  ","id":105,"section":"posts","summary":"LC 4 Median of Two Sorted Arrays Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. Solution 2020-09-11 Notes: 山景城一姐的做法一目了然！第一种用了merge sort，第二种做法是binar","tags":["leetcode","binary_search"],"title":"4 Median of Two Sorted Arrays","uri":"https://foxisawesome.github.io/posts/4-median-of-two-sorted-arrays/","year":"2020"},{"content":"original labuladong post\n先给大家讲个笑话乐呵一下：\n有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。\n从此，图书馆丢了 N - 1 本书。\n二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：思路很简单，细节是魔鬼。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 \u0026lt;= 还是 \u0026lt;。\n你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。\n本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。\n零、二分查找框架 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u0026lt; target) { left = ... } else if (nums[mid] \u0026gt; target) { right = ... } } return ...; }  分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。\n其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。\n另外声明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。\n一、寻找一个数（基本的二分搜索） 这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。\nint binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] \u0026lt; target) left = mid + 1; // 注意 else if (nums[mid] \u0026gt; target) right = mid - 1; // 注意 } return -1; }  1、为什么 while 循环的条件中是 \u0026lt;=，而不是 \u0026lt;？\n答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。\n我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。\n什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：\nif(nums[mid] == target) return mid;  但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。\nwhile(left \u0026lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。\nwhile(left \u0026lt; right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。\n当然，如果你非要用 while(left \u0026lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：\n//... while(left \u0026lt; right) { // ... } return nums[left] == target ? left : -1;  2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？\n答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？\n当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。\n3、此算法有什么缺陷？\n答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。\n比如说给你有序数组 nums = [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。\n这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。\n我们后续的算法就来讨论这两种二分查找的算法。\n二、寻找左侧边界的二分搜索 以下是最常见的代码形式，其中的标记是需要注意的细节：\nint left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left \u0026lt; right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; // 注意 } } return left; }  1、为什么 while 中是 \u0026lt; 而不是 \u0026lt;=?\n答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\nwhile(left \u0026lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。\nPS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的 right 不是 nums.length - 1 吗，为啥这里非要写成 nums.length 使得「搜索区间」变成左闭右开呢？\n因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。\n2、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：\n对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。\n比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。\n再比如说 nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。\n综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：\nwhile (left \u0026lt; right) { //... } // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1;  3、为什么 left = mid + 1，right = mid ？和之前的算法不一样？\n答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。\n4、为什么该算法能够搜索左侧边界？\n答：关键在于对于 nums[mid] == target 这种情况的处理：\nif (nums[mid] == target) right = mid;  可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n5、为什么返回 left 而不是 right？\n答：都是一样的，因为 while 终止的条件是 left == right。\n6、能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。\n答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：\n因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 \u0026lt;=：\nint left_bound(int[] nums, int target) { // 搜索区间为 [left, right] int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; // if else ... }  因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下：\nif (nums[mid] \u0026lt; target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u0026gt; target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; }  由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界：\n因此，最后返回结果的代码应该检查越界情况：\nif (left \u0026gt;= nums.length || nums[left] != target) return -1; return left;  至此，整个算法就写完了，完整代码如下：\nint left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; // 搜索区间为 [left, right] while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { // 搜索区间变为 [mid+1, right] left = mid + 1; } else if (nums[mid] \u0026gt; target) { // 搜索区间变为 [left, mid-1] right = mid - 1; } else if (nums[mid] == target) { // 收缩右侧边界 right = mid - 1; } } // 检查出界情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; }  这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。\n三、寻找右侧边界的二分查找 类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：\nint right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left \u0026lt; right) { int mid = (left + right) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid; } } return left - 1; // 注意 }  1、为什么这个算法能够找到右侧边界？\n答：类似地，关键点还是这里：\nif (nums[mid] == target) { left = mid + 1;  当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。\n2、为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。\n答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。\n至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：\nif (nums[mid] == target) { left = mid + 1; // 这样想: mid = left - 1  因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。\n至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。\n3、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：\nwhile (left \u0026lt; right) { // ... } if (left == 0) return -1; return nums[left-1] == target ? (left-1) : -1;  4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。\n答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：\nint right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 这里改成收缩左侧边界即可 left = mid + 1; } } // 这里改为检查 right 越界的情况，见下图 if (right \u0026lt; 0 || nums[right] != target) return -1; return right; }  当 target 比所有元素都小时，right 会被减到 -1，所以需要在最后防止越界：\n至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？\n四、逻辑统一 来梳理一下这些细节差异的因果逻辑：\n第一个，最基本的二分查找算法：\n因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u0026lt;= right) 同时也决定了 left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回  第二个，寻找左侧边界的二分查找：\n因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界  第三个，寻找右侧边界的二分查找：\n因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一  对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：\nint binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } int left_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 最后要检查 left 越界的情况 if (left \u0026gt;= nums.length || nums[left] != target) return -1; return left; } int right_bound(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 最后要检查 right 越界的情况 if (right \u0026lt; 0 || nums[right] != target) return -1; return right; }  如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。\n通过本文，你学会了：\n1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。\n2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。\n3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。\n4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。\n呵呵，此文对二分查找的问题无敌好吧！致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\n上一篇：回溯算法解题框架\n下一篇：滑动窗口解题框架\n目录\n","id":106,"section":"posts","summary":"original labuladong post 先给大家讲个笑话乐呵一下： 有一天阿东到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿","tags":["binary_search"],"title":"二分查找详解","uri":"https://foxisawesome.github.io/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/","year":"2020"},{"content":"LC 829 Consecutive Numbers Sum   Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers?\nInput: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5   Solution 2020-09-11 Notes:\n  以为又是backtracking的解法呢。\n  一个数$N$能分解成连续自然数之和，就可以分解为: $$ N = a*k + (k+1)*k/2 $$ Where $a$ is a integer.\nupper bound comes from a\u0026gt;=0.\n  此题最大亮点是解答中这句话：\n The best way to solve this problem is to run Shor\u0026rsquo;s Algorithm on the quantum computer, that requires $\\mathcal{O}(\\log^2 N \\log \\log N \\log \\log \\log N)$ time. If there is no quantum computer in the interview room, just use classical GNFS Algorithm, which runs in a decent $\\mathcal{O}(e^{\\log^{1/3} N (\\log \\log N)^{2/3}})$time.\n   class Solution: def consecutiveNumbersSum(self, N: int) -\u0026gt; int: count = 0 upper = ceil((2*N +0.25)**0.5-0.5) for k in range(1, upper+1): if (N- k*(k+1)//2 ) % k == 0: count += 1 return count # Time O(sqrt(N)) # Space O(1)  ","id":107,"section":"posts","summary":"LC 829 Consecutive Numbers Sum Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Input: 15 Output: 4 Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 Solution 2020-09-11 Notes: 以为又是backtrackin","tags":["leetcode","math"],"title":"829 Consecutive Numbers Sum","uri":"https://foxisawesome.github.io/posts/829-consecutive-numbers-sum/","year":"2020"},{"content":"LC 312 Burst Balloons   Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nInput: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --\u0026gt; [3,5,8] --\u0026gt; [3,8] --\u0026gt; [8] --\u0026gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167   Solution 2020-09-10 Notes:\n幼稚的一刷，能解对但是ETL. 用了memo：\n [1] +nums+[1] 小trick可以简化边界条件。 track 区间的index应该能优化不少。  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() return self.dfs(nums) def dfs(self, nums): if not nums: return 0 if str(nums) in self.memo: return self.memo[str(nums)] temp = [] nums = [1] + nums + [1] n = len(nums) for i in range(1,n-1): new_nums = nums[1:i]+nums[i+1:n-1] temp.append(nums[i]*nums[i-1]*nums[i+1] + self.dfs(new_nums)) self.memo[str(nums)] = max(temp) return self.memo[str(nums)] # Time O(N!) # Space O()  看了答案，优化了一下：\n最关键的公式是：nums[i-1]*nums[k]*nums[j+1]: 含义如下\n Dfs(i,j) return 的是刺破[i,j]区间上所有气球后得到的最大值，前提是区间上所有气球都破了。 在[i,j]区间上，假设 [i,k-1], 和 [k+1,j] 已经被最优刺破，那么剩下的最后一个k-th 气球被刺破时，值就为nums[i-1]*nums[k]*nums[j+1]。是top-down的recursion。 labuladong 提供了相同解释  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() nums = [1] + nums + [1] return self.dfs(nums,1,len(nums)-2) def dfs(self, nums, i, j): if not nums: return 0 if (i,j) in self.memo: return self.memo[(i,j)] ans = 0 for k in range(i,j+1): ans = max(ans, self.dfs(nums,i,k-1) + nums[i-1]*nums[k]*nums[j+1] + self.dfs(nums,k+1,j)) self.memo[(i,j)] = ans return self.memo[(i,j)] # Time O(N^3) # Space O(N^2)  ","id":108,"section":"posts","summary":"LC 312 Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum","tags":["leetcode","dp","recursion"],"title":"312 Burst Balloons","uri":"https://foxisawesome.github.io/posts/312-burst-balloons/","year":"2020"},{"content":"LC 110 Balanced Binary Tree   Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\n a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n Given the following tree [3,9,20,null,null,15,7]:Return true.\n 3 / \\ 9 20 / \\ 15 7  Given the following tree [1,2,2,3,3,null,null,4,4]:Return false.\n 1 / \\ 2 2 / \\ 3 3 / \\ 4 4   Solution 2020-09-10 Notes:  Time complexity is O(NlogN), 这个花花讲了原因不是很懂 其实isBalance()输出的时 需要判断left child and right child if existed.否则左右是两条单链的情况不能过。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True l = self.treeHeight(root.left) r = self.treeHeight(root.right) return (abs(l-r) \u0026lt; 2) and self.isBalanced(root.left) and self.isBalanced(root.right) def treeHeight(self,root): if not root: return 0 l = self.treeHeight(root.left) r = self.treeHeight(root.right) return max(l,r) + 1 # Time O(NlogN) # Space O(H)  ","id":109,"section":"posts","summary":"LC 110 Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Given the following tree [3,9,20,null,null,15,7]:Return true. 3 / \\ 9 20 / \\ 15 7 Given the following tree [1,2,2,3,3,null,null,4,4]:Return false. 1 / \\ 2","tags":["leetcode","tree"],"title":"110 Balanced Binary Tree","uri":"https://foxisawesome.github.io/posts/110-balanced-binary-tree/","year":"2020"},{"content":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.   Solution 2020-09-10 Notes:\n Pretty similar to symetric tree. need to judge flipping or not flipping cases  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: TreeNode, root2: TreeNode) -\u0026gt; bool: if not root1 and not root2: return True if not root1 or not root2: return False # flipping l1 = self.flipEquiv(root1.left, root2.right) r1 = self.flipEquiv(root1.right, root2.left) # not flipping l2 = self.flipEquiv(root1.left, root2.left) r2 = self.flipEquiv(root1.right, root2.right) return root1.val == root2.val and ((l1 and r1) or (l2 and r2)) # Time O(N) # Space O(logN)  ","id":110,"section":"posts","summary":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.","tags":["leetcode","tree"],"title":"951 Flip Equivalent Binary Trees","uri":"https://foxisawesome.github.io/posts/951-flip-equivalent-binary-trees/","year":"2020"},{"content":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case. need to create a mirror() with two arguments.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSymmetric_recur(self, root: TreeNode) -\u0026gt; bool: if not root: return True return self.mirror(root.left, root.right) def mirror(self, r1, r2): if not r1 and not r2: return True if not r1 or not r2: return False outer = self.mirror(r1.left, r2.right) inner = self.mirror(r1.right, r2.left) return r1.val==r2.val and outer and inner def isSymmetric_iter(self, root: TreeNode) -\u0026gt; bool: if not root: return True stack = [] stack.append((root.left, root.right)) while stack: l, r = stack.pop() if not l and not r: continue if not l or not r or l.val != r.val: return False stack.append((l.left, r.right)) stack.append((l.right,r.left)) return True # Time O(N) # Space O(logN)  ","id":111,"section":"posts","summary":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case.","tags":["leetcode","tree"],"title":"101 Symmetric Tree","uri":"https://foxisawesome.github.io/posts/101-symmetric-tree/","year":"2020"},{"content":"LC 100 Same Tree   Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\n Solution 2020-09-09 Notes:\n Two roots 的pattern 和 single root一样。Tree 刷的略有感觉了！  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: if not p and not q: return True if not p or not q: return False l = self.isSameTree(p.left, q.left) r = self.isSameTree(p.right, q.right) return p.val == q.val and l and r # Time O(N) # Space O(logN)  ","id":112,"section":"posts","summary":"LC 100 Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Solution 2020-09-09 Notes: Two roots 的pattern 和 single root一样。Tree 刷的略有感","tags":["leetcode","tree"],"title":"100 Same Tree","uri":"https://foxisawesome.github.io/posts/100-same-tree/","year":"2020"},{"content":"LC 112 Path Sum   Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1  return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\n Solution 2020-09-09 Notes:  recursion 可以把pathSm()合并到主函数，因为input，output都一致。但我还是刷出来了！😊。 每一层传入的是 target-root.val, 穿出的是left bool or right bool 领悟是if not root: return None (or False in this case)是default，肯定要的。 iteration的做法在第二部分。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum_recur(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False return self.pathSum(root, sum) def pathSum(self, root, target): if not root: return if not root.left and not root.right: return root.val == target l = self.pathSum(root.left, target - root.val) r = self.pathSum(root.right, target - root.val) return l or r # Time O(N) # Space O(logN) def hasPathSum_iter(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False stack = [(root, root.val)] while stack: node, path = stack.pop() if not node.left and not node.right and path == sum: return True if node.left: stack.append((node.left, path + node.left.val)) if node.right: stack.append((node.right, path + node.right.val)) return False # Time O(N) # Space O(N)  ","id":113,"section":"posts","summary":"LC 112 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum","tags":["leetcode","tree"],"title":"112 Path Sum","uri":"https://foxisawesome.github.io/posts/112-path-sum/","year":"2020"},{"content":"LC 104 Maximum Depth of Binary Tree   Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-09-09 Notes:\n 注意patterns. Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.maxDepth(root.left) r = self.maxDepth(root.right) return max(l,r)+1 # Time O(N) # Space: best scenario O(H)=O(logN)  ","id":114,"section":"posts","summary":"LC 104 Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 Solution 2020-09-09 Notes: 注意patterns. Beat the TREE! # Definition for","tags":["leetcode","tree"],"title":"104 Maximum Depth of Binary Tree","uri":"https://foxisawesome.github.io/posts/104-maximum-depth-of-binary-tree/","year":"2020"},{"content":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.minDepth(root.left) r = self.minDepth(root.right) if not l and r: return r+1 if not r and l: return l+1 return min(l,r)+1 # Time O(N) # Space O(logN)  ","id":115,"section":"posts","summary":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node.","tags":["leetcode","tree"],"title":"111 Minimum Depth of Binary Tree","uri":"https://foxisawesome.github.io/posts/111-minimum-depth-of-binary-tree/","year":"2020"},{"content":"LC 124 Binary Tree Maximum Path Sum   Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nInput: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42   Solution 2020-09-09 Notes:\n 因为要online update ans，所以得要个helper()。helper() 返回的是 maxPathSum。 line #23: 是因为每条sub-path只能取左child或者右child中的较大path。   类似题: LC 543  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: TreeNode) -\u0026gt; int: self.ans = -float('inf') self.helperMax(root) return self.ans def helperMax(self, root): if not root: return 0 left = self.helperMax(root.left) right = self.helperMax(root.right) left = left if left \u0026gt; 0 else 0 right = right if right \u0026gt; 0 else 0 self.ans = max(self.ans, left+right+root.val) return root.val + max(left, right) # Time O(N) # Space O(H)  ","id":116,"section":"posts","summary":"LC 124 Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15","tags":["leetcode","tree"],"title":"124 Binary Tree Maximum Path Sum","uri":"https://foxisawesome.github.io/posts/124-binary-tree-maximum-path-sum/","year":"2020"},{"content":"LC 236 Lowest Common Ancestor of a Binary Tree   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\n Solution 2020-09-09 Notes:  递归灵魂三问 (reference: labuladong)：  递归函数return的是什么？ 递归函数的arguments？ 如何利用递归函数的返回值？   part 1: 最底层返回条件，root== p 或 q时， 返回root。 这题底层就两种情况，啥也没找到 Null，找到p, q，就不再开新的recursion， 直接返回p, q。 part 2: 固定的binary tree recursion模版 part 3: 此处是post-order, 返回值的利用，就三种情况：a. p, q 同时都在root里, 那么root就是LCA, 把这个LCA一层层返回上去。 b. p,q 都不在root里, 返回None。c. p,q 其一在root里，那个层层返回p 或 q 的这两个单独节点，直到他们相遇的root才是LCA。  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u0026gt; 'TreeNode': # part 1 if root is None: return None if root == p or root == q: return root # part 2 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # part 3 if left and right: return root if not left and not right: return None return left if left else right # Time O(N) # Space O(?)  ","id":117,"section":"posts","summary":"LC 236 Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be","tags":["leetcode","tree"],"title":"236 Lowest Common Ancestor of a Binary Tree","uri":"https://foxisawesome.github.io/posts/236-lowest-common-ancestor-of-a-binary-tree/","year":"2020"},{"content":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:  O(N) is easy.  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: l = 0 out = '' for i in s: while l \u0026lt; len(t): if t[l]==i: out += t[l] l +=1 break l += 1 return out == s # Time O(M), M:len(t) # Space O(1)   the follow-up of this questions: while s\u0026raquo;t, O(N) is not satisfied. here is O(MlogN) solution using binary search is pretty hard to think of:  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: d = dict() for i, val in enumerate(t): if val not in d: d[val] = [i] else: d[val].append(i) tar = 0 for i, val in enumerate(s): if val not in d: return False pos = self.leftBound(d[val],tar) if pos == len(d[val]): return False tar = d[val][pos] + 1 return True def leftBound(self, idx_ls, p): l, r = 0, len(idx_ls) while l \u0026lt; r: m = l + (r-l)//2 if idx_ls[m] \u0026lt; p: l = m + 1 elif idx_ls[m] \u0026gt;= p: r = m return l # Time O(MlogN), N:len(s), M:len(t) # Space O(M)  ","id":118,"section":"posts","summary":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:  O(N) is easy.","tags":["leetcode","binary_search"],"title":"392 Is Subsequence","uri":"https://foxisawesome.github.io/posts/392-is-subsequence/","year":"2020"},{"content":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","id":119,"section":"posts","summary":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"268 Missing Number","uri":"https://foxisawesome.github.io/posts/268-missing-number/","year":"2020"},{"content":"LC 645 Set Mismatch   The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n Solution 2020-09-08 Notes:\n 可以直接算出来， sum(1-n) - sum(set(nums)) 也可以用hash table的思想构造 count dict 来做， one-pass。要真用dict() 得two-pass了。还得pass一边dictionary。  class Solution: def findErrorNums(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) h = [0]*n for i in range(n): h[nums[i]-1] += 1 return [h.index(2)+1, h.index(0)+1] # Time O(N) # Space O(N)  ","id":120,"section":"posts","summary":"LC 645 Set Mismatch The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number","tags":["leetcode","hashtable"],"title":"645 Set Mismatch","uri":"https://foxisawesome.github.io/posts/645-set-mismatch/","year":"2020"},{"content":"LC 234 Palindrome Linked List   Given a singly linked list, determine if it is a palindrome.\n Solution 2020-09-08 Notes:   Recursion solution参考了 labuladong\n  以下是一种比较直观但是不是optimal的解法\n  line 13 is a post-order traverse.\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: ListNode) -\u0026gt; bool: self.left = head return self.traverse(head) def traverse(self, right): if not right: return True res = self.traverse(right.next) res = res and right.val ==self.left.val self.left = self.left.next return res # Time O(N) # Space O(?)  ","id":121,"section":"posts","summary":"LC 234 Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Solution 2020-09-08 Notes: Recursion solution参考了 labuladong 以下是一种比较直观但是不是optimal的解法 line 13 is a post-order traverse. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"234 Palindrome Linked List","uri":"https://foxisawesome.github.io/posts/234-palindrome-linked-list/","year":"2020"},{"content":"LC 325 Maximum Size Subarray Sum Equals K   Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead.\nInput: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.   Solution 2020-09-08 Notes:\n 此题解法跟 LC560 一摸一样。用cumulative + hash table 的one-pass O(N). 因为hash table需要用来存nums的index dict()的value 需要是list  class Solution: def maxSubArrayLen(self, nums: List[int], k: int) -\u0026gt; int: if not nums: return 0 d = collections.defaultdict(list) cum_sum = 0 d[0].append(0) n = len(nums) ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans = max(ans, i-min(d[target_sum])+1) d[cum_sum].append(i+1) return ans # Time O(N) # Space O(N)  ","id":122,"section":"posts","summary":"LC 325 Maximum Size Subarray Sum Equals K Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead. Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Solution 2020-09-08 Notes: 此题解法跟","tags":["leetcode","array","hashtable"],"title":"325 Maximum Size Subarray Sum Equals K","uri":"https://foxisawesome.github.io/posts/325-maximum-size-subarray-sum-equals-k/","year":"2020"},{"content":"LC 560 Subarray Sum Equals K   Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\nInput:nums = [1,1,1], k = 2 Output: 2   Solution 2020-09-08 Notes:\n  看了labuladong 的总结\n  预先算一个cumulative sum 的dictionary，只要 cum_sum - k in d 那么 ans 就叠加次数。\n  需要dict记录frequency, (nums可能有0)。\n  FB 热门题\n  class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: d = dict() n = len(nums) cum_sum = 0 d[cum_sum] = 1 ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans += d[target_sum] d[cum_sum] = d.get(cum_sum,0) + 1 return ans # Time O(N) # Space O(1)  ","id":123,"section":"posts","summary":"LC 560 Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Input:nums = [1,1,1], k = 2 Output: 2 Solution 2020-09-08 Notes: 看了labuladong 的总结 预先算一个cumulativ","tags":["leetcode","array","hashtable"],"title":"560 Subarray Sum Equals K","uri":"https://foxisawesome.github.io/posts/560-subarray-sum-equals-k/","year":"2020"},{"content":"LC 1109 Corporate Flight Bookings   There are n flights, and they are labeled from 1 to n.\nWe have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive.\nReturn an array answer of length n, representing the number of seats booked on each flight in order of their label.\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25]   Solution 2020-09-08 Notes:\n 题目很绕口，核心是起点和终点之间的所有节点都会 carry over seats number。 用 labuladong的差分数列的算法只要 one-pass of booking array O(N). :  首先构造 diff_arr[i] = nums[i] - nums[i-1], where diff_arr[0] = nums[0] 这个操作 diff_arr[i] += val and diff_arr[j+1] -= val 就可以操作 nums[i], ..., nums[j] all +val. With corner case, if j+1 \u0026lt; len(nums):diff_arr[j+1] -= val  回复nums: nums[i] = diff_arr[i] + nums[i-1] 如此只要 one-pass 操作区间的节点就可以对整个数列进行多次计算，直接返回要求值。   类似的技术还有先计算 cumulative sum of nums 再操作，FB有很多热门题这么做。  class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u0026gt; List[int]: diff_arr = [0] * n # diff[i] = arr[i]- arrr[i-1] ans = [0] * n for book in bookings: i = book[0]-1 j = book[1]-1 seat = book[2] diff_arr[i] += seat if j+1 \u0026lt; n: diff_arr[j+1] -= seat ans[0] = diff_arr[0] for i in range(1,n): ans[i] = diff_arr[i] + ans[i-1] return ans # Time O(N) # Space O(N)  ","id":124,"section":"posts","summary":"LC 1109 Corporate Flight Bookings There are n flights, and they are labeled from 1 to n. We have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label. Input: bookings = [[1,2,10],[2,3,20],[2,5,25]],","tags":["leetcode","array"],"title":"1109 Corporate Flight Bookings","uri":"https://foxisawesome.github.io/posts/1109-corporate-flight-bookings/","year":"2020"},{"content":"LC 1539 Kth Missing Positive Number   Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nInput: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.   Solution 2020-09-07 Notes:  O(N) solution is pretty easy, but not optimal. the binary solution is optimal.  arr[i]-(i+1): 返回的是 arr[i]和i+1 之间miss了几个数，如果arr没miss数，返回的因该是0. 所以这个条件和k比较可以快速找到最接近的位置。 我疏忽的是：这题是求k-th missing value 的起始左边界，以下是搜索左边界的标准做法。 Binary search而不是找 exact的 target (需要保证存在唯一解，才能用)，是搜索target的左边界，所以在binary search时单独例举 arr[i]-(i+1)==k 跳出会报错。应该合并 \u0026gt;=两种情况这种写法才对。 另外这题是 1-indexed，所以会有 i+1, l+k 这种小细节要搞清。    class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr) while l\u0026lt;r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m return l+k # 2nd way of writing this left boundary search. same results. def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr)-1 while l\u0026lt;=r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m - 1 return l+k # Time O(logN) # Space O(1)  class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: stack = [] if arr[-1] - len(arr) \u0026lt; k: return arr[-1]+(k-arr[-1]+len(arr)) elif arr[-1] - len(arr) \u0026gt;= k: stack = [i for i in range(1, arr[-1]+1)] [stack.remove(i) for i in arr] return stack[k-1] # Time O(N) # Space O(N)  ","id":125,"section":"posts","summary":"LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary","tags":["leetcode","binary_Search"],"title":"1539 Kth Missing Positive Number","uri":"https://foxisawesome.github.io/posts/1539-kth-missing-positive-number/","year":"2020"},{"content":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:  One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","id":126,"section":"posts","summary":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:  One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","tags":["leetcode","hashtable"],"title":"1512 Number of Good Pairs","uri":"https://foxisawesome.github.io/posts/1512-number-of-good-pairs/","year":"2020"},{"content":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:  Details: python built-in divmod() returns floor, which is not friendly in negative case. need to take int(a/b) I was scared what if the division tests on a infinite unreapted, then toasted. However, the test cases have none. convet all calc to postive nums once determined. Loop through mod and record each mod’s index place.  class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -\u0026gt; str: if denominator == 0: return '' ans = '-' if numerator * denominator \u0026lt; 0 else '' numerator, denominator = abs(numerator), abs(denominator) d = dict() div, mod = self.myDivmod(numerator, denominator) if mod == 0: ans += str(div) return ans ans += str(div) + '.' d[mod] = len(ans) while mod: div, mod = self.myDivmod(mod*10, denominator) ans += str(div) if mod in d: idx = d[mod] ans = ans[:idx] + '(' + ans[idx:] + ')' break else: d[mod] = len(ans) return ans def myDivmod(self, a, b): d = int(a/b) m = a - d*b return (d, m)  ","id":127,"section":"posts","summary":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:  Details: python built-in divmod() returns floor, which is not friendly in negative case.","tags":["leetcode"],"title":"166 Fraction to Recurring Decimal","uri":"https://foxisawesome.github.io/posts/166-fraction-to-recurring-decimal/","year":"2020"},{"content":"LC 159 Longest Substring With at Most Two Distinct Characters   Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters.\nInput: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5.   Solution 2020-09-05 Notes:\n 今天周末出去走了一圈，回家刷题效率可以啊。  class Solution: def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u0026gt; int: if not s: return 0 out = 0 n = len(s) for i in range(n): l = 1 while i+l \u0026lt; n and len(set(s[i:i+l+1])) \u0026lt; 3: l += 1 out = max(out, l) return out # Time O(N) # Space O(1)  ","id":128,"section":"posts","summary":"LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5. Solution 2020-09-05 Notes: 今天周末出去走了一圈，回家刷题效率可以啊。 class Solution: def","tags":["leetcode"],"title":"159 Longest Substring With at Most Two Distinct Characters","uri":"https://foxisawesome.github.io/posts/159-longest-substring-with-at-most-two-distinct-characters/","year":"2020"},{"content":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:  Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.add(num) else: stack.remove(num) return stack.pop() # Time O(N) # Space O(N)  If we take XOR of zero and some bit, it will return that bit: $a \\oplus 0 = a$ If we take XOR of two same bits, it will return 0: $a \\oplus a = 0$\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for num in nums: a ^= num return a  class Solution(object): def singleNumber(self, nums): return 2 * sum(set(nums)) - sum(nums)  ","id":129,"section":"posts","summary":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:  Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.","tags":["leetcode"],"title":"136 Single Number","uri":"https://foxisawesome.github.io/posts/136-single-number/","year":"2020"},{"content":"LC 187 Repeated Dna Sequences   All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n Solution 2020-09-05 Notes:  很简单的题，两个小陷进：  Substring = s[i-9:i+1] NOT s[i-10:i] because 0-indexed. avoid dups in the output.    class Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: n = len(s) if not s or n\u0026lt;10: return [] count = dict() out = [] for i in range(9,n): entry = s[i-9:i+1] ct = count.get(entry,0) + 1 count[entry]= ct if ct \u0026gt; 1 and entry not in out: out.append(entry) return out # Time O(N) # Space O(1)  ","id":130,"section":"posts","summary":"LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: 很简单的题，两个小陷","tags":["leetcode"],"title":"187 Repeated Dna Sequences","uri":"https://foxisawesome.github.io/posts/187-repeated-dna-sequences/","year":"2020"},{"content":"LC 1249 Minimum Remove to Make Valid Parentheses   Given a string s of '(' , ')' and lowercase English characters.\nYour task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.\nInput: s = \u0026quot;lee(t(c)o)de)\u0026quot; Output: \u0026quot;lee(t(c)o)de\u0026quot; Explanation: \u0026quot;lee(t(co)de)\u0026quot; , \u0026quot;lee(t(c)ode)\u0026quot; would also be accepted.   Solution 2020-09-05 Notes:  很简单的题，但是发现在line#16，用set() 要比 list()的extend 快好多好多！  class Solution: def minRemoveToMakeValid(self, s: str) -\u0026gt; str: if not s: return '' stack = [] to_rm = [] ans = '' for i, val in enumerate(s): if val not in ('(',')'): continue elif val == '(': stack.append(i) elif val == ')': if stack: stack.pop() elif not stack: to_rm.append(i) to_rm = set(to_rm + stack) for i, val in enumerate(s): if i not in to_rm: ans += val return ans # Time O(N) # Space O(N)  ","id":131,"section":"posts","summary":"LC 1249 Minimum Remove to Make Valid Parentheses Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string. Input: s = \u0026quot;lee(t(c)o)de)\u0026quot; Output: \u0026quot;lee(t(c)o)de\u0026quot; Explanation: \u0026quot;lee(t(co)de)\u0026quot; , \u0026quot;lee(t(c)ode)\u0026quot; would also be accepted. Solution 2020-09-05 Notes: 很简","tags":["leetcode","stack"],"title":"1249 Minimum Remove to Make Valid Parentheses","uri":"https://foxisawesome.github.io/posts/1249-minimum-remove-to-make-valid-parentheses/","year":"2020"},{"content":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Sam e\n  class Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: count = dict() stack = [] for l in s: count[l] = count.get(l,0) + 1 for c in s: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":132,"section":"posts","summary":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration.","tags":["leetcode"],"title":"316 Remove Dup Letters","uri":"https://foxisawesome.github.io/posts/316-remove-dup-letters/","year":"2020"},{"content":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Same as LC 316\n  class Solution: def smallestSubsequence(self, text: str) -\u0026gt; str: count = dict() stack = [] for l in text: count[l] = count.get(l,0) + 1 for c in text: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":133,"section":"posts","summary":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:   Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.","tags":["leetcode"],"title":"1081 Smallest Subsequence of Distinct Char","uri":"https://foxisawesome.github.io/posts/1081-smallest-subsequence-of-distinct-char/","year":"2020"},{"content":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing asLC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.get(nums[fast],0) + 1 if count[nums[fast]] \u0026lt;= 2: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":134,"section":"posts","summary":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing asLC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.","tags":["leetcode","two_pointers"],"title":"80 Remove Dup From Sorted Array II","uri":"https://foxisawesome.github.io/posts/80-remove-dup-from-sorted-array-ii/","year":"2020"},{"content":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.   Solution 2020-09-04 Notes:\n Two pointers: slow and fast. updates when fast == slow. Same thing asLC 80.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: slow, fast = 0, 1 while fast \u0026lt; len(nums): if nums[fast] != nums[slow]: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":135,"section":"posts","summary":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.","tags":["leetcode","two_pointers"],"title":"26 Remove Dup From Sorted Array","uri":"https://foxisawesome.github.io/posts/26-remove-dup-from-sorted-array/","year":"2020"},{"content":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes: K - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: nums.sort() return self.kSum(nums, target, 4) def kSum(self, nums: List[int], target: int, k: int) -\u0026gt; List[List[int]]: res = [] if len(nums)==0 or nums[0] * k \u0026gt; target or nums[-1] * k \u0026lt; target: return res if k == 2: return self.twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for _, val in enumerate(self.kSum(nums[i+1:], target-nums[i], k-1)): res.append([nums[i]] + val) return res def twoSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: res = [] lo, hi = 0, len(nums) - 1 while (lo \u0026lt; hi): sum = nums[lo] + nums[hi] if sum \u0026lt; target or (lo \u0026gt; 0 and nums[lo] == nums[lo - 1]): lo += 1 elif sum \u0026gt; target or (hi \u0026lt; len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res # Time O(N^(k-1)) # Space O(N)  ","id":136,"section":"posts","summary":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes: K - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):","tags":["leetcode"],"title":"18 K Sum","uri":"https://foxisawesome.github.io/posts/18-k-sum/","year":"2020"},{"content":"LC 140 Word Break II   Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\nInput: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ]   Solution 2020-09-03 Notes:  第一次尝试，哇！这不是和 word break 一摸一样嘛。照模版写了个bt如下，试了两个例子都过了。提交了才发现，严重超时。一看官方解答是dp做的，感叹要不怎么是medium，一题是hard呢。但我觉得我要能加上memo 跟下面的dfs应该是同理。 于是看了大牛的解答，带memo的recursion是可以过的  # backtracking, exceed time limit! class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) out = [] self.backtracking(s,wordDict,[],out,n) return out def backtracking(self, s, wordDict, path, out, n): m = len(s) if m == 0: out.append(\u0026quot; \u0026quot;.join(path)) return for i in range(m): if s[:i+1] in wordDict: path.append(s[:i+1]) for self.backtracking(s[i+1:], wordDict, path, out, n) path.pop() # Time O() # Space O()  recursion with memo:\n need to add () to this res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)). Otherwise, it will interperate as res.append((w + '') if not r else (\u0026quot; \u0026quot; + r))  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: res = [] memo = dict() return self.dfs(s,wordDict,memo) def dfs(self, s,wordDict,memo): if s in memo: return memo[s] if not s: return [\u0026quot;\u0026quot;] res = [] for w in wordDict: if s[:len(w)] == w: for r in self.dfs(s[len(w):], wordDict, memo): res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)) memo[s] = res return res  ","id":137,"section":"posts","summary":"LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] Solution 2020-09-03 Notes: 第一","tags":["leetcode","dp","recursion","backtracking","DFS"],"title":"140 Word Break II","uri":"https://foxisawesome.github.io/posts/140-word-break-ii/","year":"2020"},{"content":"LC 128 Longest Consecutive Sequence   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Solution 2020-09-03 Notes:\n  题目 time complexity 要求O(N)，那没其他办法只能 hash table做了，看了花花的视频， 没话说一讲就很简单了。\n  solution #1: 用dictionary做，key记录nums里的每个数，val=但这个数字的最长连续数字长度。查看num-1 和 num+1的val. online 求最长长度。\n  solution #2: 用set做, if num-1 not in the set, then num is the starting point of a consecutive list. Count the length until num+l not in the set. offline getting longest length.\n  class Solution: def longestConsecutive_solu1(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #1 h = dict() # key: num, val: consecutive length until key out = 0 for i in nums: if i in h: continue l = h[i-1] if i-1 in h else 0 r = h[i+1] if i+1 in h else 0 h[i] = h[i-l] = h[i+r] = l+r+1 out = max(out, h[i]) return out def longestConsecutive_solu2(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #2 h = set(nums) out = 0 for num in nums: if num-1 not in h: l = 1 while num+l in h: l += 1 out = max(out, l) return out # Time O(N) # Space O(N)  ","id":138,"section":"posts","summary":"LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: 题目 time complexity 要求O(N)，那没其","tags":["leetcode"],"title":"128 Longest Consecutive Sequence","uri":"https://foxisawesome.github.io/posts/128-longest-consecutive-sequence/","year":"2020"},{"content":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n Solution 2020-09-02 Notes:\n Height of a tree: max(left_height, right_height) + 1 width of a tree (diameter): max(left_height + right_height) Diameter needs to be calculated along the way in this case.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: if not root: return 0 self.diameter = 0 self.DFS(root) return self.diameter def DFS(self, root) -\u0026gt; int: # DFS returns the height if not root: return 0 L_height = self.DFS(root.left) R_height = self.DFS(root.right) self.diameter = max(self.diameter, L_height+R_height) return max(L_height, R_height) + 1 # Time O(N) # Space O(N)  ","id":139,"section":"posts","summary":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].","tags":["leetcode","tree"],"title":"543 Diameter of Binary Tree","uri":"https://foxisawesome.github.io/posts/543-diameter-of-binary-tree/","year":"2020"},{"content":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.\n  Algo #2: one pass, same time complexity. some details need to figure out.\n  rotation algo: r, c = c, n-r-1\n  row in range(n//2+n%2) and col in range(n//2)\n  while rotating the k, cycle from the last element: t[(k-1)%4]\n    class Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: n = len(matrix) # two-pass: 1. transpose; 2. reverse rows for i in range(n): for j in range(i,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() # one-pass: for i in range(n//2+n%2): for j in range(n//2): r, c = i, j t = [0]*4 for k in range(4): t[k] = matrix[r][c] r, c = c, n-r-1 for k in range(4): matrix[r][c] = t[(k-1)%4] r, c = c, n-r-1 # Time O(N^2) # Space O(1)  ","id":140,"section":"posts","summary":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.","tags":["leetcode"],"title":"48 Rotate Image","uri":"https://foxisawesome.github.io/posts/48-rotate-image/","year":"2020"},{"content":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).\nMore formally, the probability of picking index i is w[i] / sum(w).\n Solution 2020-09-02 Notes:\n first, construct cumulative sum / total sum list. binary search for the nearest element \u0026gt; rand.uniform(0,1). I used closed interval in binary search, hence return l. No == case, because the robablilty of element exactly equal to random draw is 0.  class Solution: import random def __init__(self, w: List[int]): self.w = w self.w_sum = [] wsum = 0 tot = sum(self.w) for i in w: wsum += i prob = wsum/tot self.w_sum.append(prob) def pickIndex(self) -\u0026gt; int: target = random.uniform(0,1) l, r = 0, len(self.w)-1 while l \u0026lt;= r: m = l + (r-l)//2 if self.w_sum[m] \u0026gt; target: r = m - 1 elif self.w_sum[m] \u0026lt; target: l = m + 1 return l # Time O(N) + O(logN) # Space O(N)  ","id":141,"section":"posts","summary":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.","tags":["leetcode"],"title":"528 Random Pick With Weight","uri":"https://foxisawesome.github.io/posts/528-random-pick-with-weight/","year":"2020"},{"content":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7   Solution 2020-09-02 Notes:\n Scan two linked lists first, using stack to store the node value. use the same LC 2 add two numbers to add them up from the end. Use LC 206 reverse linked list to store reversely along the way.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while stack1 and stack2: carry, r = divmod(stack1.pop() + stack2.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp stack = stack1 if stack1 else stack2 while stack: carry, r = divmod(stack.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp if carry != 0: temp = head head = ListNode(carry) head.next = temp return head # Time O(N) # Space O(1)  ","id":142,"section":"posts","summary":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists?","tags":["leetcode","linkedList"],"title":"445 Add Two Num II","uri":"https://foxisawesome.github.io/posts/445-add-two-num-ii/","year":"2020"},{"content":"LC 295 Find Median From Data Stream   Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Solution 2020-09-01 Notes:   Follow 了花花酱的solu#1。 python the heapq implementation is a bit messy, while involving max heapq. python heapq library default heap is min-heap. filp all nums to -num to a heap, then it becomes a max-heap. Recover while pop.\n  Algo 想法挺简单但很巧: 分两堆：small (max-heap) 在左，large (min-heap)在右。\n Step1: add number to small heap while num \u0026lt;= small[0] Step2: balancing two heaps, 0\u0026lt;=len(small)-len(large)\u0026lt;2    class MedianFinder: import heapq def __init__(self): self.large = [] # min heap, right heap self.small = [] # max heap, left heap def addNum(self, num: int) -\u0026gt; None: if not self.small or num \u0026lt;= -self.small[0] : #default heapq is min heap, use -1*num will turn it as max heapq heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # balance two heaps if len(self.small) \u0026lt; len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) - len(self.large) == 2: heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -\u0026gt; float: if len(self.small) == len(self.large): return (-self.small[0] + self.large[0])/2 else: return -self.small[0] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() # Time O(nlogn) # Space O(N)  ","id":143,"section":"posts","summary":"LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow 了花花酱的so","tags":["leetcode","heap"],"title":"295 Find Median From Data Stream","uri":"https://foxisawesome.github.io/posts/295-find-median-from-data-stream/","year":"2020"},{"content":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:  Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head l_tail = slow = fast = head while fast and fast.next: l_tail = slow slow = slow.next fast = fast.next.next l_tail.next = None l = self.sortList(head) r = self.sortList(slow) return self.mergeTwoSorted(l,r) def mergeTwoSorted(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = dummy = ListNode(0) while l1 and l2: if l1.val \u0026lt; l2.val: head.next = l1 l1 = l1.next else: head.next = l2 l2 = l2.next head = head.next head.next = l1 if l1 else l2 return dummy.next # Time O(nlogn): merge sort # Space O(1): actually not O(1), since recursion is not O(1)  ","id":144,"section":"posts","summary":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:  Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.","tags":["leetcode","linkedList"],"title":"148 Sort List","uri":"https://foxisawesome.github.io/posts/148-sort-list/","year":"2020"},{"content":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.   Solution 2020-09-01 Notes:\n classic DFS/backtracking problem. The biggest thing I\u0026rsquo;ve learnt from this: to return True/False instead of a list of retults. one needs to pass the true from bottom to top. Line 31-32 is doing this! Otherwise, if only line 23, on the the bottom DFS functions returns True, other lays return None.  class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: n = len(board) m = len(board[0]) directions = [[1,0], [-1,0], [0,1], [0,-1]] inits = [] for i in range(n): for j in range(m): if board[i][j] == word[0]: inits.append((i,j)) while inits: start = inits.pop() visited = set() visited.add(start) if self.dfs(board, word, directions, word[0], start, visited, m,n): return True return False def dfs(self, board, word, directions, path, point, visited,m,n): i, j = point[0], point[1] if path == word: return True for d in directions: x0, y0 = d[0], d[1] x1, y1 = x0+i, y0+j if 0\u0026lt;=x1\u0026lt;n and 0\u0026lt;=y1\u0026lt;m and (x1,y1) not in visited and board[x1][y1]==word[len(path)]: next_pt = (x1,y1) visited.add(next_pt) if self.dfs(board, word, directions, path+board[x1][y1],next_pt,visited,m,n): return True visited.remove(next_pt) # Time O(N*3^L), where L is the length of word # Space O(N)  ","id":145,"section":"posts","summary":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true.","tags":["leetcode","backtracking","DFS"],"title":"79 Word Search","uri":"https://foxisawesome.github.io/posts/79-word-search/","year":"2020"},{"content":"LC 981 Time Based Key Value Store   Create a timebased key-value store class TimeMap, that supports two operations.\n set(string key, string value, int timestamp)   Stores the key and value, along with the given timestamp.  get(string key, int timestamp)   Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).   Solution 2020-09-01 Notes:  抄了一遍：这个reference  class TimeMap: def __init__(self): self.v_ = collections.defaultdict(list) self.t_ = collections.defaultdict(list) def set(self, key: str, value: str, timestamp: int) -\u0026gt; None: self.t_[key].append(timestamp) self.v_[key].append(value) def get(self, key: str, timestamp: int) -\u0026gt; str: if key not in self.t_: return \u0026quot;\u0026quot; # bisect is efficient algo to search key i = bisect.bisect_right(self.t_[key], timestamp) if i: return self.v_[key][i-1] return \u0026quot;\u0026quot; # Your TimeMap object will be instantiated and called as such: # obj = TimeMap() # obj.set(key,value,timestamp) # param_2 = obj.get(key,timestamp)  ","id":146,"section":"posts","summary":"LC 981 Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are","tags":["leetcode"],"title":"981 Time Based Key Value Store","uri":"https://foxisawesome.github.io/posts/981-time-based-key-value-store/","year":"2020"},{"content":"LC 1041 Robot Bounded in Circle \n On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:\n \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n 2020-08-31 Notes:  没见过这种implementation。好经典的做法，二刷希望能刷出来。  class Solution: def isRobotBounded(self, instructions: str) -\u0026gt; bool: # north = 0, east = 1, south = 2, west = 3 directions = [[0,1],[1,0],[0,-1],[-1,0]] x = y = 0 idx = 0 for i in instructions: if i == 'L': idx = (idx + 3) % 4 elif i == 'R': idx = (idx + 1) % 4 else: x += directions[idx][0] y += directions[idx][1] return (x==0 and y==0) or idx != 0  ","id":147,"section":"posts","summary":"LC 1041 Robot Bounded in Circle On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in","tags":["leetcode"],"title":"1041 Robot Bounded in Circle","uri":"https://foxisawesome.github.io/posts/1041-robot-bounded-in-circle/","year":"2020"},{"content":"LC 957 Prison Cells \n There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can\u0026rsquo;t have two adjacent neighbors.)\nWe describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\n 2020-08-31 Notes:\n  这题做了好久，好多corner case没过。最后才明白：\n  cycle = 14\n  two cases:\n​\ta. head in the cycle of 14; days %= 14\n​\tb. head not in the cycle of 14. in this case, days = (days-1)%14,\n    class Solution: def nextDay(self, cells): cells_nd = [0] for i in range(1,len(cells)-1): if cells[i-1] == cells[i+1]: cells_nd.append(1) else: cells_nd.append(0) cells_nd.append(0) return cells_nd def prisonAfterNDays(self, cells: List[int], N: int) -\u0026gt; List[int]: if not cells: return [] if N == 0: return cells memo = dict() memo[str(cells[:])] = 0 n = len(cells) for d in range(1,N+1): cells = self.nextDay(cells) print(d,cells) if str(cells) in memo: cycle = d - memo[str(cells)] break memo[str(cells[:])] = d # cycle is always 14. But two cases: 1. head is in the cycle; 2. head is not in the cycle. if d \u0026lt; N: if memo[str(cells)]==0: # head in the cycle case days = (N)%cycle else: # head not in the cycle case. days = (N-1)%cycle for d in range(days): cells = self.nextDay(cells) return cells  ","id":148,"section":"posts","summary":"LC 957 Prison Cells There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the","tags":["leetcode"],"title":"957 Prison Cells","uri":"https://foxisawesome.github.io/posts/957-prison-cells/","year":"2020"},{"content":"LC 735 Aseroid Collision \n We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.  Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other.  Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.  Example 4:\nInput: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   2020-08-31 Notes:\n 一次就做对了如下。虽然不简洁，但能用上recursion，也算挺开心了。 一看官方解答，跟简洁，能combine 很多的case。而且最关键的：while+ continue+break的组合完美的绕开了recursion的做法。看了下时间比较差距不大。  class Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: stack = self.helper(stack, a) return stack def helper(self, stack, a): if not stack: stack.append(a) elif stack[-1] * a \u0026gt; 0 or stack[-1] \u0026lt; 0 and a \u0026gt; 0: stack.append(a) elif abs(stack[-1]) == abs(a): stack.pop() elif abs(stack[-1]) \u0026lt; abs(a): stack.pop() return self.helper(stack, a) return stack # Time O(N) # Space O(N)  官方解答：\nclass Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: while stack and a \u0026lt; 0 \u0026lt; stack[-1]: if stack[-1] \u0026lt; -a: stack.pop() continue elif stack[-1] == -a: stack.pop() break else: stack.append(a) return stack  ","id":149,"section":"posts","summary":"LC 735 Aseroid Collision We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size,","tags":["leetcode","recursion","stack"],"title":"735 Aseroid Collision","uri":"https://foxisawesome.github.io/posts/735-aseroid-collision/","year":"2020"},{"content":"LC 141 Linked List Cycle \n Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.   08/29/2020 Notes:\n Fast two steps at a time, slow pointer one step a time. 一次也就过了。  class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if not head: return slow = fast = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False  ","id":150,"section":"posts","summary":"LC 141 Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There","tags":["leetcode","linkedList"],"title":"141 Linked List Cycle","uri":"https://foxisawesome.github.io/posts/141-linked-list-cycle/","year":"2020"},{"content":"LC 328 Odd Even Linked List  Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL   Solution 2020-08-30 Notes: linked list 终于在周末刷出感觉了。这题也一遍就过了。\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return odd = p1 = ListNode(1) even = p2 = ListNode(0) count = 1 while head: if count % 2 == 1: odd.next = ListNode(head.val) odd = odd.next else: even.next = ListNode(head.val) even = even.next head = head.next count += 1 odd.next = p2.next return p1.next  ","id":151,"section":"posts","summary":"LC 328 Odd Even Linked List Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL Solution 2020-08-30 Notes: linked list 终","tags":["leetcode","linkedList"],"title":"328 Odd Even Linked List","uri":"https://foxisawesome.github.io/posts/328-odd-even-linked-list/","year":"2020"},{"content":"LC 1266 Minimum Time Visiting All Points  On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.   Solution 8-30-2020 Notes: 一遍就过的题，没啥好说的。\nclass Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -\u0026gt; int: n = len(points) m = len(points[0]) time = 0 if not points or n == 0 or m == 0: return time for i in range(1, n): x1, y1 = points[i-1] x2, y2 = points[i] time += max(abs(x1-x2), abs(y1-y2)) return time  ","id":152,"section":"posts","summary":"LC 1266 Minimum Time Visiting All Points On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points. You can move according to the next rules: In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in","tags":["leetcode"],"title":"1266 Minimum Time Visiting All Points","uri":"https://foxisawesome.github.io/posts/1266-minimum-time-visiting-all-points/","year":"2020"},{"content":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:\n BST has a property that: if in-order traverse, the output is a sorted list. Time complex is O(N), if store everything, then space complexity is O(N). I can only maintain min_diff in each root step to reduce space complexity to O(1). recursion here is pretty easy: standard in-order traversal recursion.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getMinimumDifference(self, root: TreeNode) -\u0026gt; int: self.prev = None self.min_diff = float('inf') self.inorder(root) return self.min_diff def inorder(self, root): if not root: return self.inorder(root.left) if self.prev is not None: self.min_diff = min(self.min_diff, root.val - self.prev) self.prev = root.val self.inorder(root.right)  ","id":153,"section":"posts","summary":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:","tags":["leetcode","tree","BST"],"title":"530 Min Abs Dif BST","uri":"https://foxisawesome.github.io/posts/530-min-abs-dif-bst/","year":"2020"},{"content":"LC 98 Valid BST\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  Solution 08/30/2020 Notes:  two ways: 1. Check if a sorted list returned after in-order traversal. 2. check if alway root.right.val \u0026gt; root.val \u0026gt; root.left.val I used the first way. 这又是个很高级的recursion。  class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: self.prev = None return self.inorder(root) def inorder(self, root): if not root: return True if not self.inorder(root.left): return False if self.prev is not None and root.val \u0026lt;= self.prev: return False self.prev = root.val return self.inorder(root.right)  ","id":154,"section":"posts","summary":"LC 98 Valid BST Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example","tags":["leetcode","tree","BST"],"title":"98 Valid BST","uri":"https://foxisawesome.github.io/posts/98-valid-bst/","year":"2020"},{"content":"LC 701\n Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5  You can return this binary search tree:\n 4 / \\ 2 7 / \\ / 1 3 5  This tree is also valid:\n 5 / \\ 2 7 / \\ 1 3 \\ 4   08/30/2020 Notes:\n 这个recursion 好高级，似懂非懂回头还得在刷。 一定要明确 resursion function return 的是什么。 这个return的是TreeNode。  9/10/2020 Note:\n刷了一阵tree之后终于搞懂了，给tree添加leaf node的操作是 root.left = TreeNode(val), 所以if not root: return root.val. 最后添加完之后就是return这个root 一层一层返回。\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def insertIntoBST(self, root: TreeNode, val: int) -\u0026gt; TreeNode: if not root: return TreeNode(val) if root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root  ","id":155,"section":"posts","summary":"LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST","tags":["leetcode","tree","BST"],"title":"701 Insert Into BST","uri":"https://foxisawesome.github.io/posts/701-insert-into-bst/","year":"2020"},{"content":"滑动窗口算法的思路是这样：\n1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)称为一个「窗口」。\n2、我们先不断地增加right指针扩大窗口[left, right)，直到窗口中的字符串符合要求（包含了T中的所有字符）。\n3、此时，我们停止增加right，转而不断增加left指针缩小窗口[left, right)，直到窗口中的字符串不再符合要求（不包含T中的所有字符了）。同时，每次增加left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到right到达字符串S的尽头。\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。\nrefrence: wx:labuladong\nCode Template:\ndef slidingWindow(s: str, t: str) -\u0026gt; str: target, window = {}, {} for i in t: target[i] = target.get(i,0) + 1 left, right, valid = 0, 0, 0 while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] # move right index right += 1 # 进行窗口内数据的一系列更新 ... # /*** debug 输出的位置 ***/ print('s: '+s2[left:right]+' window' + str(window) + ' valid: ' + str(valid)) # see if needs to shrink window while (window shrinking condition): d = s[left] left += 1 # 进行窗口内数据的一系列更新 ... return ...  ","id":156,"section":"posts","summary":"滑动窗口算法的思路是这样： 1、我们在字符串S中使用双指针中的左右指针技巧，初始化left = right = 0，把索引左闭右开区间[left, right)","tags":["template"],"title":"Sliding Window Note","uri":"https://foxisawesome.github.io/posts/sliding-window-note/","year":"2020"},{"content":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post!\nIt takes a while for me to get how exactly Linked List works. I used following utility functions to keep my leetcode solutions and run codes locally.\nNote:\n say head = ListNode(0), then head = head.next is to iterate to next node on the Linked List. use head.next = a to point to next node.  # My liked list utility functions: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def list2ListNode(list): head = LinkedList = ListNode(0) for i in range(len(list)): LinkedList.next = ListNode(list[i]) LinkedList = LinkedList.next return head.next def printListNode(p): head = ListNode(0) head.next = p out = [] while p: out.append(p.val) p = p.next return out # e.g.: indata = [1,2,3,4,5,6] head = ListNode.list2ListNode(indata) ListNode.printListNode(head)  ","id":157,"section":"posts","summary":"开始刷Leetcode 好几个月了，今天开始学很多人用blog 记录下自己的notes，也激励自己好好刷题！First post! It takes a while for me to get how exactly Linked List","tags":["template","linkedList"],"title":"Linked List Note (First Post)","uri":"https://foxisawesome.github.io/posts/linked-list-note/","year":"2020"},{"content":"LC 917 Reverse Only Letters   Given a string S, return the \u0026ldquo;reversed\u0026rdquo; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.\n Solution 2020-08-29 Notes: class Solution: def reverseOnlyLetters(self, S: str) -\u0026gt; str: if not S: return '' out = list(S) n = len(S) l, r = 0, n-1 while l \u0026lt; r: if not S[l].isalpha() and not S[r].isalpha(): l += 1 r -= 1 elif not S[l].isalpha() and S[r].isalpha() : l += 1 elif S[l].isalpha() and not S[r].isalpha() : r -= 1 else: out[l], out[r] = out[r], out[l] l += 1 r -= 1 return ''.join(out) # Time O(N) # Space O(1)  ","id":158,"section":"posts","summary":"LC 917 Reverse Only Letters   Given a string S, return the \u0026ldquo;reversed\u0026rdquo; string where all characters that are not a letter stay in the same place, and all letters reverse their positions.\n Solution 2020-08-29 Notes: class Solution: def reverseOnlyLetters(self, S: str) -\u0026gt; str: if not S: return '' out = list(S) n = len(S) l, r = 0, n-1 while l \u0026lt; r: if not S[l].isalpha() and not S[r].","tags":["leetcode","two_pointers"],"title":"917 Reverse Only Letters","uri":"https://foxisawesome.github.io/posts/917-reverse-only-letters/","year":"2020"},{"content":"LC 50 Powx N   Implement pow(x, n), which calculates x raised to the power n (i.e. x^n).\n Solution 2020-09-25 Notes:  一个月水平进化了一点。  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: return self.myPow(1/x,abs(n)) if n == 0: return 1 if n % 2 ==0: ans = self.myPow(x,n//2) ** 2 else: ans = x * self.myPow(x, n//2) ** 2 return ans # Time O(logN) # Space O(1)  2020-08-28 Notes:  一遍就过了, 二分法的思想  class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: x = 1/x n = -n return self.doubleup(x,n) def doubleup(self,x,n): if n == 0: return 1 half = self.doubleup(x,n//2) if n % 2 == 0: return half * half else: return half * half * x  ","id":159,"section":"posts","summary":"LC 50 Powx N Implement pow(x, n), which calculates x raised to the power n (i.e. x^n). Solution 2020-09-25 Notes: 一个月水平进化了一点。 class Solution: def myPow(self, x: float, n: int) -\u0026gt; float: if n \u0026lt; 0: return self.myPow(1/x,abs(n)) if n == 0: return 1 if n % 2 ==0: ans = self.myPow(x,n//2) ** 2 else: ans = x * self.myPow(x, n//2)","tags":["leetcode","recursion"],"title":"50 Powx N","uri":"https://foxisawesome.github.io/posts/50-powx-n/","year":"2020"},{"content":"本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。\nLeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。\n本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：\nunordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。\n可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。\n所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。\n本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。\n一、最小覆盖子串 题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。\n如果我们使用暴力解法，代码大概是这样的：\nfor (int i = 0; i \u0026lt; s.size(); i++) for (int j = i + 1; j \u0026lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案  思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。\n滑动窗口算法的思路是这样：\n1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。\n2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。\n这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。**左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。\n下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。\n初始状态：\n增加 right，直到窗口 [left, right] 包含了 T 中所有字符：\n现在开始增加 left，缩小窗口 [left, right]。\n直到窗口中的字符串不再符合要求，left 不再继续移动。\n之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。\n如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。\n上述过程可以简单地写出如下伪码框架：\nstring s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; while(right \u0026lt; s.size()) { window.add(s[right]); right++; // 如果符合要求，移动 left 缩小窗口 while (window 符合要求) { // 如果这个窗口的子串更短，则更新 res res = minLen(res, window); window.remove(s[left]); left++; } } return res;  如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left\u0026hellip;right] 是否符合要求，是否包含 t 的所有字符呢？\n可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。\n现在将上面的框架继续细化：\nstring s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; // 相当于两个计数器 unordered_map\u0026lt;char, int\u0026gt; window; unordered_map\u0026lt;char, int\u0026gt; needs; for (char c : t) needs[c]++; // 记录 window 中已经有多少字符符合要求了 int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; // 加入 window if (window[c1] == needs[c1]) // 字符 c1 的出现次数符合要求了 match++; } right++; // window 中的字符串已符合 needs 的要求了 while (match == needs.size()) { // 更新结果 res res = minLen(res, window); char c2 = s[left]; if (needs.count(c2)) { window[c2]--; // 移出 window if (window[c2] \u0026lt; needs[c2]) // 字符 c2 出现次数不再符合要求 match--; } left++; } } return res;  上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！\nstring minWindow(string s, string t) { // 记录最短子串的开始位置和长度 int start = 0, minLen = INT_MAX; int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; window; unordered_map\u0026lt;char, int\u0026gt; needs; for (char c : t) needs[c]++; int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; if (window[c1] == needs[c1]) match++; } right++; while (match == needs.size()) { if (right - left \u0026lt; minLen) { // 更新最小子串的位置和长度 start = left; minLen = right - left; } char c2 = s[left]; if (needs.count(c2)) { window[c2]--; if (window[c2] \u0026lt; needs[c2]) match--; } left++; } } return minLen == INT_MAX ? \u0026quot;\u0026quot; : s.substr(start, minLen); }  如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？\n这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。\n读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。\n二、找到字符串中所有字母异位词 这道题的难度是 Easy，但是评论区点赞最多的一条是这样：\nHow can this problem be marked as easy???\n实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解：\nvector\u0026lt;int\u0026gt; findAnagrams(string s, string t) { // 用数组记录答案 vector\u0026lt;int\u0026gt; res; int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; needs; unordered_map\u0026lt;char, int\u0026gt; window; for (char c : t) needs[c]++; int match = 0; while (right \u0026lt; s.size()) { char c1 = s[right]; if (needs.count(c1)) { window[c1]++; if (window[c1] == needs[c1]) match++; } right++; while (match == needs.size()) { // 如果 window 的大小合适 // 就把起始索引 left 加入结果 if (right - left == t.size()) { res.push_back(left); } char c2 = s[left]; if (needs.count(c2)) { window[c2]--; if (window[c2] \u0026lt; needs[c2]) match--; } left++; } } return res; }  因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。\n三、无重复字符的最长子串 遇到子串问题，首先想到的就是滑动窗口技巧。\n类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复：\nint lengthOfLongestSubstring(string s) { int left = 0, right = 0; unordered_map\u0026lt;char, int\u0026gt; window; int res = 0; // 记录最长长度 while (right \u0026lt; s.size()) { char c1 = s[right]; window[c1]++; right++; // 如果 window 中出现重复字符 // 开始移动 left 缩小窗口 while (window[c1] \u0026gt; 1) { char c2 = s[left]; window[c2]--; left++; } res = max(res, right - left); } return res; }  需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。\n最后总结 通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：\nint left = 0, right = 0; while (right \u0026lt; s.size()) { window.add(s[right]); right++; while (valid) { window.remove(s[left]); left++; } }  其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。\n稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～\nJiajun 提供最小覆盖子串 Python3 代码：\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: # 最短子串开始位置和长度 start, min_len = 0, float('Inf') left, right = 0, 0 res = s # 两个计数器 needs = Counter(t) window = collections.defaultdict(int) # defaultdict在访问的key不存在的时候返回默认值0, 可以减少一次逻辑判断 match = 0 while right \u0026lt; len(s): c1 = s[right] if needs[c1] \u0026gt; 0: window[c1] += 1 if window[c1] == needs[c1]: match += 1 right += 1 while match == len(needs): if right - left \u0026lt; min_len: # 更新最小子串长度 min_len = right - left start = left c2 = s[left] if needs[c2] \u0026gt; 0: window[c2] -= 1 if window[c2] \u0026lt; needs[c2]: match -= 1 left += 1 return s[start:start+min_len] if min_len != float(\u0026quot;Inf\u0026quot;) else \u0026quot;\u0026quot;  ","id":160,"section":"posts","summary":"本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是","tags":["sliding_window"],"title":"滑动窗口技巧","uri":"https://foxisawesome.github.io/posts/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7/","year":"2020"},{"content":"LC 42 Trapping Rain Water   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n Solution 2020-08-05 Notes:\n 短边原理，左右指针同时走，r_max 大时短边在left，所以计算left side。 每一格计算下相较于短边的容水量即可  左右指针的 while loop，设为 l\u0026lt;=r 或者 了l\u0026lt;r 都一样，因为l=r跳出时只可能r_max = l_max = height[r]=height[l], water=0.    class Solution: def trap(self, height: List[int]) -\u0026gt; int: if not height: return 0 l, r = 0, len(height)-1 l_max, r_max = height[0], height[-1] ans = 0 while l \u0026lt; r: l_max = max(l_max, height[l]) r_max = max(r_max, height[r]) if l_max \u0026lt; r_max: ans += l_max - height[l] l += 1 else: ans += r_max - height[r] r -= 1 return ans # Time O(N) # Space O(1)  ","id":161,"section":"posts","summary":"LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: 短边原理，左右指针同时走，r_max 大时短边在left，所以计算lef","tags":["leetcode"],"title":"42 Trapping Rain Water","uri":"https://foxisawesome.github.io/posts/42-trapping-rain-water/","year":"2020"},{"content":"LC 206 Reverse Linked List   Reverse a singly linked list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   Solution 2020-09-01 Notes:\n  这题刷了不下10遍了，终于明白iteration这里的四步操作了。\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: # iteration def reverseList_iter(self, head: ListNode) -\u0026gt; ListNode: if not head: return None prev = None curr = head while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev # Time O(N) for iteration # Space O(1)   recursion的做法还是似懂非懂，还得再看看。感觉TreeNode, ListNode 的recursion 都是if not head/root: return head/root。 另外，recession 这里返回的是 以head.next为头reversed 的list，只需要再把head.next\t reverse 下就好了。  2020-9-12 Notes:\n睡了个午觉，顿悟了这个解法。\ninput: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 head head.next line#4: 1 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2 head p head.next line#5: 4 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1 p head.next head  # recursion def reverseList_rec(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p  可是这道题的进化版好难：LC 92\n","id":162,"section":"posts","summary":"LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL Solution 2020-09-01 Notes: 这题刷了不下10遍了，终于明白iteration这里的四步操作了。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next","tags":["leetcode","linkedList"],"title":"206 Reverse Linked List","uri":"https://foxisawesome.github.io/posts/206-reverse-linked-list/","year":"2020"},{"content":"这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。\n废话不多说，直接上回溯算法框架。解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。\n代码方面，回溯算法的框架：\nresult = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择  其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。\n什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！\n一、全排列问题 我们在高中的时候就做过排列组合的数学题，我们也知道 n 个不重复的数，全排列共有 n! 个。\nPS：为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字。\n那么我们当时是怎么穷举全排列的呢？比方说给三个数 [1,2,3]，你肯定不会无规律地乱穷举，一般是这样：\n先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……\n其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：\n只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。\n为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上：\n你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。\n现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。\n如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：\n我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列。\n再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前「学习数据结构的框架思维」写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：\nvoid traverse(TreeNode root) { for (TreeNode child : root.childern) // 前序遍历需要的操作 traverse(child); // 后序遍历需要的操作 }  而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：\n前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。\n回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：\n现在，你是否理解了回溯算法的这段核心框架？\nfor 选择 in 选择列表: # 做选择 将该选择从选择列表移除 路径.add(选择) backtrack(路径, 选择列表) # 撤销选择 路径.remove(选择) 将该选择再加入选择列表  我们只要在递归之前做出选择，在递归之后撤销刚才的选择，就能正确得到每个节点的选择列表和路径。\n下面，直接看全排列代码：\nList\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new LinkedList\u0026lt;\u0026gt;(); /* 主函数，输入一组不重复的数字，返回它们的全排列 */ List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { // 记录「路径」 LinkedList\u0026lt;Integer\u0026gt; track = new LinkedList\u0026lt;\u0026gt;(); backtrack(nums, track); return res; } // 路径：记录在 track 中 // 选择列表：nums 中不存在于 track 的那些元素 // 结束条件：nums 中的元素全都在 track 中出现 void backtrack(int[] nums, LinkedList\u0026lt;Integer\u0026gt; track) { // 触发结束条件 if (track.size() == nums.length) { res.add(new LinkedList(track)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { // 排除不合法的选择 if (track.contains(nums[i])) continue; // 做选择 track.add(nums[i]); // 进入下一层决策树 backtrack(nums, track); // 取消选择 track.removeLast(); } }  我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 nums 和 track 推导出当前的选择列表：\n至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，因为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。\n但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。\n明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。\n二、N 皇后问题 这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。\nPS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。\n这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。\n直接套用框架:\nvector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; /* 输入棋盘边长 n，返回所有合法的放置 */ vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { // '.' 表示空，'Q' 表示皇后，初始化空棋盘。 vector\u0026lt;string\u0026gt; board(n, string(n, '.')); backtrack(board, 0); return res; } // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后一行 void backtrack(vector\u0026lt;string\u0026gt;\u0026amp; board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int n = board[row].size(); for (int col = 0; col \u0026lt; n; col++) { // 排除不合法选择 if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = 'Q'; // 进入下一行决策 backtrack(board, row + 1); // 撤销选择 board[row][col] = '.'; } }  这部分主要代码，其实跟全排列问题差不多，isValid 函数的实现也很简单：\n/* 是否可以在 board[row][col] 放置皇后？ */ bool isValid(vector\u0026lt;string\u0026gt;\u0026amp; board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i \u0026lt; n; i++) { if (board[i][col] == 'Q') return false; } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == 'Q') return false; } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == 'Q') return false; } return true; }  函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：\n如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。\n当 N = 8 时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。\n不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 isValid 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 N = 10 的时候，计算就已经很耗时了。\n有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。\n其实特别简单，只要稍微修改一下回溯算法的代码即可：\n// 函数找到一个答案后就返回 true bool backtrack(vector\u0026lt;string\u0026gt;\u0026amp; board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return true; } ... for (int col = 0; col \u0026lt; n; col++) { ... board[row][col] = 'Q'; if (backtrack(board, row + 1)) return true; board[row][col] = '.'; } return false; }  这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？\n三、最后总结 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：\ndef backtrack(...): for 选择 in 选择列表: 做选择 backtrack(...) 撤销选择  写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。\n其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？\n某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。\n致力于把算法讲清楚！欢迎关注我的微信公众号 labuladong，查看更多通俗易懂的文章：\nZongshuai 提供全排列 Python3解法代码：\nclass Solution: def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: # 回溯算法 result = [] track = [] # 可行路径 def trackBack(nums_, track_): if len(track_) == len(nums_): # 满足终止条件 result.append(track_[:]) return for i in nums_: #所有可选项 if i in track_: # 判断是否可选 continue track.append(i) # 选择 trackBack(nums_, track_) # 递归 track.pop() # 回溯 trackBack(nums, track) return result  上一篇：动态规划答疑篇\n下一篇：二分查找解题框架\n目录\n","id":163,"section":"posts","summary":"这篇文章是很久之前的一篇《回溯算法详解》的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套","tags":["backtracking"],"title":"回溯算法详解","uri":"https://foxisawesome.github.io/posts/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88/","year":"2020"},{"content":"LC 2 Add Two Num   You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807.   Solution 2020-07-02 Notes:  比较简单，但是 don’t forget line 17 and 25。  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: head = out = ListNode(0) carry = 0 while l1 and l2: carry, m = divmod(l1.val + l2.val + carry, 10) out.next = ListNode(m) l1 = l1.next l2 = l2.next out = out.next l = l1 if l1 else l2 while l: carry, m = divmod(l.val + carry, 10) out.next = ListNode(m) out = out.next l = l.next if carry \u0026gt; 0: out.next = ListNode(carry) return head.next # Time O(N) # Space O(1)  ","id":164,"section":"posts","summary":"LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt;","tags":["leetcode","linkedList"],"title":"2 Add Two Num","uri":"https://foxisawesome.github.io/posts/2-add-two-num/","year":"2020"},{"content":"LC 169 Majority Element   Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\nYou may assume that the array is non-empty and the majority element always exist in the array.\n Solution 2020-09-24 Notes:  这道题有很多种方法做。  hash table做法。\nclass Solution: def majorityElement(self, nums: List[int]) -\u0026gt; int: d = dict() n = len(nums) target = n//2 for i in nums: d[i] = d.get(i,0) + 1 if d[i] \u0026gt; target: return i # Time O(N) # Space O(N)  sort\nclass Solution: def majorityElement(self, nums): nums.sort() return nums[len(nums)//2] # Time O(NlogN) # Space O(1)  还有divide and concur 等。\n","id":165,"section":"posts","summary":"LC 169 Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Solution 2020-09-24 Notes: 这道题有很多种方法做。 hash table做法。 class Solution:","tags":["leetcode","hashtable"],"title":"169 Majority Element","uri":"https://foxisawesome.github.io/posts/169-majority-element/","year":"2020"},{"content":"LC 204 Count Primes   Count the number of prime numbers less than a non-negative number, **n**.\n Solution 2020-09-12 Notes:   In mathematics, the sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.\n  class Solution: def countPrimes(self, n: int) -\u0026gt; int: if n \u0026lt; 2: return 0 grid = [1] * n grid[0] = 0 grid[1] = 0 for i in range(2,int(n**0.5)+1): if grid[i] == 0: continue for j in range(i*i, n, i): grid[j] = 0 return sum(grid) # Time O(NloglogN)?? # Space O(N)  ","id":166,"section":"posts","summary":"LC 204 Count Primes   Count the number of prime numbers less than a non-negative number, **n**.\n Solution 2020-09-12 Notes:   In mathematics, the sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.\n  class Solution: def countPrimes(self, n: int) -\u0026gt; int: if n \u0026lt; 2: return 0 grid = [1] * n grid[0] = 0 grid[1] = 0 for i in range(2,int(n**0.","tags":["leetcode","math"],"title":"204 Count Primes","uri":"https://foxisawesome.github.io/posts/204-count-primes/","year":"2020"},{"content":"LC 69 Sqrtx   Implement int sqrt(int x).\nSqrt(8) = 2\n Solution 2020-03-07 Notes:\n 标准的binary search 模版， right 从x//2开始。  class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x: return mid elif mid**2 \u0026gt; x: right = mid -1 elif mid**2 \u0026lt; x: left = mid + 1 # exit at [right, left], hence return right return right # Time O(logN) # Space O(1)  ","id":167,"section":"posts","summary":"LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: 标准的binary search 模版， right 从x//2开始。 class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x:","tags":["leetcode","binary_Search"],"title":"69 Sqrtx","uri":"https://foxisawesome.github.io/posts/69-sqrtx/","year":"2020"},{"content":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","id":168,"section":"posts","summary":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","tags":["leetcode","array","hashtable"],"title":"1 Two Sum","uri":"https://foxisawesome.github.io/posts/1-two-sum/","year":"2020"},{"content":"前缀和技巧 今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。\n那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行了。\n关键是，如何快速得到某个子数组的和呢，比如说给你一个数组 nums，让你实现一个接口 sum(i, j)，这个接口要返回 nums[i..j] 的和，而且会被多次调用，你怎么实现这个接口呢？\n因为接口要被多次调用，显然不能每次都去遍历 nums[i..j]，有没有一种快速的方法在 O(1) 时间内算出 nums[i..j] 呢？这就需要前缀和技巧了。\n一、什么是前缀和 前缀和的思路是这样的，对于一个给定的数组 nums，我们额外开辟一个前缀和数组进行预处理：\nint n = nums.length; // 前缀和数组 int[] preSum = new int[n + 1]; preSum[0] = 0; for (int i = 0; i \u0026lt; n; i++) preSum[i + 1] = preSum[i] + nums[i];  这个前缀和数组 preSum 的含义也很好理解，preSum[i] 就是 nums[0..i-1] 的和。那么如果我们想求 nums[i..j] 的和，只需要一步操作 preSum[j+1]-preSum[i] 即可，而不需要重新去遍历数组了。\n回到这个子数组问题，我们想求有多少个子数组的和为 k，借助前缀和技巧很容易写出一个解法：\nint subarraySum(int[] nums, int k) { int n = nums.length; // 构造前缀和 int[] sum = new int[n + 1]; sum[0] = 0; for (int i = 0; i \u0026lt; n; i++) sum[i + 1] = sum[i] + nums[i]; int ans = 0; // 穷举所有子数组 for (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; i; j++) // sum of nums[j..i-1] if (sum[i] - sum[j] == k) ans++; return ans; }  这个解法的时间复杂度 $O(N^2)$ 空间复杂度 $O(N)$，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。\n二、优化解法 前面的解法有嵌套的 for 循环：\nfor (int i = 1; i \u0026lt;= n; i++) for (int j = 0; j \u0026lt; i; j++) if (sum[i] - sum[j] == k) ans++;  第二层 for 循环在干嘛呢？翻译一下就是，**在计算，有几个 j 能够使得 sum[i] 和 sum[j] 的差为 k。**毎找到一个这样的 j，就把结果加一。\n我们可以把 if 语句里的条件判断移项，这样写：\nif (sum[j] == sum[i] - k) ans++;  优化的思路是：我直接记录下有几个 sum[j] 和 sum[i] - k 相等，直接更新结果，就避免了内层的 for 循环。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。\nint subarraySum(int[] nums, int k) { int n = nums.length; // map：前缀和 -\u0026gt; 该前缀和出现的次数 HashMap\u0026lt;Integer, Integer\u0026gt; preSum = new HashMap\u0026lt;\u0026gt;(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i \u0026lt; n; i++) { sum0_i += nums[i]; // 这是我们想找的前缀和 nums[0..j] int sum0_j = sum0_i - k; // 如果前面有这个前缀和，则直接更新答案 if (preSum.containsKey(sum0_j)) ans += preSum.get(sum0_j); // 把前缀和 nums[0..i] 加入并记录出现次数 preSum.put(sum0_i, preSum.getOrDefault(sum0_i, 0) + 1); } return ans; }  比如说下面这个情况，需要前缀和 8 就能找到和为 k 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。\n这样，就把时间复杂度降到了 $O(N)$，是最优解法了。\n三、总结 前缀和不难，却很有用，主要用于处理数组区间的问题。\n比如说，让你统计班上同学考试成绩在不同分数段的百分比，也可以利用前缀和技巧：\nint[] scores; // 存储着所有同学的分数 // 试卷满分 150 分 int[] count = new int[150 + 1] // 记录每个分数有几个同学 for (int score : scores) count[score]++ // 构造前缀和 for (int i = 1; i \u0026lt; count.length; i++) count[i] = count[i] + count[i-1];  这样，给你任何一个分数段，你都能通过前缀和相减快速计算出这个分数段的人数，百分比也就很容易计算了。\n但是，稍微复杂一些的算法问题，不止考察简单的前缀和技巧。比如本文探讨的这道题目，就需要借助前缀和的思路做进一步的优化，借助哈希表去除不必要的嵌套循环。可见对题目的理解和细节的分析能力对于算法的优化是至关重要的。\n希望本文对你有帮助。\n坚持原创高质量文章，致力于把算法问题讲清楚，欢迎关注我的公众号 labuladong 获取最新文章：\nlabuladong 提供JAVA解法代码：\nint subarraySum(int[] nums, int k) { int n = nums.length; // map：前缀和 -\u0026gt; 该前缀和出现的次数 HashMap\u0026lt;Integer, Integer\u0026gt; preSum = new HashMap\u0026lt;\u0026gt;(); // base case preSum.put(0, 1); int ans = 0, sum0_i = 0; for (int i = 0; i \u0026lt; n; i++) { sum0_i += nums[i]; // 这是我们想找的前缀和 nums[0..j] int sum0_j = sum0_i - k; // 如果前面有这个前缀和，则直接更新答案 if (preSum.containsKey(sum0_j)) ans += preSum.get(sum0_j); // 把前缀和 nums[0..i] 加入并记录出现次数 preSum.put(sum0_i, preSum.getOrDefault(sum0_i, 0) + 1); } return ans; }  Jinglun Zhou 提供C++解法代码：\nclass Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n=nums.size(); unordered_map\u0026lt;int,int\u0026gt; preSum; // map: 前缀和 -\u0026gt; 该前缀和出现的次数 preSum[0]=1; // base case: 例如当数组中只有一个元素， 而k恰好等于这个元素 int ans=0, sum0_i=0; // sum0_i 表示前缀和 nums[0...i] for(int i=0;i\u0026lt;n;i++) { sum0_i +=nums[i]; // 这是我们想找的前缀和 nums[0...j] int sum0_j=sum0_i-k; // 如果前面有这个前缀和，则直接更新答案 if(preSum.count(sum0_j)) ans+=preSum[sum0_j]; //把前缀和 nums[0...i] 加入并记录出现次数 preSum[sum0_i]++; // 把当前的前缀和加入到map中 } return ans; } };  上一篇：烧饼排序\n下一篇：字符串乘法\n目录\n","id":169,"section":"posts","summary":"前缀和技巧 今天来聊一道简单却十分巧妙的算法问题：算出一共有几个和为 k 的子数组。 那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 k 不就行","tags":null,"title":"","uri":"https://foxisawesome.github.io/posts/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7/","year":"0001"}],"tags":[{"title":"array","uri":"https://foxisawesome.github.io/tags/array/"},{"title":"backtracking","uri":"https://foxisawesome.github.io/tags/backtracking/"},{"title":"BFS","uri":"https://foxisawesome.github.io/tags/bfs/"},{"title":"binary_search","uri":"https://foxisawesome.github.io/tags/binary_search/"},{"title":"BST","uri":"https://foxisawesome.github.io/tags/bst/"},{"title":"DFS","uri":"https://foxisawesome.github.io/tags/dfs/"},{"title":"dia","uri":"https://foxisawesome.github.io/tags/dia/"},{"title":"dp","uri":"https://foxisawesome.github.io/tags/dp/"},{"title":"GRAPH","uri":"https://foxisawesome.github.io/tags/graph/"},{"title":"hashtable","uri":"https://foxisawesome.github.io/tags/hashtable/"},{"title":"heap","uri":"https://foxisawesome.github.io/tags/heap/"},{"title":"leetcode","uri":"https://foxisawesome.github.io/tags/leetcode/"},{"title":"linkedList","uri":"https://foxisawesome.github.io/tags/linkedlist/"},{"title":"math","uri":"https://foxisawesome.github.io/tags/math/"},{"title":"matrix","uri":"https://foxisawesome.github.io/tags/matrix/"},{"title":"recursion","uri":"https://foxisawesome.github.io/tags/recursion/"},{"title":"sliding_window","uri":"https://foxisawesome.github.io/tags/sliding_window/"},{"title":"sort","uri":"https://foxisawesome.github.io/tags/sort/"},{"title":"stack","uri":"https://foxisawesome.github.io/tags/stack/"},{"title":"string","uri":"https://foxisawesome.github.io/tags/string/"},{"title":"template","uri":"https://foxisawesome.github.io/tags/template/"},{"title":"tree","uri":"https://foxisawesome.github.io/tags/tree/"},{"title":"two_pointers","uri":"https://foxisawesome.github.io/tags/two_pointers/"}]}