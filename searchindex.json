{"categories":[{"title":"algo","uri":"https://foxisawesome.github.io/categories/algo/"},{"title":"ml","uri":"https://foxisawesome.github.io/categories/ml/"},{"title":"sql","uri":"https://foxisawesome.github.io/categories/sql/"}],"posts":[{"content":"LC 312 Burst Balloons   Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\nFind the maximum coins you can collect by bursting the balloons wisely.\nInput: [3,1,5,8] Output: 167 Explanation: nums = [3,1,5,8] --\u0026gt; [3,5,8] --\u0026gt; [3,8] --\u0026gt; [8] --\u0026gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167   Solution 2020-09-10 Notes:\nå¹¼ç¨šçš„ä¸€åˆ·ï¼Œèƒ½è§£å¯¹ä½†æ˜¯ETL. ç”¨äº†memoï¼š\n [1] +nums+[1] å°trickå¯ä»¥ç®€åŒ–è¾¹ç•Œæ¡ä»¶ã€‚ track åŒºé—´çš„indexåº”è¯¥èƒ½ä¼˜åŒ–ä¸å°‘ã€‚  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() return self.dfs(nums) def dfs(self, nums): if not nums: return 0 if str(nums) in self.memo: return self.memo[str(nums)] temp = [] nums = [1] + nums + [1] n = len(nums) for i in range(1,n-1): new_nums = nums[1:i]+nums[i+1:n-1] temp.append(nums[i]*nums[i-1]*nums[i+1] + self.dfs(new_nums)) self.memo[str(nums)] = max(temp) return self.memo[str(nums)] # Time O(N!) ?? # Space O()  çœ‹äº†ç­”æ¡ˆï¼Œä¼˜åŒ–äº†ä¸€ä¸‹ï¼š\næœ€å…³é”®çš„å…¬å¼æ˜¯ï¼šnums[i-1]*nums[k]*nums[j+1]: å«ä¹‰å¦‚ä¸‹\n  Dfs(i,j) return çš„æ˜¯åˆºç ´[i,j]åŒºé—´ä¸Šæ‰€æœ‰æ°”çƒåå¾—åˆ°çš„æœ€å¤§å€¼ï¼Œå‰ææ—¶æ‰€æœ‰æ°”çƒéƒ½ç ´äº†ã€‚\n  åœ¨[i,j]åŒºé—´ä¸Šï¼Œå‡è®¾ [i,k-1], å’Œ [k+1,j] å·²ç»è¢«æœ€ä¼˜åˆºç ´ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„æœ€åä¸€ä¸ªk-th æ°”çƒè¢«åˆºç ´æ—¶ï¼Œå€¼å°±ä¸ºnums[i-1]*nums[k]*nums[j+1]ã€‚æ˜¯top-downçš„recursionã€‚\n  class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 self.memo = dict() nums = [1] + nums + [1] return self.dfs(nums,1,len(nums)-2) def dfs(self, nums, i, j): if not nums: return 0 if (i,j) in self.memo: return self.memo[(i,j)] ans = 0 for k in range(i,j+1): ans = max(ans, self.dfs(nums,i,k-1) + nums[i-1]*nums[k]*nums[j+1] + self.dfs(nums,k+1,j)) self.memo[(i,j)] = ans return self.memo[(i,j)] # Time O(N^3) # Space O(N^2)  ","id":0,"section":"posts","summary":"LC 312 Burst Balloons Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum","tags":["leetcode","dp","recursion"],"title":"312 Burst Balloons","uri":"https://foxisawesome.github.io/312-burst-balloons/","year":"2020"},{"content":"LC 110 Balanced Binary Tree   Given a binary tree, determine if it is height-balanced.\nFor this problem, a height-balanced binary tree is defined as:\n a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n Given the following tree [3,9,20,null,null,15,7]:Return true.\n 3 / \\ 9 20 / \\ 15 7  Given the following tree [1,2,2,3,3,null,null,4,4]:Return false.\n 1 / \\ 2 2 / \\ 3 3 / \\ 4 4   Solution 2020-09-10 Notes:\n Time complexity is O(NlogN), è¿™ä¸ªèŠ±èŠ±è®²äº†åŸå› ä¸æ˜¯å¾ˆæ‡‚ å…¶å®isBalance()è¾“å‡ºçš„æ—¶ éœ€è¦åˆ¤æ–­left child and right child if existed.å¦åˆ™å·¦å³æ˜¯ä¸¤æ¡å•é“¾çš„æƒ…å†µä¸èƒ½è¿‡ã€‚  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -\u0026gt; bool: if not root: return True l = self.treeHeight(root.left) r = self.treeHeight(root.right) return (abs(l-r) \u0026lt; 2) and self.isBalanced(root.left) and self.isBalanced(root.right) def treeHeight(self,root): if not root: return 0 l = self.treeHeight(root.left) r = self.treeHeight(root.right) return max(l,r) + 1 # Time O(NlogN) # Space O(H)  ","id":1,"section":"posts","summary":"LC 110 Balanced Binary Tree Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Given the following tree [3,9,20,null,null,15,7]:Return true. 3 / \\ 9 20 / \\ 15 7 Given the following tree [1,2,2,3,3,null,null,4,4]:Return false. 1 / \\ 2","tags":["leetcode","tree"],"title":"110 Balanced Binary Tree","uri":"https://foxisawesome.github.io/110-balanced-binary-tree/","year":"2020"},{"content":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7] Output: true Explanation: We flipped at nodes with values 1, 3, and 5.   Solution 2020-09-10 Notes:\n Pretty similar to symetric tree. need to judge flipping or not flipping cases  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def flipEquiv(self, root1: TreeNode, root2: TreeNode) -\u0026gt; bool: if not root1 and not root2: return True if not root1 or not root2: return False # flipping l1 = self.flipEquiv(root1.left, root2.right) r1 = self.flipEquiv(root1.right, root2.left) # not flipping l2 = self.flipEquiv(root1.left, root2.left) r2 = self.flipEquiv(root1.right, root2.right) return root1.val == root2.val and ((l1 and r1) or (l2 and r2)) # Time O(N) # Space O(logN)  ","id":2,"section":"posts","summary":"LC 951 Flip Equivalent Binary Trees   For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivelent or false otherwise.","tags":["leetcode","tree"],"title":"951 Flip Equivalent Binary Trees","uri":"https://foxisawesome.github.io/951-flip-equivalent-binary-trees/","year":"2020"},{"content":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case. need to create a mirror() with two arguments.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSymmetric_recur(self, root: TreeNode) -\u0026gt; bool: if not root: return True return self.mirror(root.left, root.right) def mirror(self, r1, r2): if not r1 and not r2: return True if not r1 or not r2: return False outer = self.mirror(r1.left, r2.right) inner = self.mirror(r1.right, r2.left) return r1.val==r2.val and outer and inner def isSymmetric_iter(self, root: TreeNode) -\u0026gt; bool: if not root: return True stack = [] stack.append((root.left, root.right)) while stack: l, r = stack.pop() if not l and not r: continue if not l or not r or l.val != r.val: return False stack.append((l.left, r.right)) stack.append((l.right,r.left)) return True # Time O(N) # Space O(logN)  ","id":3,"section":"posts","summary":"LC 101 Symmetric Tree   Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3  But the following [1,2,2,null,3,null,3] is not:\n 1 / \\ 2 2 \\ \\ 3 3   Solution 2020-09-10 Notes:\n recursion is pretty standard in this case.","tags":["leetcode","tree"],"title":"101 Symmetric Tree","uri":"https://foxisawesome.github.io/101-symmetric-tree/","year":"2020"},{"content":"LC 100 Same Tree   Given two binary trees, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.\n Solution 2020-09-09 Notes:\n Two roots çš„pattern å’Œ single rootä¸€æ ·ã€‚Tree åˆ·çš„ç•¥æœ‰æ„Ÿè§‰äº†ï¼  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -\u0026gt; bool: if not p and not q: return True if not p or not q: return False l = self.isSameTree(p.left, q.left) r = self.isSameTree(p.right, q.right) return p.val == q.val and l and r # Time O(N) # Space O(logN)  ","id":4,"section":"posts","summary":"LC 100 Same Tree Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Solution 2020-09-09 Notes: Two roots çš„pattern å’Œ single rootä¸€æ ·ã€‚Tree åˆ·çš„ç•¥æœ‰æ„Ÿ","tags":["leetcode","tree"],"title":"100 Same Tree","uri":"https://foxisawesome.github.io/100-same-tree/","year":"2020"},{"content":"LC 112 Path Sum   Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nGiven the below binary tree and sum = 22,\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1  return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\n Solution 2020-09-09 Notes:\n recursion å¯ä»¥æŠŠpathSm()åˆå¹¶åˆ°ä¸»å‡½æ•°ï¼Œå› ä¸ºinputï¼Œoutputéƒ½ä¸€è‡´ã€‚ä½†æˆ‘è¿˜æ˜¯åˆ·å‡ºæ¥äº†ï¼ğŸ˜Šã€‚ æ¯ä¸€å±‚ä¼ å…¥çš„æ˜¯ target-root.val, ç©¿å‡ºçš„æ˜¯left bool or right bool é¢†æ‚Ÿæ˜¯if not root: return None (or False in this case)æ˜¯defaultï¼Œè‚¯å®šè¦çš„ã€‚ iterationçš„åšæ³•åœ¨ç¬¬äºŒéƒ¨åˆ†ã€‚  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def hasPathSum_recur(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False return self.pathSum(root, sum) def pathSum(self, root, target): if not root: return if not root.left and not root.right: return root.val == target l = self.pathSum(root.left, target - root.val) r = self.pathSum(root.right, target - root.val) return l or r # Time O(N) # Space O(logN) def hasPathSum_iter(self, root: TreeNode, sum: int) -\u0026gt; bool: if not root: return False stack = [(root, root.val)] while stack: node, path = stack.pop() if not node.left and not node.right and path == sum: return True if node.left: stack.append((node.left, path + node.left.val)) if node.right: stack.append((node.right, path + node.right.val)) return False # Time O(N) # Space O(N)  ","id":5,"section":"posts","summary":"LC 112 Path Sum Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Given the below binary tree and sum = 22, 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 return true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum","tags":["leetcode","tree"],"title":"112 Path Sum","uri":"https://foxisawesome.github.io/112-path-sum/","year":"2020"},{"content":"LC 104 Maximum Depth of Binary Tree   Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7   Solution 2020-09-09 Notes:\n æ³¨æ„patterns. Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.maxDepth(root.left) r = self.maxDepth(root.right) return max(l,r)+1 # Time O(N) # Space: best scenario O(H)=O(logN)  ","id":6,"section":"posts","summary":"LC 104 Maximum Depth of Binary Tree Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given binary tree [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 Solution 2020-09-09 Notes: æ³¨æ„patterns. Beat the TREE! # Definition for","tags":["leetcode","tree"],"title":"104 Maximum Depth of Binary Tree","uri":"https://foxisawesome.github.io/104-maximum-depth-of-binary-tree/","year":"2020"},{"content":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def minDepth(self, root: TreeNode) -\u0026gt; int: if not root: return 0 l = self.minDepth(root.left) r = self.minDepth(root.right) if not l and r: return r+1 if not r and l: return l+1 return min(l,r)+1 # Time O(N) # Space O(logN)  ","id":7,"section":"posts","summary":"LC 111 Minimum Depth of Binary Tree   Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nGiven binary tree [3,9,20,null,null,15,7],\n 3 / \\ 9 20 / \\ 15 7  return 2\n Solution 2020-09-09 Notes:\n Beat the TREE!  # Definition for a binary tree node.","tags":["leetcode","tree"],"title":"111 Minimum Depth of Binary Tree","uri":"https://foxisawesome.github.io/111-minimum-depth-of-binary-tree/","year":"2020"},{"content":"LC 124 Binary Tree Maximum Path Sum   Given a non-empty binary tree, find the maximum path sum.\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\nInput: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42   Solution 2020-09-09 Notes:\n å› ä¸ºè¦online update ansï¼Œæ‰€ä»¥å¾—è¦ä¸ªhelper()ã€‚helper() è¿”å›çš„æ˜¯ maxPathSumã€‚ line #23: æ˜¯å› ä¸ºæ¯æ¡sub-pathåªèƒ½å–å·¦childæˆ–è€…å³childä¸­çš„è¾ƒå¤§pathã€‚   ç±»ä¼¼é¢˜: LC 543  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxPathSum(self, root: TreeNode) -\u0026gt; int: self.ans = -float('inf') self.helperMax(root) return self.ans def helperMax(self, root): if not root: return 0 left = self.helperMax(root.left) right = self.helperMax(root.right) left = left if left \u0026gt; 0 else 0 right = right if right \u0026gt; 0 else 0 self.ans = max(self.ans, left+right+root.val) return root.val + max(left, right) # Time O(N) # Space O(H)  ","id":8,"section":"posts","summary":"LC 124 Binary Tree Maximum Path Sum Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15","tags":["leetcode","tree"],"title":"124 Binary Tree Maximum Path Sum","uri":"https://foxisawesome.github.io/124-binary-tree-maximum-path-sum/","year":"2020"},{"content":"LC 987 Vertical Order Traversal of a Binary Tree    Solution 2020-09-09T13:59:40-04:00 Notes:\n   # Time O() # Space O()  ","id":9,"section":"posts","summary":"LC 987 Vertical Order Traversal of a Binary Tree    Solution 2020-09-09T13:59:40-04:00 Notes:\n   # Time O() # Space O()  ","tags":["leetcode"],"title":"987 Vertical Order Traversal of a Binary Tree","uri":"https://foxisawesome.github.io/987-vertical-order-traversal-of-a-binary-tree/","year":"2020"},{"content":"LC 236 Lowest Common Ancestor of a Binary Tree   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).â€\n Solution 2020-09-09 Notes:\n é€’å½’çµé­‚ä¸‰é—® (reference: labuladong)ï¼š  é€’å½’å‡½æ•°returnçš„æ˜¯ä»€ä¹ˆï¼Ÿ é€’å½’å‡½æ•°çš„argumentsï¼Ÿ å¦‚ä½•åˆ©ç”¨é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼Ÿ   part 1: æœ€åº•å±‚è¿”å›æ¡ä»¶ï¼Œroot== p æˆ– qæ—¶ï¼Œ è¿”å›rootã€‚ è¿™é¢˜åº•å±‚å°±ä¸¤ç§æƒ…å†µï¼Œå•¥ä¹Ÿæ²¡æ‰¾åˆ° Nullï¼Œæ‰¾åˆ°p, qï¼Œå°±ä¸å†å¼€æ–°çš„recursionï¼Œ ç›´æ¥è¿”å›p, qã€‚ part 2: å›ºå®šçš„binary tree recursionæ¨¡ç‰ˆ part 3: æ­¤å¤„æ˜¯post-order, è¿”å›å€¼çš„åˆ©ç”¨ï¼Œå°±ä¸‰ç§æƒ…å†µï¼ša. p, q åŒæ—¶éƒ½åœ¨rooté‡Œ, é‚£ä¹ˆrootå°±æ˜¯LCA, æŠŠè¿™ä¸ªLCAä¸€å±‚å±‚è¿”å›ä¸Šå»ã€‚ b. p,q éƒ½ä¸åœ¨rooté‡Œ, è¿”å›Noneã€‚c. p,q å…¶ä¸€åœ¨rooté‡Œï¼Œé‚£ä¸ªå±‚å±‚è¿”å›p æˆ– q çš„è¿™ä¸¤ä¸ªå•ç‹¬èŠ‚ç‚¹ï¼Œç›´åˆ°ä»–ä»¬ç›¸é‡çš„rootæ‰æ˜¯LCAã€‚  # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -\u0026gt; 'TreeNode': # part 1 if root is None: return None if root == p or root == q: return root # part 2 left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) # part 3 if left and right: return root if not left and not right: return None return left if left else right # Time O(N) # Space O(?)  ","id":10,"section":"posts","summary":"LC 236 Lowest Common Ancestor of a Binary Tree Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be","tags":["leetcode","tree"],"title":"236 Lowest Common Ancestor of a Binary Tree","uri":"https://foxisawesome.github.io/236-lowest-common-ancestor-of-a-binary-tree/","year":"2020"},{"content":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:\n O(N) is easy.  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: l = 0 out = '' for i in s: while l \u0026lt; len(t): if t[l]==i: out += t[l] l +=1 break l += 1 return out == s # Time O(M), M:len(t) # Space O(1)   the follow-up of this questions: while s\u0026raquo;t, O(N) is not satisfied. here is O(MlogN) solution using binary search is pretty hard to think of:  class Solution: def isSubsequence(self, s: str, t: str) -\u0026gt; bool: d = dict() for i, val in enumerate(t): if val not in d: d[val] = [i] else: d[val].append(i) tar = 0 for i, val in enumerate(s): if val not in d: return False pos = self.leftBound(d[val],tar) if pos == len(d[val]): return False tar = d[val][pos] + 1 return True def leftBound(self, idx_ls, p): l, r = 0, len(idx_ls) while l \u0026lt; r: m = l + (r-l)//2 if idx_ls[m] \u0026lt; p: l = m + 1 elif idx_ls[m] \u0026gt;= p: r = m return l # Time O(MlogN), N:len(s), M:len(t) # Space O(M)  ","id":11,"section":"posts","summary":"LC 392 Is Subsequence   Given a string s and a string t, check if s is subsequence of t.\nA subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \u0026quot;ace\u0026quot; is a subsequence of \u0026quot;abcde\u0026quot; while \u0026quot;aec\u0026quot; is not).\n Solution 2020-09-08 Notes:","tags":["leetcode","binarysearch"],"title":"392 Is Subsequence","uri":"https://foxisawesome.github.io/392-is-subsequence/","year":"2020"},{"content":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","id":12,"section":"posts","summary":"LC 268 Missing Number   Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n Solution 2020-09-08 Notes:\n Calculate it directly.  class Solution: def missingNumber(self, nums: List[int]) -\u0026gt; int: n = len(nums) return n*(n+1)//2 - sum(nums) # Time O(1) # Space O(1)  ","tags":["leetcode"],"title":"268 Missing Number","uri":"https://foxisawesome.github.io/268-missing-number/","year":"2020"},{"content":"LC 645 Set Mismatch   The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\nGiven an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\n Solution 2020-09-08 Notes:\n å¯ä»¥ç›´æ¥ç®—å‡ºæ¥ï¼Œ sum(1-n) - sum(set(nums)) ä¹Ÿå¯ä»¥ç”¨hash tableçš„æ€æƒ³æ„é€  count dict æ¥åšï¼Œ one-passã€‚è¦çœŸç”¨dict() å¾—two-passäº†ã€‚è¿˜å¾—passä¸€è¾¹dictionaryã€‚  class Solution: def findErrorNums(self, nums: List[int]) -\u0026gt; List[int]: n = len(nums) h = [0]*n for i in range(n): h[nums[i]-1] += 1 return [h.index(2)+1, h.index(0)+1] # Time O(N) # Space O(N)  ","id":13,"section":"posts","summary":"LC 645 Set Mismatch The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number. Given an array nums representing the data status of this set after the error. Your task is to firstly find the number","tags":["leetcode","hashtable"],"title":"645 Set Mismatch","uri":"https://foxisawesome.github.io/645-set-mismatch/","year":"2020"},{"content":"LC 234 Palindrome Linked List   Given a singly linked list, determine if it is a palindrome.\n Solution 2020-09-08 Notes:\n  Recursion solutionå‚è€ƒäº† labuladong\n  ä»¥ä¸‹æ˜¯ä¸€ç§æ¯”è¾ƒç›´è§‚ä½†æ˜¯ä¸æ˜¯optimalçš„è§£æ³•\n  line 13 is a post-order traverse.\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def isPalindrome(self, head: ListNode) -\u0026gt; bool: self.left = head return self.traverse(head) def traverse(self, right): if not right: return True res = self.traverse(right.next) res = res and right.val ==self.left.val self.left = self.left.next return res # Time O(N) # Space O(?)  ","id":14,"section":"posts","summary":"LC 234 Palindrome Linked List Given a singly linked list, determine if it is a palindrome. Solution 2020-09-08 Notes: Recursion solutionå‚è€ƒäº† labuladong ä»¥ä¸‹æ˜¯ä¸€ç§æ¯”è¾ƒç›´è§‚ä½†æ˜¯ä¸æ˜¯optimalçš„è§£æ³• line 13 is a post-order traverse. # Definition for singly-linked list. # class ListNode: #","tags":["leetcode","linkedlist"],"title":"234 Palindrome Linked List","uri":"https://foxisawesome.github.io/234-palindrome-linked-list/","year":"2020"},{"content":"Summary:\n  it minimizes â€œwithinâ€ cluster distance or equivalently maximizes â€œin betweenâ€ cluster distance/variance.\n  K-means algorithm is closely ralated to E-M algorithm\nE-M (Expectation-Maximization) algorithm is a â€œsoftâ€ version of K-means\n  Algorithm intuition (see example implemented in numpy below ):\n  Pre-set $K$: use elbow plot: loss vs $K$ to determine K or use automatic: gap statistics method to determine $K$.\n  Randomly assign initial cluster centroid $k$. To make algorithm more efficient, set centroid â€œfar awayâ€.\n  while not converge, iterative descent algorithm\na. given cluster C, minimize cost function to find centroid of cluster\nb. given centroid, minimize cost function to find cluster $k$\n    E-M algorithm:\n  set $K=2$: â€œ2 component Gaussian Mixtureâ€, GMM\n  while not converge:\nâ€‹\ta. compute probability given fixing Gaussian pdf\nâ€‹\tb. based on Prob. calculate Gaussian distribution parameters\n    K-means / E-M is a non-convex optimization problem. it has local optima issue. initialization is important. to avoid this issue, one can run M times, choose the one has the min cost function/MSE.\n  cons: K-means is limited to linear cluster boundaries.\n  cons: slow for large # of samples.\n  import numpy as np from matplotlib import pyplot as plt def data_generator(): class_1_data = np.random.randn(100,2) + np.array([1,2]) class_2_data = np.random.randn(100,2) + np.array([-5,9]) class_3_data = np.random.randn(100,2) + np.array([8,2]) return np.concatenate([class_1_data, class_2_data, class_3_data], axis=0) def K_means(data, K, lr=0.2): D = data.shape[1] N = data.shape[0] category = np.zeros(N) centroid = np.random.randn(K, D) centroid_copy = centroid.copy() finished = False while not finished: # step 1: update data point's category for j in range(N): nearest_centroid = None nearest_centroid_dist = float('inf') for k in range(K): dist_j_k = np.linalg.norm(centroid[k] - data[j]) if dist_j_k \u0026lt; nearest_centroid_dist: nearest_centroid_dist = dist_j_k nearest_centroid = k category[j] = nearest_centroid # step 2: recalc centroid for j in range(K): new_centroid = np.mean(data[category == j], axis = 0) centroid[j] = new_centroid*lr + centroid[j]*(1-lr) # visualization print(centroid) plt.scatter(x=data[:,0], y=data[:,1], c=category) plt.plot(list(centroid[:,0]), list(centroid[:,1]), 'ro') plt.show() # step 3: iterate 1 and 2 # convergence check cg_rt = np.linalg.norm(np.linalg.norm(centroid - centroid_copy, axis = 0).reshape(-1)) centroid_copy = centroid.copy() if cg_rt \u0026lt; 0.01: finished = True  # data generator: data = data_generator() plt.scatter(data[:,0], data[:,1]) plt.show() # apply K-means K_means(data, 3)  ","id":15,"section":"posts","summary":"Summary:\n  it minimizes â€œwithinâ€ cluster distance or equivalently maximizes â€œin betweenâ€ cluster distance/variance.\n  K-means algorithm is closely ralated to E-M algorithm\nE-M (Expectation-Maximization) algorithm is a â€œsoftâ€ version of K-means\n  Algorithm intuition (see example implemented in numpy below ):\n  Pre-set $K$: use elbow plot: loss vs $K$ to determine K or use automatic: gap statistics method to determine $K$.\n  Randomly assign initial cluster centroid $k$.","tags":["kmeans"],"title":"ML Kmeans Algo Sample","uri":"https://foxisawesome.github.io/ml-kmeans/","year":"2020"},{"content":"LC 325 Maximum Size Subarray Sum Equals K   Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead.\nInput: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest.   Solution 2020-09-08 Notes:\n æ­¤é¢˜è§£æ³•è·Ÿ LC560 ä¸€æ‘¸ä¸€æ ·ã€‚ç”¨cumulative + hash table çš„one-pass O(N). å› ä¸ºhash tableéœ€è¦ç”¨æ¥å­˜numsçš„index dict()çš„value éœ€è¦æ˜¯list  class Solution: def maxSubArrayLen(self, nums: List[int], k: int) -\u0026gt; int: if not nums: return 0 d = collections.defaultdict(list) cum_sum = 0 d[0].append(0) n = len(nums) ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans = max(ans, i-min(d[target_sum])+1) d[cum_sum].append(i+1) return ans # Time O(N) # Space O(N)  ","id":16,"section":"posts","summary":"LC 325 Maximum Size Subarray Sum Equals K Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn\u0026rsquo;t one, return 0 instead. Input: nums = [1, -1, 5, -2, 3], k = 3 Output: 4 Explanation: The subarray [1, -1, 5, -2] sums to 3 and is the longest. Solution 2020-09-08 Notes: æ­¤é¢˜è§£æ³•è·Ÿ","tags":["leetcode","array","hashtable"],"title":"325 Maximum Size Subarray Sum Equals K","uri":"https://foxisawesome.github.io/325-maximum-size-subarray-sum-equals-k/","year":"2020"},{"content":"LC 560 Subarray Sum Equals K   Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\nInput:nums = [1,1,1], k = 2 Output: 2   Solution 2020-09-08 Notes:\n  çœ‹äº†labuladong çš„æ€»ç»“\n  é¢„å…ˆç®—ä¸€ä¸ªcumulative sum çš„dictionaryï¼Œåªè¦ cum_sum - k in d é‚£ä¹ˆ ans å°±å åŠ æ¬¡æ•°ã€‚\n  éœ€è¦dictè®°å½•frequency, (numså¯èƒ½æœ‰0)ã€‚\n  FB çƒ­é—¨é¢˜\n  class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: d = dict() n = len(nums) cum_sum = 0 d[cum_sum] = 1 ans = 0 for i in range(n): cum_sum += nums[i] target_sum = cum_sum - k if target_sum in d: ans += d[target_sum] d[cum_sum] = d.get(cum_sum,0) + 1 return ans # Time O(N) # Space O(1)  ","id":17,"section":"posts","summary":"LC 560 Subarray Sum Equals K Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Input:nums = [1,1,1], k = 2 Output: 2 Solution 2020-09-08 Notes: çœ‹äº†labuladong çš„æ€»ç»“ é¢„å…ˆç®—ä¸€ä¸ªcumulativ","tags":["leetcode","array","hashtable"],"title":"560 Subarray Sum Equals K","uri":"https://foxisawesome.github.io/560-subarray-sum-equals-k/","year":"2020"},{"content":"LC 1109 Corporate Flight Bookings   There are n flights, and they are labeled from 1 to n.\nWe have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive.\nReturn an array answer of length n, representing the number of seats booked on each flight in order of their label.\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 Output: [10,55,45,25,25]   Solution 2020-09-08 Notes:\n é¢˜ç›®å¾ˆç»•å£ï¼Œæ ¸å¿ƒæ˜¯èµ·ç‚¹å’Œç»ˆç‚¹ä¹‹é—´çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¼š carry over seats numberã€‚ ç”¨ labuladongçš„å·®åˆ†æ•°åˆ—çš„ç®—æ³•åªè¦ one-pass of booking array O(N). :  é¦–å…ˆæ„é€  diff_arr[i] = nums[i] - nums[i-1], where diff_arr[0] = nums[0] è¿™ä¸ªæ“ä½œ diff_arr[i] += val and diff_arr[j+1] -= val å°±å¯ä»¥æ“ä½œ nums[i], ..., nums[j] all +val. With corner case, if j+1 \u0026lt; len(nums):diff_arr[j+1] -= val  å›å¤nums: nums[i] = diff_arr[i] + nums[i-1] å¦‚æ­¤åªè¦ one-pass æ“ä½œåŒºé—´çš„èŠ‚ç‚¹å°±å¯ä»¥å¯¹æ•´ä¸ªæ•°åˆ—è¿›è¡Œå¤šæ¬¡è®¡ç®—ï¼Œç›´æ¥è¿”å›è¦æ±‚å€¼ã€‚   ç±»ä¼¼çš„æŠ€æœ¯è¿˜æœ‰å…ˆè®¡ç®— cumulative sum of nums å†æ“ä½œï¼ŒFBæœ‰å¾ˆå¤šçƒ­é—¨é¢˜è¿™ä¹ˆåšã€‚  class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u0026gt; List[int]: diff_arr = [0] * n # diff[i] = arr[i]- arrr[i-1] ans = [0] * n for book in bookings: i = book[0]-1 j = book[1]-1 seat = book[2] diff_arr[i] += seat if j+1 \u0026lt; n: diff_arr[j+1] -= seat ans[0] = diff_arr[0] for i in range(1,n): ans[i] = diff_arr[i] + ans[i-1] return ans # Time O(N) # Space O(N)  ","id":18,"section":"posts","summary":"LC 1109 Corporate Flight Bookings There are n flights, and they are labeled from 1 to n. We have a list of flight bookings. The i-th booking bookings[i] = [i, j, k] means that we booked k seats from flights labeled i to j inclusive. Return an array answer of length n, representing the number of seats booked on each flight in order of their label. Input: bookings = [[1,2,10],[2,3,20],[2,5,25]],","tags":["leetcode","array"],"title":"1109 Corporate Flight Bookings","uri":"https://foxisawesome.github.io/1109-corporate-flight-bookings/","year":"2020"},{"content":"LC 1539 Kth Missing Positive Number   Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nFind the kth positive integer that is missing from this array.\nInput: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.   Solution 2020-09-07 Notes:\n O(N) solution is pretty easy, but not optimal. the binary solution is optimal.  arr[i]-(i+1): è¿”å›çš„æ˜¯ arr[i]å’Œi+1 ä¹‹é—´missäº†å‡ ä¸ªæ•°ï¼Œå¦‚æœarræ²¡missæ•°ï¼Œè¿”å›çš„å› è¯¥æ˜¯0. æ‰€ä»¥è¿™ä¸ªæ¡ä»¶å’Œkæ¯”è¾ƒå¯ä»¥å¿«é€Ÿæ‰¾åˆ°æœ€æ¥è¿‘çš„ä½ç½®ã€‚ æˆ‘ç–å¿½çš„æ˜¯ï¼šè¿™é¢˜æ˜¯æ±‚k-th missing value çš„èµ·å§‹å·¦è¾¹ç•Œï¼Œä»¥ä¸‹æ˜¯æœç´¢å·¦è¾¹ç•Œçš„æ ‡å‡†åšæ³•ã€‚ Binary searchè€Œä¸æ˜¯æ‰¾ exactçš„ target (éœ€è¦ä¿è¯å­˜åœ¨å”¯ä¸€è§£ï¼Œæ‰èƒ½ç”¨)ï¼Œæ˜¯æœç´¢targetçš„å·¦è¾¹ç•Œï¼Œæ‰€ä»¥åœ¨binary searchæ—¶å•ç‹¬ä¾‹ä¸¾ arr[i]-(i+1)==k è·³å‡ºä¼šæŠ¥é”™ã€‚åº”è¯¥åˆå¹¶ \u0026gt;=ä¸¤ç§æƒ…å†µè¿™ç§å†™æ³•æ‰å¯¹ã€‚ å¦å¤–è¿™é¢˜æ˜¯ 1-indexedï¼Œæ‰€ä»¥ä¼šæœ‰ i+1, l+k è¿™ç§å°ç»†èŠ‚è¦ææ¸…ã€‚    class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr) while l\u0026lt;r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m return l+k # 2nd way of writing this left boundary search. same results. def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: l, r = 0, len(arr)-1 while l\u0026lt;=r: m = l + (r-l)//2 if arr[m] - (m+1) \u0026lt; k: l = m + 1 elif arr[m] - (m+1) \u0026gt;= k: r = m - 1 return l+k # Time O(logN) # Space O(1)  class Solution: def findKthPositive(self, arr: List[int], k: int) -\u0026gt; int: stack = [] if arr[-1] - len(arr) \u0026lt; k: return arr[-1]+(k-arr[-1]+len(arr)) elif arr[-1] - len(arr) \u0026gt;= k: stack = [i for i in range(1, arr[-1]+1)] [stack.remove(i) for i in arr] return stack[k-1] # Time O(N) # Space O(N)  ","id":19,"section":"posts","summary":"LC 1539 Kth Missing Positive Number Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Find the kth positive integer that is missing from this array. Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Solution 2020-09-07 Notes: O(N) solution is pretty easy, but not optimal. the binary","tags":["leetcode","binarySearch"],"title":"1539 Kth Missing Positive Number","uri":"https://foxisawesome.github.io/1539-kth-missing-positive-number/","year":"2020"},{"content":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","id":20,"section":"posts","summary":"LC 1512 Number of Good Pairs   Given an array of integers nums.\nA pair (i,j) is called good if nums[i] == nums[j] and i \u0026lt; j.\nReturn the number of good pairs.\n Solution 2020-09-06 Notes:\n One-pass using hash table. line 7-9, if gets a match, how many pairs it can make to previous ones is d[num].  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 ans = 0 d = dict() for num in nums: if num in d: ans += d[num] d[num] += 1 else: d[num] = 1 return ans # Time O(N) # Space O(N)   Use double loop:  class Solution: def numIdenticalPairs(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 n = len(nums) ans = 0 for i in range(n): j = i+1 while j \u0026lt; n: if nums[i] == nums[j]: ans += 1 j += 1 return ans # Time O(N^2) # Space O(1)  ","tags":["leetcode","hashtable"],"title":"1512 Number of Good Pairs","uri":"https://foxisawesome.github.io/1512-number-of-good-pairs/","year":"2020"},{"content":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case. need to take int(a/b) I was scared what if the division tests on a infinite unreapted, then toasted. However, the test cases have none. convet all calc to postive nums once determined. Loop through mod and record each modâ€™s index place.  class Solution: def fractionToDecimal(self, numerator: int, denominator: int) -\u0026gt; str: if denominator == 0: return '' ans = '-' if numerator * denominator \u0026lt; 0 else '' numerator, denominator = abs(numerator), abs(denominator) d = dict() div, mod = self.myDivmod(numerator, denominator) if mod == 0: ans += str(div) return ans ans += str(div) + '.' d[mod] = len(ans) while mod: div, mod = self.myDivmod(mod*10, denominator) ans += str(div) if mod in d: idx = d[mod] ans = ans[:idx] + '(' + ans[idx:] + ')' break else: d[mod] = len(ans) return ans def myDivmod(self, a, b): d = int(a/b) m = a - d*b return (d, m)  ","id":21,"section":"posts","summary":"LC 166 Fraction to Recurring Decimal   Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\nIf the fractional part is repeating, enclose the repeating part in parentheses.\nIf multiple answers are possible, just return any of them.\nExtreme case: numer = -2147483648, denominator = -1999\n Solution 2020-09-05 Notes:\n Details: python built-in divmod() returns floor, which is not friendly in negative case.","tags":["leetcode"],"title":"166 Fraction to Recurring Decimal","uri":"https://foxisawesome.github.io/166-fraction-to-recurring-decimal/","year":"2020"},{"content":"LC 159 Longest Substring With at Most Two Distinct Characters   Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters.\nInput: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5.   Solution 2020-09-05 Notes:\n ä»Šå¤©å‘¨æœ«å‡ºå»èµ°äº†ä¸€åœˆï¼Œå›å®¶åˆ·é¢˜æ•ˆç‡å¯ä»¥å•Šã€‚  class Solution: def lengthOfLongestSubstringTwoDistinct(self, s: str) -\u0026gt; int: if not s: return 0 out = 0 n = len(s) for i in range(n): l = 1 while i+l \u0026lt; n and len(set(s[i:i+l+1])) \u0026lt; 3: l += 1 out = max(out, l) return out # Time O(N) # Space O(1)  ","id":22,"section":"posts","summary":"LC 159 Longest Substring With at Most Two Distinct Characters Given a string *s* , find the length of the longest substring *t* that contains at most 2 distinct characters. Input: \u0026quot;ccaabbb\u0026quot; Output: 5 Explanation: t is \u0026quot;aabbb\u0026quot; which its length is 5. Solution 2020-09-05 Notes: ä»Šå¤©å‘¨æœ«å‡ºå»èµ°äº†ä¸€åœˆï¼Œå›å®¶åˆ·é¢˜æ•ˆç‡å¯ä»¥å•Šã€‚ class Solution: def","tags":["leetcode"],"title":"159 Longest Substring With at Most Two Distinct Characters","uri":"https://foxisawesome.github.io/159-longest-substring-with-at-most-two-distinct-characters/","year":"2020"},{"content":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.add(num) else: stack.remove(num) return stack.pop() # Time O(N) # Space O(N)  If we take XOR of zero and some bit, it will return that bit: $a \\oplus 0 = a$ If we take XOR of two same bits, it will return 0: $a \\oplus a = 0$\nclass Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: a = 0 for num in nums: a ^= num return a  class Solution(object): def singleNumber(self, nums): return 2 * sum(set(nums)) - sum(nums)  ","id":23,"section":"posts","summary":"LC 136 Single Number   Given a non-empty array of integers, every element appears twice except for one. Find that single one.\nNote: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n Solution 2020-09-05 Notes:\n Space O(1) solution is a bit tricky.  class Solution: def singleNumber(self, nums: List[int]) -\u0026gt; int: stack = set() for num in nums: if num not in stack: stack.","tags":["leetcode"],"title":"136 Single Number","uri":"https://foxisawesome.github.io/136-single-number/","year":"2020"},{"content":"LC 187 Repeated Dna Sequences   All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.\nWrite a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.\n Solution 2020-09-05 Notes:\n å¾ˆç®€å•çš„é¢˜ï¼Œä¸¤ä¸ªå°é™·è¿›ï¼š  Substring = s[i-9:i+1] NOT s[i-10:i] because 0-indexed. avoid dups in the output.    class Solution: def findRepeatedDnaSequences(self, s: str) -\u0026gt; List[str]: n = len(s) if not s or n\u0026lt;10: return [] count = dict() out = [] for i in range(9,n): entry = s[i-9:i+1] ct = count.get(entry,0) + 1 count[entry]= ct if ct \u0026gt; 1 and entry not in out: out.append(entry) return out # Time O(N) # Space O(1)  ","id":24,"section":"posts","summary":"LC 187 Repeated Dna Sequences All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: \u0026ldquo;ACGAATTCCG\u0026rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA. Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. Solution 2020-09-05 Notes: å¾ˆç®€å•çš„é¢˜ï¼Œä¸¤ä¸ªå°é™·","tags":["leetcode"],"title":"187 Repeated Dna Sequences","uri":"https://foxisawesome.github.io/187-repeated-dna-sequences/","year":"2020"},{"content":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","id":25,"section":"posts","summary":"LC 1249 Minimum Remove to Make Valid Parentheses    Solution 2020-09-05T14:01:30-04:00 Notes:\n   # Time O() # Space O()  ","tags":["leetcode"],"title":"1249 Minimum Remove to Make Valid Parentheses","uri":"https://foxisawesome.github.io/1249-minimum-remove-to-make-valid-parentheses/","year":"2020"},{"content":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Sam e\n  class Solution: def removeDuplicateLetters(self, s: str) -\u0026gt; str: count = dict() stack = [] for l in s: count[l] = count.get(l,0) + 1 for c in s: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":26,"section":"posts","summary":"LC 316 Remove Dup Letters  Given a string which contains only lowercase letters, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.\nInput: \u0026quot;cbacdcbc\u0026quot; Output: \u0026quot;acdb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration.","tags":["leetcode"],"title":"316 Remove Dup Letters","uri":"https://foxisawesome.github.io/316-remove-dup-letters/","year":"2020"},{"content":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.\n  Pop out letters stack[-1] \u0026lt; l (same as monotoinc stack to get next greater number algo), do NOT pop, if counter goes to 0.\nwhile stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop()\n  Same as LC 316\n  class Solution: def smallestSubsequence(self, text: str) -\u0026gt; str: count = dict() stack = [] for l in text: count[l] = count.get(l,0) + 1 for c in text: count[c] -= 1 if c in stack: continue while stack and stack[-1] \u0026gt; c and count[stack[-1]] != 0: stack.pop() stack.append(c) return \u0026quot;\u0026quot;.join(stack) # Time O(N) # Space O(N)  ","id":27,"section":"posts","summary":"LC 1081 Smallest Subsequence of Distinct Char   Return the lexicographically smallest subsequence of text that contains all the distinct characters of text exactly once.\nInput: \u0026quot;ecbacba\u0026quot; Output: \u0026quot;eacb\u0026quot;   Solution 2020-09-04 Notes:\n  Need one-pass of s to get the counter of each letter.\n  a second pass, dial down counter at each iteration. use a stack to record every distinct letter and keep the order of recorded letter same as their orders in the string.","tags":["leetcode"],"title":"1081 Smallest Subsequence of Distinct Char","uri":"https://foxisawesome.github.io/1081-smallest-subsequence-of-distinct-char/","year":"2020"},{"content":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.get(nums[fast],0) + 1 if count[nums[fast]] \u0026lt;= 2: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":28,"section":"posts","summary":"LC 80 Remove Dup From Sorted Array II   Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,1,2,3,3], output [0,0,1,1,2,3,3]   Solution 2020-09-04 Notes:\n Same thing as LC 26.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 count = dict() count[nums[0]] = 1 slow, fast = 0, 1 while fast \u0026lt; len(nums): count[nums[fast]] = count.","tags":["leetcode","twopointers"],"title":"80 Remove Dup From Sorted Array II","uri":"https://foxisawesome.github.io/80-remove-dup-from-sorted-array-ii/","year":"2020"},{"content":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.   Solution 2020-09-04 Notes:\n Two pointers: slow and fast. updates when fast == slow.  class Solution: def removeDuplicates(self, nums: List[int]) -\u0026gt; int: slow, fast = 0, 1 while fast \u0026lt; len(nums): if nums[fast] != nums[slow]: slow += 1 nums[slow], nums[fast] = nums[fast], nums[slow] fast += 1 return slow + 1 # Time O(N) # Space O(1)  ","id":29,"section":"posts","summary":"LC 26 Remove Dup From Sorted Array   Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.\nGiven nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.","tags":["leetcode","twopointers"],"title":"26 Remove Dup From Sorted Array","uri":"https://foxisawesome.github.io/26-remove-dup-from-sorted-array/","year":"2020"},{"content":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):\nclass Solution: def fourSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: nums.sort() return self.kSum(nums, target, 4) def kSum(self, nums: List[int], target: int, k: int) -\u0026gt; List[List[int]]: res = [] if len(nums)==0 or nums[0] * k \u0026gt; target or nums[-1] * k \u0026lt; target: return res if k == 2: return self.twoSum(nums, target) for i in range(len(nums)): if i == 0 or nums[i - 1] != nums[i]: for _, val in enumerate(self.kSum(nums[i+1:], target-nums[i], k-1)): res.append([nums[i]] + val) return res def twoSum(self, nums: List[int], target: int) -\u0026gt; List[List[int]]: res = [] lo, hi = 0, len(nums) - 1 while (lo \u0026lt; hi): sum = nums[lo] + nums[hi] if sum \u0026lt; target or (lo \u0026gt; 0 and nums[lo] == nums[lo - 1]): lo += 1 elif sum \u0026gt; target or (hi \u0026lt; len(nums) - 1 and nums[hi] == nums[hi + 1]): hi -= 1 else: res.append([nums[lo], nums[hi]]) lo += 1 hi -= 1 return res # Time O(N^(k-1)) # Space O(N)  ","id":30,"section":"posts","summary":"LC 18 4Sum   Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.\nNote: The solution set must not contain duplicate quadruplets.\n Solution 2020-09-03 Notes:\nK - sum algo:\n sort nums recursion top down, reduce to a 2-Sum problem two pointers: l, r to find target  Note: to skip duplicates: if not (i \u0026gt; 0 and nums[i]==nums[i-1]):","tags":["leetcode"],"title":"18 K Sum","uri":"https://foxisawesome.github.io/18-k-sum/","year":"2020"},{"content":"LC 140 Word Break II   Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\nInput: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ]   Solution 2020-09-03 Notes:\n ç¬¬ä¸€æ¬¡å°è¯•ï¼Œå“‡ï¼è¿™ä¸æ˜¯å’Œ word break ä¸€æ‘¸ä¸€æ ·å˜›ã€‚ç…§æ¨¡ç‰ˆå†™äº†ä¸ªbtå¦‚ä¸‹ï¼Œè¯•äº†ä¸¤ä¸ªä¾‹å­éƒ½è¿‡äº†ã€‚æäº¤äº†æ‰å‘ç°ï¼Œä¸¥é‡è¶…æ—¶ã€‚ä¸€çœ‹å®˜æ–¹è§£ç­”æ˜¯dpåšçš„ï¼Œæ„Ÿå¹è¦ä¸æ€ä¹ˆæ˜¯mediumï¼Œä¸€é¢˜æ˜¯hardå‘¢ã€‚ä½†æˆ‘è§‰å¾—æˆ‘è¦èƒ½åŠ ä¸Šmemo è·Ÿä¸‹é¢çš„dfsåº”è¯¥æ˜¯åŒç†ã€‚ äºæ˜¯çœ‹äº†å¤§ç‰›çš„è§£ç­”ï¼Œå¸¦memoçš„recursionæ˜¯å¯ä»¥è¿‡çš„  # backtracking, exceed time limit! class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: n = len(s) out = [] self.backtracking(s,wordDict,[],out,n) return out def backtracking(self, s, wordDict, path, out, n): m = len(s) if m == 0: out.append(\u0026quot; \u0026quot;.join(path)) return for i in range(m): if s[:i+1] in wordDict: path.append(s[:i+1]) for self.backtracking(s[i+1:], wordDict, path, out, n) path.pop() # Time O() # Space O()  recursion with memo:\n need to add () to this res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)). Otherwise, it will interperate as res.append((w + '') if not r else (\u0026quot; \u0026quot; + r))  class Solution: def wordBreak(self, s: str, wordDict: List[str]) -\u0026gt; List[str]: res = [] memo = dict() return self.dfs(s,wordDict,memo) def dfs(self, s,wordDict,memo): if s in memo: return memo[s] if not s: return [\u0026quot;\u0026quot;] res = [] for w in wordDict: if s[:len(w)] == w: for r in self.dfs(s[len(w):], wordDict, memo): res.append(w + ('' if not r else \u0026quot; \u0026quot; + r)) memo[s] = res return res  ","id":31,"section":"posts","summary":"LC 140 Word Break II Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Input: s = \u0026quot;pineapplepenapple\u0026quot; wordDict = [\u0026quot;apple\u0026quot;, \u0026quot;pen\u0026quot;, \u0026quot;applepen\u0026quot;, \u0026quot;pine\u0026quot;, \u0026quot;pineapple\u0026quot;] Output: [ \u0026quot;pine apple pen apple\u0026quot;, \u0026quot;pineapple pen apple\u0026quot;, \u0026quot;pine applepen apple\u0026quot; ] Solution 2020-09-03 Notes: ç¬¬ä¸€","tags":["leetcode","dp","recursion","backtracking"],"title":"140 Word Break II","uri":"https://foxisawesome.github.io/140-word-break-ii/","year":"2020"},{"content":"LC 128 Longest Consecutive Sequence   Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\nYour algorithm should run in O(n) complexity.\nExample:\nInput: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.   Solution 2020-09-03 Notes:\n  é¢˜ç›® time complexity è¦æ±‚O(N)ï¼Œé‚£æ²¡å…¶ä»–åŠæ³•åªèƒ½ hash tableåšäº†ï¼Œçœ‹äº†èŠ±èŠ±çš„è§†é¢‘ï¼Œ æ²¡è¯è¯´ä¸€è®²å°±å¾ˆç®€å•äº†ã€‚\n  solution #1: ç”¨dictionaryåšï¼Œkeyè®°å½•numsé‡Œçš„æ¯ä¸ªæ•°ï¼Œval=ä½†è¿™ä¸ªæ•°å­—çš„æœ€é•¿è¿ç»­æ•°å­—é•¿åº¦ã€‚æŸ¥çœ‹num-1 å’Œ num+1çš„val. online æ±‚æœ€é•¿é•¿åº¦ã€‚\n  solution #2: ç”¨setåš, if num-1 not in the set, then num is the starting point of a consecutive list. Count the length until num+l not in the set. offline getting longest length.\n  class Solution: def longestConsecutive_solu1(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #1 h = dict() # key: num, val: consecutive length until key out = 0 for i in nums: if i in h: continue l = h[i-1] if i-1 in h else 0 r = h[i+1] if i+1 in h else 0 h[i] = h[i-l] = h[i+r] = l+r+1 out = max(out, h[i]) return out def longestConsecutive_solu2(self, nums: List[int]) -\u0026gt; int: if not nums: return 0 #solution #2 h = set(nums) out = 0 for num in nums: if num-1 not in h: l = 1 while num+l in h: l += 1 out = max(out, l) return out # Time O(N) # Space O(N)  ","id":32,"section":"posts","summary":"LC 128 Longest Consecutive Sequence Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution 2020-09-03 Notes: é¢˜ç›® time complexity è¦æ±‚O(N)ï¼Œé‚£æ²¡å…¶","tags":["leetcode"],"title":"128 Longest Consecutive Sequence","uri":"https://foxisawesome.github.io/128-longest-consecutive-sequence/","year":"2020"},{"content":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\n Solution 2020-09-02 Notes:\n Height of a tree: max(left_height, right_height) + 1 width of a tree (diameter): max(left_height + right_height) Diameter needs to be calculated along the way in this case.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -\u0026gt; int: if not root: return 0 self.diameter = 0 self.DFS(root) return self.diameter def DFS(self, root) -\u0026gt; int: # DFS returns the height if not root: return 0 L_height = self.DFS(root.left) R_height = self.DFS(root.right) self.diameter = max(self.diameter, L_height+R_height) return max(L_height, R_height) + 1 # Time O(N) # Space O(N)  ","id":33,"section":"posts","summary":"LC 543 Diameter of Binary Tree   Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nExample: Given a binary tree\n 1 / \\ 2 3 / \\ 4 5  Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].","tags":["leetcode","tree"],"title":"543 Diameter of Binary Tree","uri":"https://foxisawesome.github.io/543-diameter-of-binary-tree/","year":"2020"},{"content":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.\n  Algo #2: one pass, same time complexity. some details need to figure out.\n  rotation algo: r, c = c, n-r-1\n  row in range(n//2+n%2) and col in range(n//2)\n  while rotating the k, cycle from the last element: t[(k-1)%4]\n    class Solution: def rotate(self, matrix: List[List[int]]) -\u0026gt; None: n = len(matrix) # two-pass: 1. transpose; 2. reverse rows for i in range(n): for j in range(i,n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] for i in range(n): matrix[i].reverse() # one-pass: for i in range(n//2+n%2): for j in range(n//2): r, c = i, j t = [0]*4 for k in range(4): t[k] = matrix[r][c] r, c = c, n-r-1 for k in range(4): matrix[r][c] = t[(k-1)%4] r, c = c, n-r-1 # Time O(N^2) # Space O(1)  ","id":34,"section":"posts","summary":"LC 48 Rotate Image   You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\n Solution 2020-09-02T14:16:29-04:00 Notes:\n  Algo #1: tranpose the matrix first, then reverse the rows. it requires two passes.","tags":["leetcode"],"title":"48 Rotate Image","uri":"https://foxisawesome.github.io/48-rotate-image/","year":"2020"},{"content":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e 25%) while the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e 75%).\nMore formally, the probability of picking index i is w[i] / sum(w).\n Solution 2020-09-02 Notes:\n first, construct cumulative sum / total sum list. binary search for the nearest element \u0026gt; rand.uniform(0,1). I used closed interval in binary search, hence return l. No == case, because the robablilty of element exactly equal to random draw is 0.  class Solution: import random def __init__(self, w: List[int]): self.w = w self.w_sum = [] wsum = 0 tot = sum(self.w) for i in w: wsum += i prob = wsum/tot self.w_sum.append(prob) def pickIndex(self) -\u0026gt; int: target = random.uniform(0,1) l, r = 0, len(self.w)-1 while l \u0026lt;= r: m = l + (r-l)//2 if self.w_sum[m] \u0026gt; target: r = m - 1 elif self.w_sum[m] \u0026lt; target: l = m + 1 return l # Time O(N) + O(logN) # Space O(N)  ","id":35,"section":"posts","summary":"LC 528 Random Pick With Weight   Given an array of positive integers w. where w[i] describes the weight of i``th index (0-indexed).\nWe need to call the function pickIndex() which randomly returns an integer in the range [0, w.length - 1]. pickIndex() should return the integer proportional to its weight in the w array. For example, for w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.","tags":["leetcode"],"title":"528 Random Pick With Weight","uri":"https://foxisawesome.github.io/528-random-pick-with-weight/","year":"2020"},{"content":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.\nExample:\nInput: (7 -\u0026gt; 2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 8 -\u0026gt; 0 -\u0026gt; 7   Solution 2020-09-02 Notes:\n Scan two linked lists first, using stack to store the node value. use the same LC 2 add two numbers to add them up from the end. Use LC 206 reverse linked list to store reversely along the way.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: stack1, stack2 = [], [] while l1: stack1.append(l1.val) l1 = l1.next while l2: stack2.append(l2.val) l2 = l2.next carry = 0 head = None while stack1 and stack2: carry, r = divmod(stack1.pop() + stack2.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp stack = stack1 if stack1 else stack2 while stack: carry, r = divmod(stack.pop() + carry, 10) temp = head head = ListNode(r) head.next = temp if carry != 0: temp = head head = ListNode(carry) head.next = temp return head # Time O(N) # Space O(1)  ","id":36,"section":"posts","summary":"LC 445 Add Two Num II   You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nFollow up: What if you cannot modify the input lists?","tags":["leetcode","linkedList"],"title":"445 Add Two Num II","uri":"https://foxisawesome.github.io/445-add-two-num-ii/","year":"2020"},{"content":"LC 295 Find Median From Data Stream   Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\nFor example,\n[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5   Solution 2020-09-01 Notes:\n  Follow äº†èŠ±èŠ±é…±çš„solu#1ã€‚ python the heapq implementation is a bit messy, while involving max heapq. python heapq library default heap is min-heap. filp all nums to -num to a heap, then it becomes a max-heap. Recover while pop.\n  Algo æƒ³æ³•æŒºç®€å•ä½†å¾ˆå·§: åˆ†ä¸¤å †ï¼šsmall (max-heap) åœ¨å·¦ï¼Œlarge (min-heap)åœ¨å³ã€‚\n Step1: add number to small heap while num \u0026lt;= small[0] Step2: balancing two heaps, 0\u0026lt;=len(small)-len(large)\u0026lt;2    class MedianFinder: import heapq def __init__(self): self.large = [] # min heap, right heap self.small = [] # max heap, left heap def addNum(self, num: int) -\u0026gt; None: if not self.small or num \u0026lt;= -self.small[0] : #default heapq is min heap, use -1*num will turn it as max heapq heapq.heappush(self.small, -num) else: heapq.heappush(self.large, num) # balance two heaps if len(self.small) \u0026lt; len(self.large): heapq.heappush(self.small, -heapq.heappop(self.large)) elif len(self.small) - len(self.large) == 2: heapq.heappush(self.large, -heapq.heappop(self.small)) def findMedian(self) -\u0026gt; float: if len(self.small) == len(self.large): return (-self.small[0] + self.large[0])/2 else: return -self.small[0] # Your MedianFinder object will be instantiated and called as such: # obj = MedianFinder() # obj.addNum(num) # param_2 = obj.findMedian() # Time O(nlogn) # Space O(N)  ","id":37,"section":"posts","summary":"LC 295 Find Median From Data Stream Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Solution 2020-09-01 Notes: Follow äº†èŠ±èŠ±é…±çš„so","tags":["leetcode"],"title":"295 Find Median From Data Stream","uri":"https://foxisawesome.github.io/295-find-median-from-data-stream/","year":"2020"},{"content":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head l_tail = slow = fast = head while fast and fast.next: l_tail = slow slow = slow.next fast = fast.next.next l_tail.next = None l = self.sortList(head) r = self.sortList(slow) return self.mergeTwoSorted(l,r) def mergeTwoSorted(self, l1, l2): if not l1 and not l2: return None if not l1: return l2 if not l2: return l1 head = dummy = ListNode(0) while l1 and l2: if l1.val \u0026lt; l2.val: head.next = l1 l1 = l1.next else: head.next = l2 l2 = l2.next head = head.next head.next = l1 if l1 else l2 return dummy.next # Time O(nlogn): merge sort # Space O(1): actually not O(1), since recursion is not O(1)  ","id":38,"section":"posts","summary":"LC 148 Sort List   Sort a linked list in O(n log n) time using constant space complexity.\nExample 1:\nInput: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 Output: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4  Example 2:\nInput: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 Output: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5   Solution 2020-09-01 Notes:\n Time Complaxity O(nlogn) indicates merge sort algo. in the sortList, line 8:if not head or not head.next: return head actually returns head not None. slow and fast pointers to divide list into two need a lfet tail pointer: l_tail to cut off left linked list.","tags":["leetcode","linkedList"],"title":"148 Sort List","uri":"https://foxisawesome.github.io/148-sort-list/","year":"2020"},{"content":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true. Given word = \u0026quot;ABCB\u0026quot;, return false.   Solution 2020-09-01 Notes:\n classic DFS/backtracking problem. The biggest thing I\u0026rsquo;ve learnt from this: to return True/False instead of a list of retults. one needs to pass the true from bottom to top. Line 31-32 is doing this! Otherwise, if only line 23, on the the bottom DFS functions returns True, other lays return None.  class Solution: def exist(self, board: List[List[str]], word: str) -\u0026gt; bool: n = len(board) m = len(board[0]) directions = [[1,0], [-1,0], [0,1], [0,-1]] inits = [] for i in range(n): for j in range(m): if board[i][j] == word[0]: inits.append((i,j)) while inits: start = inits.pop() visited = set() visited.add(start) if self.dfs(board, word, directions, word[0], start, visited, m,n): return True return False def dfs(self, board, word, directions, path, point, visited,m,n): i, j = point[0], point[1] if path == word: return True for d in directions: x0, y0 = d[0], d[1] x1, y1 = x0+i, y0+j if 0\u0026lt;=x1\u0026lt;n and 0\u0026lt;=y1\u0026lt;m and (x1,y1) not in visited and board[x1][y1]==word[len(path)]: next_pt = (x1,y1) visited.add(next_pt) if self.dfs(board, word, directions, path+board[x1][y1],next_pt,visited,m,n): return True visited.remove(next_pt) # Time O(N*3^L), where L is the length of word # Space O(N)  ","id":39,"section":"posts","summary":"LC 79 Word Search   Given a 2D board and a word, find if the word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cell, where \u0026ldquo;adjacent\u0026rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample:\nboard = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \u0026quot;ABCCED\u0026quot;, return true. Given word = \u0026quot;SEE\u0026quot;, return true.","tags":["leetcode","backtracking","DFS"],"title":"79 Word Search","uri":"https://foxisawesome.github.io/79-word-search/","year":"2020"},{"content":"LC 981 Time Based Key Value Store   Create a timebased key-value store class TimeMap, that supports two operations.\n set(string key, string value, int timestamp)   Stores the key and value, along with the given timestamp.  get(string key, int timestamp)   Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are no values, it returns the empty string (\u0026quot;\u0026quot;).   Solution 2020-09-01 Notes:\n æŠ„äº†ä¸€éï¼šè¿™ä¸ªreference  class TimeMap: def __init__(self): self.v_ = collections.defaultdict(list) self.t_ = collections.defaultdict(list) def set(self, key: str, value: str, timestamp: int) -\u0026gt; None: self.t_[key].append(timestamp) self.v_[key].append(value) def get(self, key: str, timestamp: int) -\u0026gt; str: if key not in self.t_: return \u0026quot;\u0026quot; # bisect is efficient algo to search key i = bisect.bisect_right(self.t_[key], timestamp) if i: return self.v_[key][i-1] return \u0026quot;\u0026quot; # Your TimeMap object will be instantiated and called as such: # obj = TimeMap() # obj.set(key,value,timestamp) # param_2 = obj.get(key,timestamp)  ","id":40,"section":"posts","summary":"LC 981 Time Based Key Value Store Create a timebased key-value store class TimeMap, that supports two operations. set(string key, string value, int timestamp) Stores the key and value, along with the given timestamp. get(string key, int timestamp) Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev. If there are","tags":["leetcode"],"title":"981 Time Based Key Value Store","uri":"https://foxisawesome.github.io/981-time-based-key-value-store/","year":"2020"},{"content":"LC 1041 Robot Bounded in Circle \n On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions:\n \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right.  The robot performs the instructions given in order, and repeats them forever.\nReturn true if and only if there exists a circle in the plane such that the robot never leaves the circle.\n 2020-08-31 Notes:\n æ²¡è§è¿‡è¿™ç§implementationã€‚å¥½ç»å…¸çš„åšæ³•ï¼ŒäºŒåˆ·å¸Œæœ›èƒ½åˆ·å‡ºæ¥ã€‚  class Solution: def isRobotBounded(self, instructions: str) -\u0026gt; bool: # north = 0, east = 1, south = 2, west = 3 directions = [[0,1],[1,0],[0,-1],[-1,0]] x = y = 0 idx = 0 for i in instructions: if i == 'L': idx = (idx + 3) % 4 elif i == 'R': idx = (idx + 1) % 4 else: x += directions[idx][0] y += directions[idx][1] return (x==0 and y==0) or idx != 0  ","id":41,"section":"posts","summary":"LC 1041 Robot Bounded in Circle On an infinite plane, a robot initially stands at (0, 0) and faces north. The robot can receive one of three instructions: \u0026quot;G\u0026quot;: go straight 1 unit; \u0026quot;L\u0026quot;: turn 90 degrees to the left; \u0026quot;R\u0026quot;: turn 90 degress to the right. The robot performs the instructions given in order, and repeats them forever. Return true if and only if there exists a circle in","tags":["leetcode"],"title":"1041 Robot Bounded in Circle","uri":"https://foxisawesome.github.io/1041-robot-bounded-in-circle/","year":"2020"},{"content":"LC 957 Prison Cells \n There are 8 prison cells in a row, and each cell is either occupied or vacant.\nEach day, whether the cell is occupied or vacant changes according to the following rules:\n If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant.  (Note that because the prison is a row, the first and the last cells in the row can\u0026rsquo;t have two adjacent neighbors.)\nWe describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.\n 2020-08-31 Notes:\n  è¿™é¢˜åšäº†å¥½ä¹…ï¼Œå¥½å¤šcorner caseæ²¡è¿‡ã€‚æœ€åæ‰æ˜ç™½ï¼š\n  cycle = 14\n  two cases:\nâ€‹\ta. head in the cycle of 14; days %= 14\nâ€‹\tb. head not in the cycle of 14. in this case, days = (days-1)%14,\n    class Solution: def nextDay(self, cells): cells_nd = [0] for i in range(1,len(cells)-1): if cells[i-1] == cells[i+1]: cells_nd.append(1) else: cells_nd.append(0) cells_nd.append(0) return cells_nd def prisonAfterNDays(self, cells: List[int], N: int) -\u0026gt; List[int]: if not cells: return [] if N == 0: return cells memo = dict() memo[str(cells[:])] = 0 n = len(cells) for d in range(1,N+1): cells = self.nextDay(cells) print(d,cells) if str(cells) in memo: cycle = d - memo[str(cells)] break memo[str(cells[:])] = d # cycle is always 14. But two cases: 1. head is in the cycle; 2. head is not in the cycle. if d \u0026lt; N: if memo[str(cells)]==0: # head in the cycle case days = (N)%cycle else: # head not in the cycle case. days = (N-1)%cycle for d in range(days): cells = self.nextDay(cells) return cells  ","id":42,"section":"posts","summary":"LC 957 Prison Cells There are 8 prison cells in a row, and each cell is either occupied or vacant. Each day, whether the cell is occupied or vacant changes according to the following rules: If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied. Otherwise, it becomes vacant. (Note that because the prison is a row, the first and the","tags":["leetcode"],"title":"957 Prison Cells","uri":"https://foxisawesome.github.io/957-prison-cells/","year":"2020"},{"content":"LC 735 Aseroid Collision \n We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.\nExample 1:\nInput: asteroids = [5, 10, -5] Output: [5, 10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.  Example 2:\nInput: asteroids = [8, -8] Output: [] Explanation: The 8 and -8 collide exploding each other.  Example 3:\nInput: asteroids = [10, 2, -5] Output: [10] Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.  Example 4:\nInput: asteroids = [-2, -1, 1, 2] Output: [-2, -1, 1, 2] Explanation: The -2 and -1 are moving left, while the 1 and 2 are moving right. Asteroids moving the same direction never meet, so no asteroids will meet each other.   2020-08-31 Notes:\n ä¸€æ¬¡å°±åšå¯¹äº†å¦‚ä¸‹ã€‚è™½ç„¶ä¸ç®€æ´ï¼Œä½†èƒ½ç”¨ä¸Šrecursionï¼Œä¹Ÿç®—æŒºå¼€å¿ƒäº†ã€‚ ä¸€çœ‹å®˜æ–¹è§£ç­”ï¼Œè·Ÿç®€æ´ï¼Œèƒ½combine å¾ˆå¤šçš„caseã€‚è€Œä¸”æœ€å…³é”®çš„ï¼šwhile+ continue+breakçš„ç»„åˆå®Œç¾çš„ç»•å¼€äº†recursionçš„åšæ³•ã€‚çœ‹äº†ä¸‹æ—¶é—´æ¯”è¾ƒå·®è·ä¸å¤§ã€‚  class Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: stack = self.helper(stack, a) return stack def helper(self, stack, a): if not stack: stack.append(a) elif stack[-1] * a \u0026gt; 0 or stack[-1] \u0026lt; 0 and a \u0026gt; 0: stack.append(a) elif abs(stack[-1]) == abs(a): stack.pop() elif abs(stack[-1]) \u0026lt; abs(a): stack.pop() return self.helper(stack, a) return stack # Time O(N) # Space O(N)  å®˜æ–¹è§£ç­”ï¼š\nclass Solution: def asteroidCollision(self, asteroids: List[int]) -\u0026gt; List[int]: if not asteroids: return [] stack = [asteroids[0]] for a in asteroids[1:]: while stack and a \u0026lt; 0 \u0026lt; stack[-1]: if stack[-1] \u0026lt; -a: stack.pop() continue elif stack[-1] == -a: stack.pop() break else: stack.append(a) return stack  ","id":43,"section":"posts","summary":"LC 735 Aseroid Collision We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size,","tags":["leetcode","recursion","stack"],"title":"735 Aseroid Collision","uri":"https://foxisawesome.github.io/735-aseroid-collision/","year":"2020"},{"content":"LC 141 Linked List Cycle \n Given a linked list, determine if it has a cycle in it.\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where tail connects to the second node.   08/29/2020 Notes:\n Fast two steps at a time, slow pointer one step a time. ä¸€æ¬¡ä¹Ÿå°±è¿‡äº†ã€‚  class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: if not head: return slow = fast = head while fast and slow and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False  ","id":44,"section":"posts","summary":"LC 141 Linked List Cycle Given a linked list, determine if it has a cycle in it. To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There","tags":["leetcode","linkedList"],"title":"141 Linked List Cycle","uri":"https://foxisawesome.github.io/141-linked-list-cycle/","year":"2020"},{"content":"LC 328\n Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.\nYou should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.\nExample 1:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL   linked list ç»ˆäºåœ¨å‘¨æœ«åˆ·å‡ºæ„Ÿè§‰äº†ã€‚è¿™é¢˜ä¹Ÿä¸€éå°±è¿‡äº†ã€‚\nclass Solution: def oddEvenList(self, head: ListNode) -\u0026gt; ListNode: if not head: return odd = p1 = ListNode(1) even = p2 = ListNode(0) count = 1 while head: if count % 2 == 1: odd.next = ListNode(head.val) odd = odd.next else: even.next = ListNode(head.val) even = even.next head = head.next count += 1 odd.next = p2.next return p1.next  ","id":45,"section":"posts","summary":"LC 328 Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 1-\u0026gt;3-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;NULL linked list ç»ˆäºåœ¨å‘¨æœ«åˆ·å‡ºæ„Ÿ","tags":["leetcode","linkedList"],"title":"328 Odd Even Linked List","uri":"https://foxisawesome.github.io/328-odd-even-linked-list/","year":"2020"},{"content":"LC 1266\n On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.\nYou can move according to the next rules:\n In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to visit the points in the same order as they appear in the array.   ä¸€éå°±è¿‡çš„é¢˜ï¼Œæ²¡å•¥å¥½è¯´çš„ã€‚\nclass Solution: def minTimeToVisitAllPoints(self, points: List[List[int]]) -\u0026gt; int: n = len(points) m = len(points[0]) time = 0 if not points or n == 0 or m == 0: return time for i in range(1, n): x1, y1 = points[i-1] x2, y2 = points[i] time += max(abs(x1-x2), abs(y1-y2)) return time  ","id":46,"section":"posts","summary":"LC 1266 On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points. You can move according to the next rules: In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second). You have to","tags":["leetcode"],"title":"1266 Minimum Time Visiting All Points","uri":"https://foxisawesome.github.io/1266-minimum-time-visiting-all-points/","year":"2020"},{"content":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:\n BST has a property that: if in-order traverse, the output is a sorted list. Time complex is O(N), if store everything, then space complexity is O(N). I can only maintain min_diff in each root step to reduce space complexity to O(1). recursion here is pretty easy: standard in-order traversal recursion.  # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def getMinimumDifference(self, root: TreeNode) -\u0026gt; int: self.prev = None self.min_diff = float('inf') self.inorder(root) return self.min_diff def inorder(self, root): if not root: return self.inorder(root.left) if self.prev is not None: self.min_diff = min(self.min_diff, root.val - self.prev) self.prev = root.val self.inorder(root.right)  ","id":47,"section":"posts","summary":"LC 530\nGiven a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\n Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.\nExample:\nInput: 1 \\ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).   8/30/2020 Note:","tags":["leetcode","tree","BST"],"title":"530 Min Abs Dif BST","uri":"https://foxisawesome.github.io/530-min-abs-dif-bst/","year":"2020"},{"content":"LC 98 Valid BST\nGiven a binary tree, determine if it is a valid binary search tree (BST).\nAssume a BST is defined as follows:\n The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.  Example 1:\n 2 / \\ 1 3 Input: [2,1,3] Output: true  Example 2:\n 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.  08/30/2020 Notes:\n two ways: 1. Check if a sorted list returned after in-order traversal. 2. check if alway root.right.val \u0026gt; root.val \u0026gt; root.left.val I used the first way. è¿™åˆæ˜¯ä¸ªå¾ˆé«˜çº§çš„recursionã€‚  class Solution: def isValidBST(self, root: TreeNode) -\u0026gt; bool: self.prev = None return self.inorder(root) def inorder(self, root): if not root: return True if not self.inorder(root.left): return False if self.prev is not None and root.val \u0026lt;= self.prev: return False self.prev = root.val return self.inorder(root.right)  ","id":48,"section":"posts","summary":"LC 98 Valid BST Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees. Example","tags":["leetcode","tree","BST"],"title":"98 Valid BST","uri":"https://foxisawesome.github.io/98-valid-bst/","year":"2020"},{"content":"LC 701\n Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.\nNote that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.\nFor example,\nGiven the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5  You can return this binary search tree:\n 4 / \\ 2 7 / \\ / 1 3 5  This tree is also valid:\n 5 / \\ 2 7 / \\ 1 3 \\ 4   08/30/2020 Notes:\n è¿™ä¸ªrecursion å¥½é«˜çº§ï¼Œä¼¼æ‡‚éæ‡‚å›å¤´è¿˜å¾—åœ¨åˆ·ã€‚ ä¸€å®šè¦æ˜ç¡® resursion function return çš„æ˜¯ä»€ä¹ˆã€‚ è¿™ä¸ªreturnçš„æ˜¯TreeNodeã€‚  9/10/2020 Note:\nåˆ·äº†ä¸€é˜µtreeä¹‹åç»ˆäºææ‡‚äº†ï¼Œç»™treeæ·»åŠ leaf nodeçš„æ“ä½œæ˜¯ root.left = TreeNode(val), æ‰€ä»¥if not root: return root.val. æœ€åæ·»åŠ å®Œä¹‹åå°±æ˜¯returnè¿™ä¸ªroot ä¸€å±‚ä¸€å±‚è¿”å›ã€‚\n# Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def insertIntoBST(self, root: TreeNode, val: int) -\u0026gt; TreeNode: if not root: return TreeNode(val) if root.val \u0026lt; val: root.right = self.insertIntoBST(root.right, val) else: root.left = self.insertIntoBST(root.left, val) return root  ","id":49,"section":"posts","summary":"LC 701 Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST","tags":["leetcode","tree","BST"],"title":"701 Insert Into BST","uri":"https://foxisawesome.github.io/701-insert-into-bst/","year":"2020"},{"content":"æ»‘åŠ¨çª—å£ç®—æ³•çš„æ€è·¯æ˜¯è¿™æ ·ï¼š\n1ã€æˆ‘ä»¬åœ¨å­—ç¬¦ä¸²Sä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ–left = right = 0ï¼ŒæŠŠç´¢å¼•å·¦é—­å³å¼€åŒºé—´[left, right)ç§°ä¸ºä¸€ä¸ªã€Œçª—å£ã€ã€‚\n2ã€æˆ‘ä»¬å…ˆä¸æ–­åœ°å¢åŠ rightæŒ‡é’ˆæ‰©å¤§çª—å£[left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼ˆåŒ…å«äº†Tä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰ã€‚\n3ã€æ­¤æ—¶ï¼Œæˆ‘ä»¬åœæ­¢å¢åŠ rightï¼Œè½¬è€Œä¸æ–­å¢åŠ leftæŒ‡é’ˆç¼©å°çª—å£[left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ä¸å†ç¬¦åˆè¦æ±‚ï¼ˆä¸åŒ…å«Tä¸­çš„æ‰€æœ‰å­—ç¬¦äº†ï¼‰ã€‚åŒæ—¶ï¼Œæ¯æ¬¡å¢åŠ leftï¼Œæˆ‘ä»¬éƒ½è¦æ›´æ–°ä¸€è½®ç»“æœã€‚\n4ã€é‡å¤ç¬¬ 2 å’Œç¬¬ 3 æ­¥ï¼Œç›´åˆ°rightåˆ°è¾¾å­—ç¬¦ä¸²Sçš„å°½å¤´ã€‚\nè¿™ä¸ªæ€è·¯å…¶å®ä¹Ÿä¸éš¾ï¼Œç¬¬ 2 æ­¥ç›¸å½“äºåœ¨å¯»æ‰¾ä¸€ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œç„¶åç¬¬ 3 æ­¥åœ¨ä¼˜åŒ–è¿™ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä¹Ÿå°±æ˜¯æœ€çŸ­çš„è¦†ç›–å­ä¸²ã€‚å·¦å³æŒ‡é’ˆè½®æµå‰è¿›ï¼Œçª—å£å¤§å°å¢å¢å‡å‡ï¼Œçª—å£ä¸æ–­å‘å³æ»‘åŠ¨ï¼Œè¿™å°±æ˜¯ã€Œæ»‘åŠ¨çª—å£ã€è¿™ä¸ªåå­—çš„æ¥å†ã€‚\nrefrence: wx:labuladong\nCode Template:\ndef slidingWindow(s: str, t: str) -\u0026gt; str: target, window = {}, {} for i in t: target[i] = target.get(i,0) + 1 left, right, valid = 0, 0, 0 while (right \u0026lt; len(s)): # expand window right point to contain all t c = s[right] # move right index right += 1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... # /*** debug è¾“å‡ºçš„ä½ç½® ***/ print('s: '+s2[left:right]+' window' + str(window) + ' valid: ' + str(valid)) # see if needs to shrink window while (window shrinking condition): d = s[left] left += 1 # è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... return ...  ","id":50,"section":"posts","summary":"æ»‘åŠ¨çª—å£ç®—æ³•çš„æ€è·¯æ˜¯è¿™æ ·ï¼š 1ã€æˆ‘ä»¬åœ¨å­—ç¬¦ä¸²Sä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ–left = right = 0ï¼ŒæŠŠç´¢å¼•å·¦é—­å³å¼€åŒºé—´[left, right)","tags":["template"],"title":"Sliding Window Note","uri":"https://foxisawesome.github.io/sliding-window-note/","year":"2020"},{"content":"å¼€å§‹åˆ·Leetcode å¥½å‡ ä¸ªæœˆäº†ï¼Œä»Šå¤©å¼€å§‹å­¦å¾ˆå¤šäººç”¨blog è®°å½•ä¸‹è‡ªå·±çš„notesï¼Œä¹Ÿæ¿€åŠ±è‡ªå·±å¥½å¥½åˆ·é¢˜ï¼First post!\nIt takes a while for me to get how exactly Linked List works. I used following utility functions to keep my leetcode solutions and run codes locally.\nNote:\n say head = ListNode(0), then head = head.next is to iterate to next node on the Linked List. use head.next = a to point to next node.  # My liked list utility functions: class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def list2ListNode(list): head = LinkedList = ListNode(0) for i in range(len(list)): LinkedList.next = ListNode(list[i]) LinkedList = LinkedList.next return head.next def printListNode(p): head = ListNode(0) head.next = p out = [] while p: out.append(p.val) p = p.next return out # e.g.: indata = [1,2,3,4,5,6] head = ListNode.list2ListNode(indata) ListNode.printListNode(head)  ","id":51,"section":"posts","summary":"å¼€å§‹åˆ·Leetcode å¥½å‡ ä¸ªæœˆäº†ï¼Œä»Šå¤©å¼€å§‹å­¦å¾ˆå¤šäººç”¨blog è®°å½•ä¸‹è‡ªå·±çš„notesï¼Œä¹Ÿæ¿€åŠ±è‡ªå·±å¥½å¥½åˆ·é¢˜ï¼First post! It takes a while for me to get how exactly Linked List","tags":["template","linkedList"],"title":"Linked List Note (First Post)","uri":"https://foxisawesome.github.io/linked-list-note/","year":"2020"},{"content":"LC 42 Trapping Rain Water   Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\n Solution 2020-08-05 Notes:\n çŸ­è¾¹åŸç†ï¼Œå·¦å³æŒ‡é’ˆåŒæ—¶èµ°ï¼Œr_max å¤§æ—¶çŸ­è¾¹åœ¨leftï¼Œæ‰€ä»¥è®¡ç®—left sideã€‚ æ¯ä¸€æ ¼è®¡ç®—ä¸‹ç›¸è¾ƒäºçŸ­è¾¹çš„å®¹æ°´é‡å³å¯  å·¦å³æŒ‡é’ˆçš„ while loopï¼Œè®¾ä¸º l\u0026lt;=r æˆ–è€… äº†l\u0026lt;r éƒ½ä¸€æ ·ï¼Œå› ä¸ºl=rè·³å‡ºæ—¶åªå¯èƒ½r_max = l_max = height[r]=height[l], water=0.    class Solution: def trap(self, height: List[int]) -\u0026gt; int: if not height: return 0 l, r = 0, len(height)-1 l_max, r_max = height[0], height[-1] ans = 0 while l \u0026lt; r: l_max = max(l_max, height[l]) r_max = max(r_max, height[r]) if l_max \u0026lt; r_max: ans += l_max - height[l] l += 1 else: ans += r_max - height[r] r -= 1 return ans # Time O(N) # Space O(1)  ","id":52,"section":"posts","summary":"LC 42 Trapping Rain Water Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. Solution 2020-08-05 Notes: çŸ­è¾¹åŸç†ï¼Œå·¦å³æŒ‡é’ˆåŒæ—¶èµ°ï¼Œr_max å¤§æ—¶çŸ­è¾¹åœ¨leftï¼Œæ‰€ä»¥è®¡ç®—lef","tags":["leetcode"],"title":"42 Trapping Rain Water","uri":"https://foxisawesome.github.io/42-trapping-rain-water/","year":"2020"},{"content":"LC 206 Reverse Linked List   Reverse a singly linked list.\nExample:\nInput: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL   Solution 2020-09-01 Notes:\n  è¿™é¢˜åˆ·äº†ä¸ä¸‹10éäº†ï¼Œç»ˆäºæ˜ç™½iterationè¿™é‡Œçš„å››æ­¥æ“ä½œäº†ã€‚\n  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: # iteration def reverseList_iter(self, head: ListNode) -\u0026gt; ListNode: if not head: return None prev = None curr = head while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev   recursionçš„åšæ³•è¿˜æ˜¯ä¼¼æ‡‚éæ‡‚ï¼Œè¿˜å¾—å†çœ‹çœ‹ã€‚æ„Ÿè§‰TreeNode, ListNode çš„recursion éƒ½æ˜¯if not head/root: return head/rootã€‚ å¦å¤–ï¼Œrecession è¿™é‡Œè¿”å›çš„æ˜¯ ä»¥head.nextä¸ºå¤´reversed çš„listï¼Œåªéœ€è¦å†æŠŠhead.next\t reverse ä¸‹å°±å¥½äº†ã€‚  # recursion def reverseList_rec(self, head: ListNode) -\u0026gt; ListNode: if not head or not head.next: return head p = self.reverseList(head.next) head.next.next = head head.next = None return p # Time O(N) for iteration # Space O(1)  ","id":53,"section":"posts","summary":"LC 206 Reverse Linked List Reverse a singly linked list. Example: Input: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL Output: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL Solution 2020-09-01 Notes: è¿™é¢˜åˆ·äº†ä¸ä¸‹10éäº†ï¼Œç»ˆäºæ˜ç™½iterationè¿™é‡Œçš„å››æ­¥æ“ä½œäº†ã€‚ # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next","tags":["leetcode","linkedList"],"title":"206 Reverse Linked List","uri":"https://foxisawesome.github.io/206-reverse-linked-list/","year":"2020"},{"content":"LC 2 Add Two Num   You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample:\nInput: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt; 6 -\u0026gt; 4) Output: 7 -\u0026gt; 0 -\u0026gt; 8 Explanation: 342 + 465 = 807.   Solution 2020-07-02 Notes:\n æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯ donâ€™t forget line 17 and 25ã€‚  # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u0026gt; ListNode: head = out = ListNode(0) carry = 0 while l1 and l2: carry, m = divmod(l1.val + l2.val + carry, 10) out.next = ListNode(m) l1 = l1.next l2 = l2.next out = out.next l = l1 if l1 else l2 while l: carry, m = divmod(l.val + carry, 10) out.next = ListNode(m) out = out.next l = l.next if carry \u0026gt; 0: out.next = ListNode(carry) return head.next # Time O(N) # Space O(1)  ","id":54,"section":"posts","summary":"LC 2 Add Two Num You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -\u0026gt; 4 -\u0026gt; 3) + (5 -\u0026gt;","tags":["leetcode","linkedList"],"title":"2 Add Two Num","uri":"https://foxisawesome.github.io/2-add-two-num/","year":"2020"},{"content":"LC 69 Sqrtx   Implement int sqrt(int x).\nSqrt(8) = 2\n Solution 2020-03-07 Notes:\n æ ‡å‡†çš„binary search æ¨¡ç‰ˆï¼Œ right ä»x//2å¼€å§‹ã€‚  class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x: return mid elif mid**2 \u0026gt; x: right = mid -1 elif mid**2 \u0026lt; x: left = mid + 1 # exit at [right, left], hence return right return right # Time O(logN) # Space O(1)  ","id":55,"section":"posts","summary":"LC 69 Sqrtx Implement int sqrt(int x). Sqrt(8) = 2 Solution 2020-03-07 Notes: æ ‡å‡†çš„binary search æ¨¡ç‰ˆï¼Œ right ä»x//2å¼€å§‹ã€‚ class Solution: def mySqrt(self, x: int) -\u0026gt; int: if x \u0026lt; 2: return x left = 1 right = x//2 while left \u0026lt;= right: mid = left + (right - left)//2 if mid**2 == x:","tags":["leetcode","binarySearch"],"title":"69 Sqrtx","uri":"https://foxisawesome.github.io/69-sqrtx/","year":"2020"},{"content":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","id":56,"section":"posts","summary":"LC 1 Two Sum   Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have *exactly* one solution, and you may not use the same element twice.\n Solution 2020-02-01 Notes:\n use hash table, one-pass.  class Solution: def twoSum(self, nums: List[int], target: int) -\u0026gt; List[int]: if not nums or target is None: return [] d = dict() for i, val in enumerate(nums): if target - val not in d: d[val] = i else: return [d[target - val], i] # Time O(N) # Space O(N)  ","tags":["leetcode","array","dictionary"],"title":"1 Two Sum","uri":"https://foxisawesome.github.io/1-two-sum/","year":"2020"}],"tags":[{"title":"array","uri":"https://foxisawesome.github.io/tags/array/"},{"title":"backtracking","uri":"https://foxisawesome.github.io/tags/backtracking/"},{"title":"binarySearch","uri":"https://foxisawesome.github.io/tags/binarysearch/"},{"title":"BST","uri":"https://foxisawesome.github.io/tags/bst/"},{"title":"DFS","uri":"https://foxisawesome.github.io/tags/dfs/"},{"title":"dictionary","uri":"https://foxisawesome.github.io/tags/dictionary/"},{"title":"dp","uri":"https://foxisawesome.github.io/tags/dp/"},{"title":"hashtable","uri":"https://foxisawesome.github.io/tags/hashtable/"},{"title":"kmeans","uri":"https://foxisawesome.github.io/tags/kmeans/"},{"title":"leetcode","uri":"https://foxisawesome.github.io/tags/leetcode/"},{"title":"linkedList","uri":"https://foxisawesome.github.io/tags/linkedlist/"},{"title":"recursion","uri":"https://foxisawesome.github.io/tags/recursion/"},{"title":"stack","uri":"https://foxisawesome.github.io/tags/stack/"},{"title":"template","uri":"https://foxisawesome.github.io/tags/template/"},{"title":"tree","uri":"https://foxisawesome.github.io/tags/tree/"},{"title":"twopointers","uri":"https://foxisawesome.github.io/tags/twopointers/"}]}